/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from './engine';
import { env } from './environment';
import { Tensor } from './tensor';
import { assert, flatten, inferDtype, isTypedArray, toTypedArray } from './util';
import { bytesPerElement } from './util_base';
export function inferShape(val, dtype) {
    let firstElem = val;
    if (isTypedArray(val)) {
        return dtype === 'string' ? [] : [val.length];
    }
    const isObject = typeof val === 'object';
    if (isObject) {
        if ('texture' in val) {
            const usedChannels = val.channels || 'RGBA';
            return [val.height, val.width * usedChannels.length];
        }
        else if ('buffer' in val && !(val.buffer instanceof ArrayBuffer)) {
            return [val.buffer.size / (dtype == null ? 4 : bytesPerElement(dtype))];
        }
    }
    if (!Array.isArray(val)) {
        return []; // Scalar.
    }
    const shape = [];
    while (Array.isArray(firstElem) ||
        isTypedArray(firstElem) && dtype !== 'string') {
        shape.push(firstElem.length);
        firstElem = firstElem[0];
    }
    if (Array.isArray(val) &&
        env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {
        deepAssertShapeConsistency(val, shape, []);
    }
    return shape;
}
function deepAssertShapeConsistency(val, shape, indices) {
    indices = indices || [];
    if (!(Array.isArray(val)) && !isTypedArray(val)) {
        assert(shape.length === 0, () => `Element arr[${indices.join('][')}] is a primitive, ` +
            `but should be an array/TypedArray of ${shape[0]} elements`);
        return;
    }
    assert(shape.length > 0, () => `Element arr[${indices.join('][')}] should be a primitive, ` +
        `but is an array of ${val.length} elements`);
    assert(val.length === shape[0], () => `Element arr[${indices.join('][')}] should have ${shape[0]} ` +
        `elements, but has ${val.length} elements`);
    const subShape = shape.slice(1);
    for (let i = 0; i < val.length; ++i) {
        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
    }
}
function assertDtype(expectedDtype, actualDType, argName, functionName) {
    if (expectedDtype === 'string_or_numeric') {
        return;
    }
    if (expectedDtype == null) {
        throw new Error(`Expected dtype cannot be null.`);
    }
    if (expectedDtype !== 'numeric' && expectedDtype !== actualDType ||
        expectedDtype === 'numeric' && actualDType === 'string') {
        throw new Error(`Argument '${argName}' passed to '${functionName}' must ` +
            `be ${expectedDtype} tensor, but got ${actualDType} tensor`);
    }
}
export function convertToTensor(x, argName, functionName, parseAsDtype = 'numeric') {
    if (x instanceof Tensor) {
        assertDtype(parseAsDtype, x.dtype, argName, functionName);
        return x;
    }
    let inferredDtype = inferDtype(x);
    // If the user expects a bool/int/float, use that info to update the
    // inferredDtype when it is not a string.
    if (inferredDtype !== 'string' &&
        ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {
        inferredDtype = parseAsDtype;
    }
    assertDtype(parseAsDtype, inferredDtype, argName, functionName);
    if ((x == null) ||
        (!isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' &&
            typeof x !== 'boolean' && typeof x !== 'string')) {
        const type = x == null ? 'null' : x.constructor.name;
        throw new Error(`Argument '${argName}' passed to '${functionName}' must be a ` +
            `Tensor or TensorLike, but got '${type}'`);
    }
    const inferredShape = inferShape(x, inferredDtype);
    if (!isTypedArray(x) && !Array.isArray(x)) {
        x = [x];
    }
    const skipTypedArray = true;
    const values = inferredDtype !== 'string' ?
        toTypedArray(x, inferredDtype) :
        flatten(x, [], skipTypedArray);
    return ENGINE.makeTensor(values, inferredShape, inferredDtype);
}
export function convertToTensorArray(arg, argName, functionName, parseAsDtype = 'numeric') {
    if (!Array.isArray(arg)) {
        throw new Error(`Argument ${argName} passed to ${functionName} must be a ` +
            '`Tensor[]` or `TensorLike[]`');
    }
    const tensors = arg;
    return tensors.map((t, i) => convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVuc29yX3V0aWxfZW52LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy90ZW5zb3JfdXRpbF9lbnYudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUNoQyxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ2xDLE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFFaEMsT0FBTyxFQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDL0UsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUU1QyxNQUFNLFVBQVUsVUFBVSxDQUN0QixHQUFvQyxFQUFFLEtBQWdCO0lBQ3hELElBQUksU0FBUyxHQUFlLEdBQUcsQ0FBQztJQUVoQyxJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNyQixPQUFPLEtBQUssS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDL0M7SUFDRCxNQUFNLFFBQVEsR0FBRyxPQUFPLEdBQUcsS0FBSyxRQUFRLENBQUM7SUFDekMsSUFBSSxRQUFRLEVBQUU7UUFDWixJQUFJLFNBQVMsSUFBSSxHQUFHLEVBQUU7WUFDcEIsTUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUM7WUFDNUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDdEQ7YUFBTSxJQUFJLFFBQVEsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FB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QUcsRUFBRSxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUMsQ0FBQztBQUM5RSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0VOR0lORX0gZnJvbSAnLi9lbmdpbmUnO1xuaW1wb3J0IHtlbnZ9IGZyb20gJy4vZW52aXJvbm1lbnQnO1xuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4vdGVuc29yJztcbmltcG9ydCB7RGF0YVR5cGUsIFRlbnNvckxpa2UsIFdlYkdMRGF0YSwgV2ViR1BVRGF0YX0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge2Fzc2VydCwgZmxhdHRlbiwgaW5mZXJEdHlwZSwgaXNUeXBlZEFycmF5LCB0b1R5cGVkQXJyYXl9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQge2J5dGVzUGVyRWxlbWVudH0gZnJvbSAnLi91dGlsX2Jhc2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gaW5mZXJTaGFwZShcbiAgICB2YWw6IFRlbnNvckxpa2V8V2ViR0xEYXRhfFdlYkdQVURhdGEsIGR0eXBlPzogRGF0YVR5cGUpOiBudW1iZXJbXSB7XG4gIGxldCBmaXJzdEVsZW06IHR5cGVvZiB2YWwgPSB2YWw7XG5cbiAgaWYgKGlzVHlwZWRBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuIGR0eXBlID09PSAnc3RyaW5nJyA/IFtdIDogW3ZhbC5sZW5ndGhdO1xuICB9XG4gIGNvbnN0IGlzT2JqZWN0ID0gdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG4gIGlmIChpc09iamVjdCkge1xuICAgIGlmICgndGV4dHVyZScgaW4gdmFsKSB7XG4gICAgICBjb25zdCB1c2VkQ2hhbm5lbHMgPSB2YWwuY2hhbm5lbHMgfHwgJ1JHQkEnO1xuICAgICAgcmV0dXJuIFt2YWwuaGVpZ2h0LCB2YWwud2lkdGggKiB1c2VkQ2hhbm5lbHMubGVuZ3RoXTtcbiAgICB9IGVsc2UgaWYgKCdidWZmZXInIGluIHZhbCAmJiAhKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBbdmFsLmJ1ZmZlci5zaXplIC8gKGR0eXBlID09IG51bGwgPyA0IDogYnl0ZXNQZXJFbGVtZW50KGR0eXBlKSldO1xuICAgIH1cbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBbXTsgIC8vIFNjYWxhci5cbiAgfVxuICBjb25zdCBzaGFwZTogbnVtYmVyW10gPSBbXTtcblxuICB3aGlsZSAoQXJyYXkuaXNBcnJheShmaXJzdEVsZW0pIHx8XG4gICAgICAgICBpc1R5cGVkQXJyYXkoZmlyc3RFbGVtKSAmJiBkdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICBzaGFwZS5wdXNoKGZpcnN0RWxlbS5sZW5ndGgpO1xuICAgIGZpcnN0RWxlbSA9IGZpcnN0RWxlbVswXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpICYmXG4gICAgICBlbnYoKS5nZXRCb29sKCdURU5TT1JMSUtFX0NIRUNLX1NIQVBFX0NPTlNJU1RFTkNZJykpIHtcbiAgICBkZWVwQXNzZXJ0U2hhcGVDb25zaXN0ZW5jeSh2YWwsIHNoYXBlLCBbXSk7XG4gIH1cblxuICByZXR1cm4gc2hhcGU7XG59XG5cbmZ1bmN0aW9uIGRlZXBBc3NlcnRTaGFwZUNvbnNpc3RlbmN5KFxuICAgIHZhbDogVGVuc29yTGlrZSwgc2hhcGU6IG51bWJlcltdLCBpbmRpY2VzOiBudW1iZXJbXSkge1xuICBpbmRpY2VzID0gaW5kaWNlcyB8fCBbXTtcbiAgaWYgKCEoQXJyYXkuaXNBcnJheSh2YWwpKSAmJiAhaXNUeXBlZEFycmF5KHZhbCkpIHtcbiAgICBhc3NlcnQoXG4gICAgICAgIHNoYXBlLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgKCkgPT4gYEVsZW1lbnQgYXJyWyR7aW5kaWNlcy5qb2luKCddWycpfV0gaXMgYSBwcmltaXRpdmUsIGAgK1xuICAgICAgICAgICAgYGJ1dCBzaG91bGQgYmUgYW4gYXJyYXkvVHlwZWRBcnJheSBvZiAke3NoYXBlWzBdfSBlbGVtZW50c2ApO1xuICAgIHJldHVybjtcbiAgfVxuICBhc3NlcnQoXG4gICAgICBzaGFwZS5sZW5ndGggPiAwLFxuICAgICAgKCkgPT4gYEVsZW1lbnQgYXJyWyR7aW5kaWNlcy5qb2luKCddWycpfV0gc2hvdWxkIGJlIGEgcHJpbWl0aXZlLCBgICtcbiAgICAgICAgICBgYnV0IGlzIGFuIGFycmF5IG9mICR7dmFsLmxlbmd0aH0gZWxlbWVudHNgKTtcbiAgYXNzZXJ0KFxuICAgICAgdmFsLmxlbmd0aCA9PT0gc2hhcGVbMF0sXG4gICAgICAoKSA9PiBgRWxlbWVudCBhcnJbJHtpbmRpY2VzLmpvaW4oJ11bJyl9XSBzaG91bGQgaGF2ZSAke3NoYXBlWzBdfSBgICtcbiAgICAgICAgICBgZWxlbWVudHMsIGJ1dCBoYXMgJHt2YWwubGVuZ3RofSBlbGVtZW50c2ApO1xuICBjb25zdCBzdWJTaGFwZSA9IHNoYXBlLnNsaWNlKDEpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSkge1xuICAgIGRlZXBBc3NlcnRTaGFwZUNvbnNpc3RlbmN5KHZhbFtpXSwgc3ViU2hhcGUsIGluZGljZXMuY29uY2F0KGkpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnREdHlwZShcbiAgICBleHBlY3RlZER0eXBlOiBEYXRhVHlwZXwnbnVtZXJpYyd8J3N0cmluZ19vcl9udW1lcmljJyxcbiAgICBhY3R1YWxEVHlwZTogRGF0YVR5cGUsIGFyZ05hbWU6IHN0cmluZywgZnVuY3Rpb25OYW1lOiBzdHJpbmcpIHtcbiAgaWYgKGV4cGVjdGVkRHR5cGUgPT09ICdzdHJpbmdfb3JfbnVtZXJpYycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGV4cGVjdGVkRHR5cGUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgZHR5cGUgY2Fubm90IGJlIG51bGwuYCk7XG4gIH1cbiAgaWYgKGV4cGVjdGVkRHR5cGUgIT09ICdudW1lcmljJyAmJiBleHBlY3RlZER0eXBlICE9PSBhY3R1YWxEVHlwZSB8fFxuICAgICAgZXhwZWN0ZWREdHlwZSA9PT0gJ251bWVyaWMnICYmIGFjdHVhbERUeXBlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFyZ3VtZW50ICcke2FyZ05hbWV9JyBwYXNzZWQgdG8gJyR7ZnVuY3Rpb25OYW1lfScgbXVzdCBgICtcbiAgICAgICAgYGJlICR7ZXhwZWN0ZWREdHlwZX0gdGVuc29yLCBidXQgZ290ICR7YWN0dWFsRFR5cGV9IHRlbnNvcmApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9UZW5zb3I8VCBleHRlbmRzIFRlbnNvcj4oXG4gICAgeDogVHxUZW5zb3JMaWtlLCBhcmdOYW1lOiBzdHJpbmcsIGZ1bmN0aW9uTmFtZTogc3RyaW5nLFxuICAgIHBhcnNlQXNEdHlwZTogRGF0YVR5cGV8J251bWVyaWMnfCdzdHJpbmdfb3JfbnVtZXJpYycgPSAnbnVtZXJpYycpOiBUIHtcbiAgaWYgKHggaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICBhc3NlcnREdHlwZShwYXJzZUFzRHR5cGUsIHguZHR5cGUsIGFyZ05hbWUsIGZ1bmN0aW9uTmFtZSk7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgbGV0IGluZmVycmVkRHR5cGUgPSBpbmZlckR0eXBlKHgpO1xuICAvLyBJZiB0aGUgdXNlciBleHBlY3RzIGEgYm9vbC9pbnQvZmxvYXQsIHVzZSB0aGF0IGluZm8gdG8gdXBkYXRlIHRoZVxuICAvLyBpbmZlcnJlZER0eXBlIHdoZW4gaXQgaXMgbm90IGEgc3RyaW5nLlxuICBpZiAoaW5mZXJyZWREdHlwZSAhPT0gJ3N0cmluZycgJiZcbiAgICAgIFsnYm9vbCcsICdpbnQzMicsICdmbG9hdDMyJ10uaW5kZXhPZihwYXJzZUFzRHR5cGUpID49IDApIHtcbiAgICBpbmZlcnJlZER0eXBlID0gcGFyc2VBc0R0eXBlIGFzIERhdGFUeXBlO1xuICB9XG4gIGFzc2VydER0eXBlKHBhcnNlQXNEdHlwZSwgaW5mZXJyZWREdHlwZSwgYXJnTmFtZSwgZnVuY3Rpb25OYW1lKTtcblxuICBpZiAoKHggPT0gbnVsbCkgfHxcbiAgICAgICghaXNUeXBlZEFycmF5KHgpICYmICFBcnJheS5pc0FycmF5KHgpICYmIHR5cGVvZiB4ICE9PSAnbnVtYmVyJyAmJlxuICAgICAgIHR5cGVvZiB4ICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIHggIT09ICdzdHJpbmcnKSkge1xuICAgIGNvbnN0IHR5cGUgPSB4ID09IG51bGwgPyAnbnVsbCcgOiAoeCBhcyB7fSkuY29uc3RydWN0b3IubmFtZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBcmd1bWVudCAnJHthcmdOYW1lfScgcGFzc2VkIHRvICcke2Z1bmN0aW9uTmFtZX0nIG11c3QgYmUgYSBgICtcbiAgICAgICAgYFRlbnNvciBvciBUZW5zb3JMaWtlLCBidXQgZ290ICcke3R5cGV9J2ApO1xuICB9XG4gIGNvbnN0IGluZmVycmVkU2hhcGUgPSBpbmZlclNoYXBlKHgsIGluZmVycmVkRHR5cGUpO1xuICBpZiAoIWlzVHlwZWRBcnJheSh4KSAmJiAhQXJyYXkuaXNBcnJheSh4KSkge1xuICAgIHggPSBbeF0gYXMgbnVtYmVyW107XG4gIH1cbiAgY29uc3Qgc2tpcFR5cGVkQXJyYXkgPSB0cnVlO1xuICBjb25zdCB2YWx1ZXMgPSBpbmZlcnJlZER0eXBlICE9PSAnc3RyaW5nJyA/XG4gICAgICB0b1R5cGVkQXJyYXkoeCwgaW5mZXJyZWREdHlwZSBhcyBEYXRhVHlwZSkgOlxuICAgICAgZmxhdHRlbih4IGFzIHN0cmluZ1tdLCBbXSwgc2tpcFR5cGVkQXJyYXkpIGFzIHN0cmluZ1tdO1xuICByZXR1cm4gRU5HSU5FLm1ha2VUZW5zb3IodmFsdWVzLCBpbmZlcnJlZFNoYXBlLCBpbmZlcnJlZER0eXBlKSBhcyBUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvVGVuc29yQXJyYXk8VCBleHRlbmRzIFRlbnNvcj4oXG4gICAgYXJnOiBBcnJheTxUfFRlbnNvckxpa2U+LCBhcmdOYW1lOiBzdHJpbmcsIGZ1bmN0aW9uTmFtZTogc3RyaW5nLFxuICAgIHBhcnNlQXNEdHlwZTogRGF0YVR5cGV8J251bWVyaWMnfCdzdHJpbmdfb3JfbnVtZXJpYycgPSAnbnVtZXJpYycpOiBUW10ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEFyZ3VtZW50ICR7YXJnTmFtZX0gcGFzc2VkIHRvICR7ZnVuY3Rpb25OYW1lfSBtdXN0IGJlIGEgYCArXG4gICAgICAgICdgVGVuc29yW11gIG9yIGBUZW5zb3JMaWtlW11gJyk7XG4gIH1cbiAgY29uc3QgdGVuc29ycyA9IGFyZyBhcyBUW107XG4gIHJldHVybiB0ZW5zb3JzLm1hcChcbiAgICAgICh0LCBpKSA9PlxuICAgICAgICAgIGNvbnZlcnRUb1RlbnNvcih0LCBgJHthcmdOYW1lfVske2l9XWAsIGZ1bmN0aW9uTmFtZSwgcGFyc2VBc0R0eXBlKSk7XG59XG4iXX0=