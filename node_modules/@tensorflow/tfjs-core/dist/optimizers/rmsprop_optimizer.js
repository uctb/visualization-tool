/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../engine';
import { dispose, tidy } from '../globals';
import { add } from '../ops/add';
import { div } from '../ops/div';
import { mul } from '../ops/mul';
import { sqrt } from '../ops/sqrt';
import { square } from '../ops/square';
import { sub } from '../ops/sub';
import { zerosLike } from '../ops/zeros_like';
import { Optimizer } from './optimizer';
/** @doclink Optimizer */
export class RMSPropOptimizer extends Optimizer {
    constructor(learningRate, decay = 0.9, momentum = 0.0, epsilon = null, centered = false) {
        super();
        this.learningRate = learningRate;
        this.decay = decay;
        this.momentum = momentum;
        this.epsilon = epsilon;
        this.accumulatedMeanSquares = [];
        this.accumulatedMoments = [];
        this.accumulatedMeanGrads = [];
        this.centered = centered;
        if (epsilon == null) {
            this.epsilon = ENGINE.backend.epsilon();
        }
        if (learningRate == null) {
            throw new Error(`learningRate for RMSPropOptimizer must be defined.`);
        }
    }
    /** @nocollapse */
    static get className() {
        // Name matters for Python compatibility.
        // This is a getter instead of a property because when it's a property, it
        // prevents the entire class from being tree-shaken.
        return 'RMSProp';
    }
    applyGradients(variableGradients) {
        const variableNames = Array.isArray(variableGradients) ?
            variableGradients.map(item => item.name) :
            Object.keys(variableGradients);
        variableNames.forEach((name, i) => {
            const value = ENGINE.registeredVariables[name];
            const trainable = false;
            if (this.accumulatedMeanSquares[i] == null) {
                this.accumulatedMeanSquares[i] = {
                    originalName: `${name}/rms`,
                    variable: tidy(() => zerosLike(value).variable(trainable))
                };
            }
            if (this.accumulatedMoments[i] == null) {
                this.accumulatedMoments[i] = {
                    originalName: `${name}/momentum`,
                    variable: tidy(() => zerosLike(value).variable(trainable))
                };
            }
            if (this.accumulatedMeanGrads[i] == null && this.centered) {
                this.accumulatedMeanGrads[i] = {
                    originalName: `${name}/mg`,
                    variable: tidy(() => zerosLike(value).variable(trainable))
                };
            }
            const gradient = Array.isArray(variableGradients) ?
                variableGradients[i].tensor :
                variableGradients[name];
            if (gradient == null) {
                return;
            }
            const accumulatedMeanSquare = this.accumulatedMeanSquares[i].variable;
            const accumulatedMoments = this.accumulatedMoments[i].variable;
            tidy(() => {
                const newAccumulatedMeanSquare = add(mul(accumulatedMeanSquare, this.decay), mul(square(gradient), 1 - this.decay));
                if (this.centered) {
                    const accumulatedMeanGrad = this.accumulatedMeanGrads[i].variable;
                    // Centered gradient
                    const newAccumulatedMeanGrad = add(mul(accumulatedMeanGrad, this.decay), mul(gradient, 1 - this.decay));
                    const gradContribution = div(mul(gradient, this.learningRate), sqrt(sub(newAccumulatedMeanSquare, add(square(newAccumulatedMeanGrad), this.epsilon))));
                    const newAccumulatedMoments = add(mul(accumulatedMoments, this.momentum), gradContribution);
                    accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
                    accumulatedMeanGrad.assign(newAccumulatedMeanGrad);
                    accumulatedMoments.assign(newAccumulatedMoments);
                    const newValue = sub(value, newAccumulatedMoments);
                    value.assign(newValue);
                }
                else {
                    // Plain gradient
                    const newAccumulatedMeanSquare = add(mul(accumulatedMeanSquare, this.decay), mul(square(gradient), 1 - this.decay));
                    const newAccumulatedMoments = add(mul(accumulatedMoments, this.momentum), div(mul(gradient, this.learningRate), sqrt(add(newAccumulatedMeanSquare, this.epsilon))));
                    accumulatedMeanSquare.assign(newAccumulatedMeanSquare);
                    accumulatedMoments.assign(newAccumulatedMoments);
                    const newValue = sub(value, newAccumulatedMoments);
                    value.assign(newValue);
                }
            });
        });
        this.incrementIterations();
    }
    dispose() {
        if (this.accumulatedMeanSquares != null) {
            dispose(this.accumulatedMeanSquares.map(v => v.variable));
        }
        if (this.accumulatedMeanGrads != null && this.centered) {
            dispose(this.accumulatedMeanGrads.map(v => v.variable));
        }
        if (this.accumulatedMoments != null) {
            dispose(this.accumulatedMoments.map(v => v.variable));
        }
    }
    async getWeights() {
        // Order matters for Python compatibility.
        const variables = [...this.accumulatedMeanSquares, ...this.accumulatedMoments];
        if (this.centered) {
            variables.push(...this.accumulatedMeanGrads);
        }
        return [await this.saveIterations()].concat(variables.map(v => ({ name: v.originalName, tensor: v.variable })));
    }
    async setWeights(weightValues) {
        weightValues = await this.extractIterations(weightValues);
        const variableCount = this.centered ? weightValues.length / 3 : weightValues.length / 2;
        const trainable = false;
        this.accumulatedMeanSquares =
            weightValues.slice(0, variableCount).map(v => ({
                originalName: v.name,
                variable: v.tensor.variable(trainable)
            }));
        this.accumulatedMoments =
            weightValues.slice(variableCount, variableCount * 2)
                .map(v => ({
                originalName: v.name,
                variable: v.tensor.variable(trainable)
            }));
        if (this.centered) {
            this.accumulatedMeanGrads =
                weightValues.slice(variableCount * 2, variableCount * 3)
                    .map(v => ({
                    originalName: v.name,
                    variable: v.tensor.variable(trainable)
                }));
        }
    }
    getConfig() {
        return {
            'learningRate': this.learningRate,
            'decay': this.decay,
            'momentum': this.momentum,
            'epsilon': this.epsilon,
            'centered': this.centered
        };
    }
    /** @nocollapse */
    static fromConfig(cls, config) {
        return new cls(config['learningRate'], config['decay'], config['momentum'], config['epsilon'], config['centered']);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm1zcHJvcF9vcHRpbWl6ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsT0FBTyxFQUFFLElBQUksRUFBQyxNQUFNLFlBQVksQ0FBQztBQUN6QyxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQy9CLE9BQU8sRUFBQyxHQUFHLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDL0IsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUMvQixPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQ2pDLE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDckMsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUMvQixPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFJNUMsT0FBTyxFQUFDLFNBQVMsRUFBb0IsTUFBTSxhQUFhLENBQUM7QUFFekQseUJBQXlCO0FBQ3pCLE1BQU0sT0FBTyxnQkFBaUIsU0FBUSxTQUFTO0lBYzdDLFlBQ2MsWUFBb0IsRUFBWSxRQUFRLEdBQUcsRUFDM0MsV0FBVyxHQUFHLEVBQVksVUFBa0IsSUFBSSxFQUMxRCxRQUFRLEdBQUcsS0FBSztRQUNsQixLQUFLLEVBQUUsQ0FBQztRQUhJLGlCQUFZLEdBQVosWUFBWSxDQUFRO1FBQVksVUFBSyxHQUFMLEtBQUssQ0FBTTtRQUMzQyxhQUFRLEdBQVIsUUFBUSxDQUFNO1FBQVksWUFBTyxHQUFQLE9BQU8sQ0FBZTtRQU50RCwyQkFBc0IsR0FBd0IsRUFBRSxDQUFDO1FBQ2pELHVCQUFr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QUMsS0FBSztZQUNuQixVQUFVLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDekIsU0FBUyxFQUFFLElBQUksQ0FBQyxPQUFPO1lBQ3ZCLFVBQVUsRUFBRSxJQUFJLENBQUMsUUFBUTtTQUMxQixDQUFDO0lBQ0osQ0FBQztJQUVELGtCQUFrQjtJQUNsQixNQUFNLENBQVUsVUFBVSxDQUN0QixHQUErQixFQUFFLE1BQWtCO1FBQ3JELE9BQU8sSUFBSSxHQUFHLENBQ1YsTUFBTSxDQUFDLGNBQWMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRSxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQzNELE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUM3QyxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi9lbmdpbmUnO1xuaW1wb3J0IHtkaXNwb3NlLCB0aWR5fSBmcm9tICcuLi9nbG9iYWxzJztcbmltcG9ydCB7YWRkfSBmcm9tICcuLi9vcHMvYWRkJztcbmltcG9ydCB7ZGl2fSBmcm9tICcuLi9vcHMvZGl2JztcbmltcG9ydCB7bXVsfSBmcm9tICcuLi9vcHMvbXVsJztcbmltcG9ydCB7c3FydH0gZnJvbSAnLi4vb3BzL3NxcnQnO1xuaW1wb3J0IHtzcXVhcmV9IGZyb20gJy4uL29wcy9zcXVhcmUnO1xuaW1wb3J0IHtzdWJ9IGZyb20gJy4uL29wcy9zdWInO1xuaW1wb3J0IHt6ZXJvc0xpa2V9IGZyb20gJy4uL29wcy96ZXJvc19saWtlJztcbmltcG9ydCB7Q29uZmlnRGljdCwgU2VyaWFsaXphYmxlLCBTZXJpYWxpemFibGVDb25zdHJ1Y3Rvcn0gZnJvbSAnLi4vc2VyaWFsaXphdGlvbic7XG5pbXBvcnQge05hbWVkVGVuc29yLCBOYW1lZFRlbnNvck1hcH0gZnJvbSAnLi4vdGVuc29yX3R5cGVzJztcblxuaW1wb3J0IHtPcHRpbWl6ZXIsIE9wdGltaXplclZhcmlhYmxlfSBmcm9tICcuL29wdGltaXplcic7XG5cbi8qKiBAZG9jbGluayBPcHRpbWl6ZXIgKi9cbmV4cG9ydCBjbGFzcyBSTVNQcm9wT3B0aW1pemVyIGV4dGVuZHMgT3B0aW1pemVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBnZXQgY2xhc3NOYW1lKCkge1xuICAgIC8vIE5hbWUgbWF0dGVycyBmb3IgUHl0aG9uIGNvbXBhdGliaWxpdHkuXG4gICAgLy8gVGhpcyBpcyBhIGdldHRlciBpbnN0ZWFkIG9mIGEgcHJvcGVydHkgYmVjYXVzZSB3aGVuIGl0J3MgYSBwcm9wZXJ0eSwgaXRcbiAgICAvLyBwcmV2ZW50cyB0aGUgZW50aXJlIGNsYXNzIGZyb20gYmVpbmcgdHJlZS1zaGFrZW4uXG4gICAgcmV0dXJuICdSTVNQcm9wJztcbiAgfVxuICBwcml2YXRlIGNlbnRlcmVkOiBib29sZWFuO1xuXG4gIHByaXZhdGUgYWNjdW11bGF0ZWRNZWFuU3F1YXJlczogT3B0aW1pemVyVmFyaWFibGVbXSA9IFtdO1xuICBwcml2YXRlIGFjY3VtdWxhdGVkTW9tZW50czogT3B0aW1pemVyVmFyaWFibGVbXSA9IFtdO1xuICBwcml2YXRlIGFjY3VtdWxhdGVkTWVhbkdyYWRzOiBPcHRpbWl6ZXJWYXJpYWJsZVtdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwcm90ZWN0ZWQgbGVhcm5pbmdSYXRlOiBudW1iZXIsIHByb3RlY3RlZCBkZWNheSA9IDAuOSxcbiAgICAgIHByb3RlY3RlZCBtb21lbnR1bSA9IDAuMCwgcHJvdGVjdGVkIGVwc2lsb246IG51bWJlciA9IG51bGwsXG4gICAgICBjZW50ZXJlZCA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2VudGVyZWQgPSBjZW50ZXJlZDtcblxuICAgIGlmIChlcHNpbG9uID09IG51bGwpIHtcbiAgICAgIHRoaXMuZXBzaWxvbiA9IEVOR0lORS5iYWNrZW5kLmVwc2lsb24oKTtcbiAgICB9XG4gICAgaWYgKGxlYXJuaW5nUmF0ZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGxlYXJuaW5nUmF0ZSBmb3IgUk1TUHJvcE9wdGltaXplciBtdXN0IGJlIGRlZmluZWQuYCk7XG4gICAgfVxuICB9XG5cbiAgYXBwbHlHcmFkaWVudHModmFyaWFibGVHcmFkaWVudHM6IE5hbWVkVGVuc29yTWFwfE5hbWVkVGVuc29yW10pIHtcbiAgICBjb25zdCB2YXJpYWJsZU5hbWVzID0gQXJyYXkuaXNBcnJheSh2YXJpYWJsZUdyYWRpZW50cykgP1xuICAgICAgICB2YXJpYWJsZUdyYWRpZW50cy5tYXAoaXRlbSA9PiBpdGVtLm5hbWUpIDpcbiAgICAgICAgT2JqZWN0LmtleXModmFyaWFibGVHcmFkaWVudHMpO1xuXG4gICAgdmFyaWFibGVOYW1lcy5mb3JFYWNoKChuYW1lLCBpKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IEVOR0lORS5yZWdpc3RlcmVkVmFyaWFibGVzW25hbWVdO1xuICAgICAgY29uc3QgdHJhaW5hYmxlID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW2ldID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW2ldID0ge1xuICAgICAgICAgIG9yaWdpbmFsTmFtZTogYCR7bmFtZX0vcm1zYCxcbiAgICAgICAgICB2YXJpYWJsZTogdGlkeSgoKSA9PiB6ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZSkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZE1vbWVudHNbaV0gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFjY3VtdWxhdGVkTW9tZW50c1tpXSA9IHtcbiAgICAgICAgICBvcmlnaW5hbE5hbWU6IGAke25hbWV9L21vbWVudHVtYCxcbiAgICAgICAgICB2YXJpYWJsZTogdGlkeSgoKSA9PiB6ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZSkpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkc1tpXSA9PSBudWxsICYmIHRoaXMuY2VudGVyZWQpIHtcbiAgICAgICAgdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkc1tpXSA9IHtcbiAgICAgICAgICBvcmlnaW5hbE5hbWU6IGAke25hbWV9L21nYCxcbiAgICAgICAgICB2YXJpYWJsZTogdGlkeSgoKSA9PiB6ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGdyYWRpZW50ID0gQXJyYXkuaXNBcnJheSh2YXJpYWJsZUdyYWRpZW50cykgP1xuICAgICAgICAgIHZhcmlhYmxlR3JhZGllbnRzW2ldLnRlbnNvciA6XG4gICAgICAgICAgdmFyaWFibGVHcmFkaWVudHNbbmFtZV07XG4gICAgICBpZiAoZ3JhZGllbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFjY3VtdWxhdGVkTWVhblNxdWFyZSA9IHRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlc1tpXS52YXJpYWJsZTtcbiAgICAgIGNvbnN0IGFjY3VtdWxhdGVkTW9tZW50cyA9IHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzW2ldLnZhcmlhYmxlO1xuICAgICAgdGlkeSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0FjY3VtdWxhdGVkTWVhblNxdWFyZSA9XG4gICAgICAgICAgICBhZGQobXVsKGFjY3VtdWxhdGVkTWVhblNxdWFyZSwgdGhpcy5kZWNheSksXG4gICAgICAgICAgICAgICAgbXVsKHNxdWFyZShncmFkaWVudCksIDEgLSB0aGlzLmRlY2F5KSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2VudGVyZWQpIHtcbiAgICAgICAgICBjb25zdCBhY2N1bXVsYXRlZE1lYW5HcmFkID0gdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkc1tpXS52YXJpYWJsZTtcbiAgICAgICAgICAvLyBDZW50ZXJlZCBncmFkaWVudFxuICAgICAgICAgIGNvbnN0IG5ld0FjY3VtdWxhdGVkTWVhbkdyYWQgPVxuICAgICAgICAgICAgICBhZGQobXVsKGFjY3VtdWxhdGVkTWVhbkdyYWQsIHRoaXMuZGVjYXkpLFxuICAgICAgICAgICAgICAgICAgbXVsKGdyYWRpZW50LCAxIC0gdGhpcy5kZWNheSkpO1xuXG4gICAgICAgICAgY29uc3QgZ3JhZENvbnRyaWJ1dGlvbiA9XG4gICAgICAgICAgICAgIGRpdihtdWwoZ3JhZGllbnQsIHRoaXMubGVhcm5pbmdSYXRlKSxcbiAgICAgICAgICAgICAgICAgIHNxcnQoXG4gICAgICAgICAgICAgICAgICAgICAgc3ViKG5ld0FjY3VtdWxhdGVkTWVhblNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkKHNxdWFyZShuZXdBY2N1bXVsYXRlZE1lYW5HcmFkKSwgdGhpcy5lcHNpbG9uKSkpKTtcbiAgICAgICAgICBjb25zdCBuZXdBY2N1bXVsYXRlZE1vbWVudHMgPVxuICAgICAgICAgICAgICBhZGQobXVsKGFjY3VtdWxhdGVkTW9tZW50cywgdGhpcy5tb21lbnR1bSksIGdyYWRDb250cmlidXRpb24pO1xuXG4gICAgICAgICAgYWNjdW11bGF0ZWRNZWFuU3F1YXJlLmFzc2lnbihuZXdBY2N1bXVsYXRlZE1lYW5TcXVhcmUpO1xuICAgICAgICAgIGFjY3VtdWxhdGVkTWVhbkdyYWQuYXNzaWduKG5ld0FjY3VtdWxhdGVkTWVhbkdyYWQpO1xuICAgICAgICAgIGFjY3VtdWxhdGVkTW9tZW50cy5hc3NpZ24obmV3QWNjdW11bGF0ZWRNb21lbnRzKTtcblxuICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gc3ViKHZhbHVlLCBuZXdBY2N1bXVsYXRlZE1vbWVudHMpO1xuICAgICAgICAgIHZhbHVlLmFzc2lnbihuZXdWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGxhaW4gZ3JhZGllbnRcbiAgICAgICAgICBjb25zdCBuZXdBY2N1bXVsYXRlZE1lYW5TcXVhcmUgPVxuICAgICAgICAgICAgICBhZGQobXVsKGFjY3VtdWxhdGVkTWVhblNxdWFyZSwgdGhpcy5kZWNheSksXG4gICAgICAgICAgICAgICAgICBtdWwoc3F1YXJlKGdyYWRpZW50KSwgMSAtIHRoaXMuZGVjYXkpKTtcblxuICAgICAgICAgIGNvbnN0IG5ld0FjY3VtdWxhdGVkTW9tZW50cyA9XG4gICAgICAgICAgICAgIGFkZChtdWwoYWNjdW11bGF0ZWRNb21lbnRzLCB0aGlzLm1vbWVudHVtKSxcbiAgICAgICAgICAgICAgICAgIGRpdihtdWwoZ3JhZGllbnQsIHRoaXMubGVhcm5pbmdSYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgICBzcXJ0KGFkZChuZXdBY2N1bXVsYXRlZE1lYW5TcXVhcmUsIHRoaXMuZXBzaWxvbikpKSk7XG5cbiAgICAgICAgICBhY2N1bXVsYXRlZE1lYW5TcXVhcmUuYXNzaWduKG5ld0FjY3VtdWxhdGVkTWVhblNxdWFyZSk7XG4gICAgICAgICAgYWNjdW11bGF0ZWRNb21lbnRzLmFzc2lnbihuZXdBY2N1bXVsYXRlZE1vbWVudHMpO1xuXG4gICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBzdWIodmFsdWUsIG5ld0FjY3VtdWxhdGVkTW9tZW50cyk7XG4gICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5pbmNyZW1lbnRJdGVyYXRpb25zKCk7XG4gIH1cblxuICBvdmVycmlkZSBkaXNwb3NlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMgIT0gbnVsbCkge1xuICAgICAgZGlzcG9zZSh0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMubWFwKHYgPT4gdi52YXJpYWJsZSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyAhPSBudWxsICYmIHRoaXMuY2VudGVyZWQpIHtcbiAgICAgIGRpc3Bvc2UodGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcy5tYXAodiA9PiB2LnZhcmlhYmxlKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkTW9tZW50cyAhPSBudWxsKSB7XG4gICAgICBkaXNwb3NlKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzLm1hcCh2ID0+IHYudmFyaWFibGUpKTtcbiAgICB9XG4gIH1cblxuICBvdmVycmlkZSBhc3luYyBnZXRXZWlnaHRzKCk6IFByb21pc2U8TmFtZWRUZW5zb3JbXT4ge1xuICAgIC8vIE9yZGVyIG1hdHRlcnMgZm9yIFB5dGhvbiBjb21wYXRpYmlsaXR5LlxuICAgIGNvbnN0IHZhcmlhYmxlczogT3B0aW1pemVyVmFyaWFibGVbXSA9XG4gICAgICAgIFsuLi50aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMsIC4uLnRoaXMuYWNjdW11bGF0ZWRNb21lbnRzXTtcbiAgICBpZiAodGhpcy5jZW50ZXJlZCkge1xuICAgICAgdmFyaWFibGVzLnB1c2goLi4udGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyk7XG4gICAgfVxuICAgIHJldHVybiBbYXdhaXQgdGhpcy5zYXZlSXRlcmF0aW9ucygpXS5jb25jYXQoXG4gICAgICAgIHZhcmlhYmxlcy5tYXAodiA9PiAoe25hbWU6IHYub3JpZ2luYWxOYW1lLCB0ZW5zb3I6IHYudmFyaWFibGV9KSkpO1xuICB9XG5cbiAgb3ZlcnJpZGUgYXN5bmMgc2V0V2VpZ2h0cyh3ZWlnaHRWYWx1ZXM6IE5hbWVkVGVuc29yW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB3ZWlnaHRWYWx1ZXMgPSBhd2FpdCB0aGlzLmV4dHJhY3RJdGVyYXRpb25zKHdlaWdodFZhbHVlcyk7XG4gICAgY29uc3QgdmFyaWFibGVDb3VudCA9XG4gICAgICAgIHRoaXMuY2VudGVyZWQgPyB3ZWlnaHRWYWx1ZXMubGVuZ3RoIC8gMyA6IHdlaWdodFZhbHVlcy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IHRyYWluYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyA9XG4gICAgICAgIHdlaWdodFZhbHVlcy5zbGljZSgwLCB2YXJpYWJsZUNvdW50KS5tYXAodiA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxOYW1lOiB2Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZTogdi50ZW5zb3IudmFyaWFibGUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaW5hYmxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICB0aGlzLmFjY3VtdWxhdGVkTW9tZW50cyA9XG4gICAgICAgIHdlaWdodFZhbHVlcy5zbGljZSh2YXJpYWJsZUNvdW50LCB2YXJpYWJsZUNvdW50ICogMilcbiAgICAgICAgICAgIC5tYXAodiA9PiAoe1xuICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsTmFtZTogdi5uYW1lLFxuICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlOiB2LnRlbnNvci52YXJpYWJsZSh0cmFpbmFibGUpXG4gICAgICAgICAgICAgICAgIH0pKTtcbiAgICBpZiAodGhpcy5jZW50ZXJlZCkge1xuICAgICAgdGhpcy5hY2N1bXVsYXRlZE1lYW5HcmFkcyA9XG4gICAgICAgICAgd2VpZ2h0VmFsdWVzLnNsaWNlKHZhcmlhYmxlQ291bnQgKiAyLCB2YXJpYWJsZUNvdW50ICogMylcbiAgICAgICAgICAgICAgLm1hcCh2ID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbE5hbWU6IHYubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlOiB2LnRlbnNvci52YXJpYWJsZSh0cmFpbmFibGUpXG4gICAgICAgICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGdldENvbmZpZygpOiBDb25maWdEaWN0IHtcbiAgICByZXR1cm4ge1xuICAgICAgJ2xlYXJuaW5nUmF0ZSc6IHRoaXMubGVhcm5pbmdSYXRlLFxuICAgICAgJ2RlY2F5JzogdGhpcy5kZWNheSxcbiAgICAgICdtb21lbnR1bSc6IHRoaXMubW9tZW50dW0sXG4gICAgICAnZXBzaWxvbic6IHRoaXMuZXBzaWxvbixcbiAgICAgICdjZW50ZXJlZCc6IHRoaXMuY2VudGVyZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBvdmVycmlkZSBmcm9tQ29uZmlnPFQgZXh0ZW5kcyBTZXJpYWxpemFibGU+KFxuICAgICAgY2xzOiBTZXJpYWxpemFibGVDb25zdHJ1Y3RvcjxUPiwgY29uZmlnOiBDb25maWdEaWN0KTogVCB7XG4gICAgcmV0dXJuIG5ldyBjbHMoXG4gICAgICAgIGNvbmZpZ1snbGVhcm5pbmdSYXRlJ10sIGNvbmZpZ1snZGVjYXknXSwgY29uZmlnWydtb21lbnR1bSddLFxuICAgICAgICBjb25maWdbJ2Vwc2lsb24nXSwgY29uZmlnWydjZW50ZXJlZCddKTtcbiAgfVxufVxuIl19