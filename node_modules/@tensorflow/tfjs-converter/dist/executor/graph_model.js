/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { dispose, io, Tensor, util } from '@tensorflow/tfjs-core';
import { OperationMapper } from '../operations/operation_mapper';
import { GraphExecutor } from './graph_executor';
import { ResourceManager } from './resource_manager';
export const TFHUB_SEARCH_PARAM = '?tfjs-format=file';
export const DEFAULT_MODEL_NAME = 'model.json';
/**
 * A `tf.GraphModel` is a directed, acyclic graph built from a
 * SavedModel GraphDef and allows inference execution.
 *
 * A `tf.GraphModel` can only be created by loading from a model converted from
 * a [TensorFlow SavedModel](https://www.tensorflow.org/guide/saved_model) using
 * the command line converter tool and loaded via `tf.loadGraphModel`.
 *
 * @doc {heading: 'Models', subheading: 'Classes'}
 */
export class GraphModel {
    /**
     * @param modelUrl url for the model, or an `io.IOHandler`.
     * @param weightManifestUrl url for the weight file generated by
     * scripts/convert.py script.
     * @param requestOption options for Request, which allows to send credentials
     * and custom headers.
     * @param onProgress Optional, progress callback function, fired periodically
     * before the load is completed.
     */
    constructor(modelUrl, loadOptions = {}, tfio = io) {
        this.modelUrl = modelUrl;
        this.loadOptions = loadOptions;
        this.version = 'n/a';
        this.io = tfio;
        if (loadOptions == null) {
            this.loadOptions = {};
        }
        this.resourceManager = new ResourceManager();
    }
    // Returns the version information for the tensorflow model GraphDef.
    get modelVersion() {
        return this.version;
    }
    get inputNodes() {
        return this.executor.inputNodes;
    }
    get outputNodes() {
        return this.executor.outputNodes;
    }
    get inputs() {
        return this.executor.inputs;
    }
    get outputs() {
        return this.executor.outputs;
    }
    get weights() {
        return this.executor.weightMap;
    }
    get metadata() {
        return this.artifacts.userDefinedMetadata;
    }
    get modelSignature() {
        return this.signature;
    }
    get modelStructuredOutputKeys() {
        return this.structuredOutputKeys;
    }
    findIOHandler() {
        const path = this.modelUrl;
        if (path.load != null) {
            // Path is an IO Handler.
            this.handler = path;
        }
        else if (this.loadOptions.requestInit != null) {
            this.handler = this.io.browserHTTPRequest(path, this.loadOptions);
        }
        else {
            const handlers = this.io.getLoadHandlers(path, this.loadOptions);
            if (handlers.length === 0) {
                // For backward compatibility: if no load handler can be found,
                // assume it is a relative http path.
                handlers.push(this.io.browserHTTPRequest(path, this.loadOptions));
            }
            else if (handlers.length > 1) {
                throw new Error(`Found more than one (${handlers.length}) load handlers for ` +
                    `URL '${[path]}'`);
            }
            this.handler = handlers[0];
        }
    }
    /**
     * Loads the model and weight files, construct the in memory weight map and
     * compile the inference graph.
     */
    load() {
        this.findIOHandler();
        if (this.handler.load == null) {
            throw new Error('Cannot proceed with model loading because the IOHandler provided ' +
                'does not have the `load` method implemented.');
        }
        const loadResult = this.handler.load();
        if (util.isPromise(loadResult)) {
            return loadResult.then(artifacts => this.loadSync(artifacts));
        }
        return this.loadSync(loadResult);
    }
    /**
     * Synchronously construct the in memory weight map and
     * compile the inference graph.
     *
     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
     */
    loadSync(artifacts) {
        this.artifacts = artifacts;
        const graph = this.artifacts.modelTopology;
        let signature = this.artifacts.signature;
        if (this.artifacts.userDefinedMetadata != null) {
            const metadata = this.artifacts.userDefinedMetadata;
            if (metadata.signature != null) {
                signature = metadata.signature;
            }
            if (metadata.structuredOutputKeys != null) {
                this.structuredOutputKeys = metadata.structuredOutputKeys;
            }
        }
        this.signature = signature;
        this.version = `${graph.versions.producer}.${graph.versions.minConsumer}`;
        const weightMap = this.io.decodeWeights(this.artifacts.weightData, this.artifacts.weightSpecs);
        this.executor = new GraphExecutor(OperationMapper.Instance.transformGraph(graph, this.signature));
        this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);
        // Attach a model-level resourceManager to each executor to share resources,
        // such as `HashTable`.
        this.executor.resourceManager = this.resourceManager;
        if (artifacts.modelInitializer != null &&
            artifacts.modelInitializer.node != null) {
            const initializer = OperationMapper.Instance.transformGraph(artifacts.modelInitializer);
            this.initializer = new GraphExecutor(initializer);
            this.initializer.weightMap = this.executor.weightMap;
            // Attach a model-level resourceManager to the initializer, the
            // hashTables created from when executing the initializer will be stored
            // in the resourceManager.
            this.initializer.resourceManager = this.resourceManager;
            this.initializerSignature = artifacts.initializerSignature;
        }
        return true;
    }
    /**
     * Save the configuration and/or weights of the GraphModel.
     *
     * An `IOHandler` is an object that has a `save` method of the proper
     * signature defined. The `save` method manages the storing or
     * transmission of serialized data ("artifacts") that represent the
     * model's topology and weights onto or via a specific medium, such as
     * file downloads, local storage, IndexedDB in the web browser and HTTP
     * requests to a server. TensorFlow.js provides `IOHandler`
     * implementations for a number of frequently used saving mediums, such as
     * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`
     * for more details.
     *
     * This method also allows you to refer to certain types of `IOHandler`s
     * as URL-like string shortcuts, such as 'localstorage://' and
     * 'indexeddb://'.
     *
     * Example 1: Save `model`'s topology and weights to browser [local
     * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);
     * then load it back.
     *
     * ```js
     * const modelUrl =
     *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
     * const model = await tf.loadGraphModel(modelUrl);
     * const zeros = tf.zeros([1, 224, 224, 3]);
     * model.predict(zeros).print();
     *
     * const saveResults = await model.save('localstorage://my-model-1');
     *
     * const loadedModel = await tf.loadGraphModel('localstorage://my-model-1');
     * console.log('Prediction from loaded model:');
     * model.predict(zeros).print();
     * ```
     *
     * @param handlerOrURL An instance of `IOHandler` or a URL-like,
     * scheme-based string shortcut for `IOHandler`.
     * @param config Options for saving the model.
     * @returns A `Promise` of `SaveResult`, which summarizes the result of
     * the saving, such as byte sizes of the saved artifacts for the model's
     *   topology and weight values.
     *
     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}
     */
    async save(handlerOrURL, config) {
        if (typeof handlerOrURL === 'string') {
            const handlers = this.io.getSaveHandlers(handlerOrURL);
            if (handlers.length === 0) {
                throw new Error(`Cannot find any save handlers for URL '${handlerOrURL}'`);
            }
            else if (handlers.length > 1) {
                throw new Error(`Found more than one (${handlers.length}) save handlers for ` +
                    `URL '${handlerOrURL}'`);
            }
            handlerOrURL = handlers[0];
        }
        if (handlerOrURL.save == null) {
            throw new Error('GraphModel.save() cannot proceed because the IOHandler ' +
                'provided does not have the `save` attribute defined.');
        }
        return handlerOrURL.save(this.artifacts);
    }
    addStructuredOutputNames(outputTensors) {
        if (this.structuredOutputKeys) {
            const outputTensorsArray = outputTensors instanceof Tensor ? [outputTensors] : outputTensors;
            const outputTensorMap = {};
            outputTensorsArray.forEach((outputTensor, i) => outputTensorMap[this.structuredOutputKeys[i]] =
                outputTensor);
            return outputTensorMap;
        }
        return outputTensors;
    }
    /**
     * Execute the inference for the input tensors.
     *
     * @param input The input tensors, when there is single input for the model,
     * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
     * inputs params should be in either `tf.Tensor`[] if the input order is
     * fixed, or otherwise NamedTensorMap format.
     *
     * For model with multiple inputs, we recommend you use NamedTensorMap as the
     * input type, if you use `tf.Tensor`[], the order of the array needs to
     * follow the
     * order of inputNodes array. @see {@link GraphModel.inputNodes}
     *
     * You can also feed any intermediate nodes using the NamedTensorMap as the
     * input type. For example, given the graph
     *    InputNode => Intermediate => OutputNode,
     * you can execute the subgraph Intermediate => OutputNode by calling
     *    model.execute('IntermediateNode' : tf.tensor(...));
     *
     * This is useful for models that uses tf.dynamic_rnn, where the intermediate
     * state needs to be fed manually.
     *
     * For batch inference execution, the tensors for each input need to be
     * concatenated together. For example with mobilenet, the required input shape
     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
     * If we are provide a batched data of 100 images, the input tensor should be
     * in the shape of [100, 244, 244, 3].
     *
     * @param config Prediction configuration for specifying the batch size.
     * Currently the batch size option is ignored for graph model.
     *
     * @returns Inference result tensors. If the model is converted and it
     * originally had structured_outputs in tensorflow, then a NamedTensorMap
     * will be returned matching the structured_outputs. If no structured_outputs
     * are present, the output will be single `tf.Tensor` if the model has single
     * output node, otherwise Tensor[].
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    predict(inputs, config) {
        const outputTensors = this.execute(inputs, this.outputNodes);
        return this.addStructuredOutputNames(outputTensors);
    }
    /**
     * Execute the inference for the input tensors in async fashion, use this
     * method when your model contains control flow ops.
     *
     * @param input The input tensors, when there is single input for the model,
     * inputs param should be a `tf.Tensor`. For models with mutliple inputs,
     * inputs params should be in either `tf.Tensor`[] if the input order is
     * fixed, or otherwise NamedTensorMap format.
     *
     * For model with multiple inputs, we recommend you use NamedTensorMap as the
     * input type, if you use `tf.Tensor`[], the order of the array needs to
     * follow the
     * order of inputNodes array. @see {@link GraphModel.inputNodes}
     *
     * You can also feed any intermediate nodes using the NamedTensorMap as the
     * input type. For example, given the graph
     *    InputNode => Intermediate => OutputNode,
     * you can execute the subgraph Intermediate => OutputNode by calling
     *    model.execute('IntermediateNode' : tf.tensor(...));
     *
     * This is useful for models that uses tf.dynamic_rnn, where the intermediate
     * state needs to be fed manually.
     *
     * For batch inference execution, the tensors for each input need to be
     * concatenated together. For example with mobilenet, the required input shape
     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].
     * If we are provide a batched data of 100 images, the input tensor should be
     * in the shape of [100, 244, 244, 3].
     *
     * @param config Prediction configuration for specifying the batch size.
     * Currently the batch size option is ignored for graph model.
     *
     * @returns A Promise of inference result tensors. If the model is converted
     * and it originally had structured_outputs in tensorflow, then a
     * NamedTensorMap will be returned matching the structured_outputs. If no
     * structured_outputs are present, the output will be single `tf.Tensor` if
     * the model has single output node, otherwise Tensor[].
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    async predictAsync(inputs, config) {
        const outputTensors = await this.executeAsync(inputs, this.outputNodes);
        return this.addStructuredOutputNames(outputTensors);
    }
    normalizeInputs(inputs) {
        var _a;
        if (!(inputs instanceof Tensor) && !Array.isArray(inputs)) {
            // The input is already a NamedTensorMap.
            const signatureInputs = (_a = this.signature) === null || _a === void 0 ? void 0 : _a.inputs;
            if (signatureInputs != null) {
                for (const input in signatureInputs) {
                    const tensor = signatureInputs[input];
                    if (tensor.resourceId != null) {
                        inputs[input] = this.resourceIdToCapturedInput[tensor.resourceId];
                    }
                }
            }
            return inputs;
        }
        inputs = Array.isArray(inputs) ? inputs : [inputs];
        const numCapturedInputs = Object.keys(this.resourceIdToCapturedInput).length;
        if (inputs.length + numCapturedInputs !== this.inputNodes.length) {
            throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length -
                numCapturedInputs} non-resource placeholders, while there are ${inputs.length} input tensors provided.`);
        }
        let inputIndex = 0;
        return this.inputNodes.reduce((map, inputName) => {
            var _a, _b, _c;
            const resourceId = (_c = (_b = (_a = this.signature) === null || _a === void 0 ? void 0 : _a.inputs) === null || _b === void 0 ? void 0 : _b[inputName]) === null || _c === void 0 ? void 0 : _c.resourceId;
            if (resourceId != null) {
                map[inputName] = this.resourceIdToCapturedInput[resourceId];
            }
            else {
                map[inputName] = inputs[inputIndex++];
            }
            return map;
        }, {});
    }
    normalizeOutputs(outputs) {
        outputs = outputs || this.outputNodes;
        return !Array.isArray(outputs) ? [outputs] : outputs;
    }
    executeInitializerGraph() {
        if (this.initializer == null) {
            return [];
        }
        if (this.initializerSignature == null) {
            return this.initializer.execute({}, []);
        }
        else {
            return this.initializer.execute({}, Object.keys(this.initializerSignature.outputs));
        }
    }
    async executeInitializerGraphAsync() {
        if (this.initializer == null) {
            return [];
        }
        if (this.initializerSignature == null) {
            return this.initializer.executeAsync({}, []);
        }
        else {
            return this.initializer.executeAsync({}, Object.keys(this.initializerSignature.outputs));
        }
    }
    setResourceIdToCapturedInput(outputs) {
        this.resourceIdToCapturedInput = {};
        if (this.initializerSignature) {
            const signatureOutputs = this.initializerSignature.outputs;
            const outputNames = Object.keys(signatureOutputs);
            for (let i = 0; i < outputNames.length; i++) {
                const outputName = outputNames[i];
                const tensorInfo = signatureOutputs[outputName];
                this.resourceIdToCapturedInput[tensorInfo.resourceId] = outputs[i];
            }
        }
    }
    /**
     * Executes inference for the model for given input tensors.
     * @param inputs tensor, tensor array or tensor map of the inputs for the
     * model, keyed by the input node names.
     * @param outputs output node name from the TensorFlow model, if no
     * outputs are specified, the default outputs of the model would be used.
     * You can inspect intermediate nodes of the model by adding them to the
     * outputs array.
     *
     * @returns A single tensor if provided with a single output or no outputs
     * are provided and there is only one default output, otherwise return a
     * tensor array. The order of the tensor array is the same as the outputs
     * if provided, otherwise the order of outputNodes attribute of the model.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    execute(inputs, outputs) {
        if (this.resourceIdToCapturedInput == null) {
            this.setResourceIdToCapturedInput(this.executeInitializerGraph());
        }
        inputs = this.normalizeInputs(inputs);
        outputs = this.normalizeOutputs(outputs);
        const result = this.executor.execute(inputs, outputs);
        return result.length > 1 ? result : result[0];
    }
    /**
     * Executes inference for the model for given input tensors in async
     * fashion, use this method when your model contains control flow ops.
     * @param inputs tensor, tensor array or tensor map of the inputs for the
     * model, keyed by the input node names.
     * @param outputs output node name from the TensorFlow model, if no outputs
     * are specified, the default outputs of the model would be used. You can
     * inspect intermediate nodes of the model by adding them to the outputs
     * array.
     *
     * @returns A Promise of single tensor if provided with a single output or
     * no outputs are provided and there is only one default output, otherwise
     * return a tensor map.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    async executeAsync(inputs, outputs) {
        if (this.resourceIdToCapturedInput == null) {
            this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync());
        }
        inputs = this.normalizeInputs(inputs);
        outputs = this.normalizeOutputs(outputs);
        const result = await this.executor.executeAsync(inputs, outputs);
        return result.length > 1 ? result : result[0];
    }
    /**
     * Get intermediate tensors for model debugging mode (flag
     * KEEP_INTERMEDIATE_TENSORS is true).
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    getIntermediateTensors() {
        return this.executor.getIntermediateTensors();
    }
    /**
     * Dispose intermediate tensors for model debugging mode (flag
     * KEEP_INTERMEDIATE_TENSORS is true).
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    disposeIntermediateTensors() {
        this.executor.disposeIntermediateTensors();
    }
    convertTensorMapToTensorsMap(map) {
        return Object.keys(map).reduce((newMap, key) => {
            newMap[key] = [map[key]];
            return newMap;
        }, {});
    }
    /**
     * Releases the memory used by the weight tensors and resourceManager.
     *
     * @doc {heading: 'Models', subheading: 'Classes'}
     */
    dispose() {
        this.executor.dispose();
        if (this.initializer) {
            this.initializer.dispose();
            if (this.resourceIdToCapturedInput) {
                dispose(this.resourceIdToCapturedInput);
            }
        }
        this.resourceManager.dispose();
    }
}
/**
 * Load a graph model given a URL to the model definition.
 *
 * Example of loading MobileNetV2 from a URL and making a prediction with a
 * zeros input:
 *
 * ```js
 * const modelUrl =
 *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';
 * const model = await tf.loadGraphModel(modelUrl);
 * const zeros = tf.zeros([1, 224, 224, 3]);
 * model.predict(zeros).print();
 * ```
 *
 * Example of loading MobileNetV2 from a TF Hub URL and making a prediction
 * with a zeros input:
 *
 * ```js
 * const modelUrl =
 *    'https://tfhub.dev/google/imagenet/mobilenet_v2_140_224/classification/2';
 * const model = await tf.loadGraphModel(modelUrl, {fromTFHub: true});
 * const zeros = tf.zeros([1, 224, 224, 3]);
 * model.predict(zeros).print();
 * ```
 * @param modelUrl The url or an `io.IOHandler` that loads the model.
 * @param options Options for the HTTP request, which allows to send
 *     credentials
 *    and custom headers.
 *
 * @doc {heading: 'Models', subheading: 'Loading'}
 */
export async function loadGraphModel(modelUrl, options = {}, tfio = io) {
    if (modelUrl == null) {
        throw new Error('modelUrl in loadGraphModel() cannot be null. Please provide a url ' +
            'or an IOHandler that loads the model');
    }
    if (options == null) {
        options = {};
    }
    if (options.fromTFHub && typeof modelUrl === 'string') {
        modelUrl = getTFHubUrl(modelUrl);
    }
    const model = new GraphModel(modelUrl, options, tfio);
    await model.load();
    return model;
}
/**
 * Load a graph model given a synchronous IO handler with a 'load' method.
 *
 * @param modelSource The `io.IOHandlerSync` that loads the model, or the
 *     `io.ModelArtifacts` that encode the model, or a tuple of
 *     `[io.ModelJSON, ArrayBuffer]` of which the first element encodes the
 *      model and the second contains the weights.
 *
 * @doc {heading: 'Models', subheading: 'Loading'}
 */
export function loadGraphModelSync(modelSource) {
    if (modelSource == null) {
        throw new Error('modelUrl in loadGraphModelSync() cannot be null. Please provide ' +
            'model artifacts or an IOHandler that loads the model');
    }
    let ioHandler;
    if (modelSource instanceof Array) {
        const [modelJSON, weights] = modelSource;
        if (!modelJSON) {
            throw new Error('modelJSON must be the first element of the array');
        }
        if (!weights || !(weights instanceof ArrayBuffer)) {
            throw new Error('An ArrayBuffer of weights must be the second element of' +
                ' the array');
        }
        if (!('modelTopology' in modelJSON)) {
            throw new Error('Model JSON is missing \'modelTopology\'');
        }
        if (!('weightsManifest' in modelJSON)) {
            throw new Error('Model JSON is missing \'weightsManifest\'');
        }
        const weightSpecs = io.getWeightSpecs(modelJSON.weightsManifest);
        const modelArtifacts = io.getModelArtifactsForJSONSync(modelJSON, weightSpecs, weights);
        ioHandler = io.fromMemorySync(modelArtifacts);
    }
    else if ('load' in modelSource) {
        // Then modelSource is already an IOHandlerSync.
        ioHandler = modelSource;
    }
    else if ('modelTopology' in modelSource && 'weightSpecs' in modelSource &&
        'weightData' in modelSource) {
        // modelSource is of type ModelArtifacts.
        ioHandler = io.fromMemorySync(modelSource);
    }
    else {
        throw new Error('Unknown model format');
    }
    const model = new GraphModel(ioHandler);
    model.load();
    return model;
}
function getTFHubUrl(modelUrl) {
    if (!modelUrl.endsWith('/')) {
        modelUrl = (modelUrl) + '/';
    }
    return `${modelUrl}${DEFAULT_MODEL_NAME}${TFHUB_SEARCH_PARAM}`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JhcGhfbW9kZWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvbnZlcnRlci9zcmMvZXhlY3V0b3IvZ3JhcGhfbW9kZWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFDLE9BQU8sRUFBa0IsRUFBRSxFQUFzQyxNQUFNLEVBQUUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFJcEgsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLGdDQUFnQyxDQUFDO0FBRS9ELE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUMvQyxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFbkQsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsbUJBQW1CLENBQUM7QUFDdEQsTUFBTSxDQUFDLE1BQU0sa0JBQWtCLEdBQUcsWUFBWSxDQUFDO0FBSS9DOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sT0FBTyxVQUFVO0lBbURyQjs7Ozs7Ozs7T0FRRztJQUNILFlBQ1ksUUFBa0IsRUFBVSxjQUE4QixFQUFFLEVBQ3BFLElBQUksR0FBRyxFQUFFO1FBREQsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUFVLGdCQUFXLEdBQVgsV0FBVyxDQUFxQjtRQTFEaEUsWUFBTyxHQUFHLEtBQUssQ0FBQztRQTREdEIsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDZixJQUFJLFdBQVcsSUFBSSxJQUFJLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7U0FDdkI7UUFDRCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksZUFBZSxFQUFFLENBQUM7SUFDL0MsQ0FBQztJQXRERCxxRUFBcUU7SUFDckUsSUFBSSxZQUFZO1FBQ2QsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3RCLENBQUM7SUFFRCxJQUFJLFVBQVU7UUFDWixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDO0lBQ2xDLENBQUM7SUFFRCxJQUFJLFdBQVc7UUFDYixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDO0lBQ25DLENBQUM7SUFFRCxJQUFJLE1BQU07UUFDUixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDO0lBQzlCLENBQUM7SUFFRCxJQUFJLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDO0lBQy9CLENBQUM7SUFFRCxJQUFJLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDO0lBQ2pDLENBQUM7SUFFRCxJQUFJLFFBQVE7UUFDVixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUM7SUFDNUMsQ0FBQztJQUVELElBQUksY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDeEIsQ0FBQztJQUVELElBQUkseUJBQXlCO1FBQzNCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDO0lBQ25DLENBQUM7SUFxQk8sYUFBYTtRQUVuQixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQzNCLElBQUssSUFBcUIsQ0FBQyxJQUFJLElBQUksSUFBSSxFQUFFO1lBQ3ZDLHlCQUF5QjtZQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQWlCLENBQUM7U0FDbEM7YUFBTSxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxJQUFJLElBQUksRUFBRTtZQUMvQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsa0JBQWtCLENBQ3RCLElBQWMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFjLENBQUM7U0FDbkU7YUFBTTtZQUNMLE1BQU0sUUFBUSxHQUNWLElBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLElBQWMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDOUQsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDekIsK0RBQStEO2dCQUMvRCxxQ0FBcUM7Z0JBQ3JDLFFBQVEsQ0FBQyxJQUFJLENBQ1QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFjLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7YUFDbkU7aUJBQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDOUIsTUFBTSxJQUFJLEtBQUssQ0FDWCx3QkFBd0IsUUFBUSxDQUFDLE1BQU0sc0JBQXNCO29CQUM3RCxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ3hCO1lBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFjLENBQUM7U0FDekM7SUFDSCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSTtRQUdGLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNyQixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLElBQUksRUFBRTtZQUM3QixNQUFNLElBQUksS0FBSyxDQUNYLG1FQUFtRTtnQkFDbkUsOENBQThDLENBQUMsQ0FBQztTQUNyRDtRQUtELE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFtQyxDQUFDO1FBQ3hFLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUM5QixPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFXLENBQUM7U0FDekU7UUFFRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFXLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsUUFBUSxDQUFDLFNBQTRCO1FBQ25DLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1FBQzNCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBcUMsQ0FBQztRQUVuRSxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQztRQUN6QyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsbUJBQW1CLElBQUksSUFBSSxFQUFFO1lBQzlDLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUM7WUFDcEQsSUFBSSxRQUFRLENBQUMsU0FBUyxJQUFJLElBQUksRUFBRTtnQkFDOUIsU0FBUyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUM7YUFDaEM7WUFFRCxJQUFJLFFBQVEsQ0FBQyxvQkFBb0IsSUFBSSxJQUFJLEVBQUU7Z0JBQ3pDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxRQUFRLENBQUMsb0JBQWdDLENBQUM7YUFDdkU7U0FDRjtRQUNELElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxDQUFDO1FBRTNCLElBQUksQ0FBQyxPQUFPLEdBQUcsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDLFFBQVEsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQzFFLE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUNuQyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzNELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxhQUFhLENBQzdCLGVBQWUsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUNwRSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsNEJBQTRCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdkUsNEVBQTRFO1FBQzVFLHVCQUF1QjtRQUN2QixJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBRXJELElBQUksU0FBUyxDQUFDLGdCQUFnQixJQUFJLElBQUk7WUFDakMsU0FBUyxDQUFDLGdCQUF5QyxDQUFDLElBQUksSUFBSSxJQUFJLEVBQUU7WUFDckUsTUFBTSxXQUFXLEdBQ2IsZUFBZSxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDeEUsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUNsRCxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQztZQUNyRCwrREFBK0Q7WUFDL0Qsd0VBQXdFO1lBQ3hFLDBCQUEwQjtZQUMxQixJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQ3hELElBQUksQ0FBQyxvQkFBb0IsR0FBRyxTQUFTLENBQUMsb0JBQW9CLENBQUM7U0FDNUQ7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQTJDRztJQUNILEtBQUssQ0FBQyxJQUFJLENBQUMsWUFBaUMsRUFBRSxNQUFzQjtRQUVsRSxJQUFJLE9BQU8sWUFBWSxLQUFLLFFBQVEsRUFBRTtZQUNwQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsQ0FBQztZQUN2RCxJQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUN6QixNQUFNLElBQUksS0FBSyxDQUNYLDBDQUEwQyxZQUFZLEdBQUcsQ0FBQyxDQUFDO2FBQ2hFO2lCQUFNLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQzlCLE1BQU0sSUFBSSxLQUFLLENBQ1gsd0JBQXdCLFFBQVEsQ0FBQyxNQUFNLHNCQUFzQjtvQkFDN0QsUUFBUSxZQUFZLEdBQUcsQ0FBQyxDQUFDO2FBQzlCO1lBQ0QsWUFBWSxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM1QjtRQUNELElBQUksWUFBWSxDQUFDLElBQUksSUFBSSxJQUFJLEVBQUU7WUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FDWCx5REFBeUQ7Z0JBQ3pELHNEQUFzRCxDQUFDLENBQUM7U0FDN0Q7UUFFRCxPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFTyx3QkFBd0IsQ0FBQyxhQUE4QjtRQUM3RCxJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtZQUM3QixNQUFNLGtCQUFrQixHQUNwQixhQUFhLFlBQVksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7WUFDdEUsTUFBTSxlQUFlLEdBQW1CLEVBQUUsQ0FBQztZQUUzQyxrQkFBa0IsQ0FBQyxPQUFPLENBQ3RCLENBQUMsWUFBWSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUQsWUFBWSxDQUFDLENBQUM7WUFFdEIsT0FBTyxlQUFlLENBQUM7U0FDeEI7UUFDRCxPQUFPLGFBQWEsQ0FBQztJQUN2QixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bc0NHO0lBQ0gsT0FBTyxDQUFDLE1BQXNDLEVBQUUsTUFBMkI7UUFFekUsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzdELE9BQU8sSUFBSSxDQUFDLHdCQUF3QixDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09BdUNHO0lBQ0gsS0FBSyxDQUFDLFlBQVksQ0FDZCxNQUFzQyxFQUN0QyxNQUEyQjtRQUM3QixNQUFNLGFBQWEsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN4RSxPQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRU8sZUFBZSxDQUFDLE1BQ2M7O1FBQ3BDLElBQUksQ0FBQyxDQUFDLE1BQU0sWUFBWSxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDekQseUNBQXlDO1lBQ3pDLE1BQU0sZUFBZSxHQUFHLE1BQUEsSUFBSSxDQUFDLFNBQVMsMENBQUUsTUFBTSxDQUFDO1lBQy9DLElBQUksZUFBZSxJQUFJLElBQUksRUFBRTtnQkFDM0IsS0FBSyxNQUFNLEtBQUssSUFBSSxlQUFlLEVBQUU7b0JBQ25DLE1BQU0sTUFBTSxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDdEMsSUFBSSxNQUFNLENBQUMsVUFBVSxJQUFJLElBQUksRUFBRTt3QkFDN0IsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7cUJBQ25FO2lCQUNGO2FBQ0Y7WUFDRCxPQUFPLE1BQU0sQ0FBQztTQUNmO1FBQ0QsTUFBTSxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVuRCxNQUFNLGlCQUFpQixHQUNuQixNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUN2RCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEdBQUcsaUJBQWlCLEtBQUssSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUU7WUFDaEUsTUFBTSxJQUFJLEtBQUssQ0FBQyxvREFDWixJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU07Z0JBQ3RCLGlCQUFpQiwrQ0FDakIsTUFBTSxDQUFDLE1BQU0sMEJBQTBCLENBQUMsQ0FBQztTQUM5QztRQUVELElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQztRQUNuQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxFQUFFOztZQUMvQyxNQUFNLFVBQVUsR0FBRyxNQUFBLE1BQUEsTUFBQSxJQUFJLENBQUMsU0FBUywwQ0FBRSxNQUFNLDBDQUFHLFNBQVMsQ0FBQywwQ0FBRSxVQUFVLENBQUM7WUFDbkUsSUFBSSxVQUFVLElBQUksSUFBSSxFQUFFO2dCQUN0QixHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQzdEO2lCQUFNO2dCQUNMLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBSSxNQUFtQixDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUM7YUFDckQ7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxFQUFvQixDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVPLGdCQUFnQixDQUFDLE9BQXdCO1FBQy9DLE9BQU8sR0FBRyxPQUFPLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUN0QyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0lBQ3ZELENBQUM7SUFFTyx1QkFBdUI7UUFDN0IsSUFBSSxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksRUFBRTtZQUM1QixPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsSUFBSSxJQUFJLENBQUMsb0JBQW9CLElBQUksSUFBSSxFQUFFO1lBQ3JDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ3pDO2FBQU07WUFDTCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUMzQixFQUFFLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztTQUN6RDtJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsNEJBQTRCO1FBQ3hDLElBQUksSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLEVBQUU7WUFDNUIsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUNELElBQUksSUFBSSxDQUFDLG9CQUFvQixJQUFJLElBQUksRUFBRTtZQUNyQyxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUM5QzthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FDaEMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDekQ7SUFDSCxDQUFDO0lBRU8sNEJBQTRCLENBQUMsT0FBaUI7UUFDcEQsSUFBSSxDQUFDLHlCQUF5QixHQUFHLEVBQUUsQ0FBQztRQUVwQyxJQUFJLElBQUksQ0FBQyxvQkFBb0IsRUFBRTtZQUM3QixNQUFNLGdCQUFnQixHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUM7WUFDM0QsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ2xELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO2dCQUMzQyxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2xDLE1BQU0sVUFBVSxHQUFHLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUNoRCxJQUFJLENBQUMseUJBQXlCLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNwRTtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7T0FlRztJQUNILE9BQU8sQ0FBQyxNQUFzQyxFQUFFLE9BQXlCO1FBRXZFLElBQUksSUFBSSxDQUFDLHlCQUF5QixJQUFJLElBQUksRUFBRTtZQUMxQyxJQUFJLENBQUMsNEJBQTRCLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFLENBQUMsQ0FBQztTQUNuRTtRQUNELE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RDLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekMsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3RELE9BQU8sTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7O09BZUc7SUFDSCxLQUFLLENBQUMsWUFBWSxDQUNkLE1BQXNDLEVBQ3RDLE9BQXlCO1FBQzNCLElBQUksSUFBSSxDQUFDLHlCQUF5QixJQUFJLElBQUksRUFBRTtZQUMxQyxJQUFJLENBQUMsNEJBQTRCLENBQzdCLE1BQU0sSUFBSSxDQUFDLDRCQUE0QixFQUFFLENBQUMsQ0FBQztTQUNoRDtRQUNELE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RDLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekMsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDakUsT0FBTyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEQsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsc0JBQXNCO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO0lBQ2hELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILDBCQUEwQjtRQUN4QixJQUFJLENBQUMsUUFBUSxDQUFDLDBCQUEwQixFQUFFLENBQUM7SUFDN0MsQ0FBQztJQUVPLDRCQUE0QixDQUFDLEdBQW1CO1FBQ3RELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUF1QixFQUFFLEdBQUcsRUFBRSxFQUFFO1lBQzlELE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ3pCLE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNULENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsT0FBTztRQUNMLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFeEIsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDM0IsSUFBSSxJQUFJLENBQUMseUJBQXlCLEVBQUU7Z0JBQ2xDLE9BQU8sQ0FBQyxJQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQzthQUN6QztTQUNGO1FBRUQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNqQyxDQUFDO0NBQ0Y7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBOEJHO0FBQ0gsTUFBTSxDQUFDLEtBQUssVUFBVSxjQUFjLENBQ2hDLFFBQTZCLEVBQUUsVUFBMEIsRUFBRSxFQUMzRCxJQUFJLEdBQUcsRUFBRTtJQUNYLElBQUksUUFBUSxJQUFJLElBQUksRUFBRTtRQUNwQixNQUFNLElBQUksS0FBSyxDQUNYLG9FQUFvRTtZQUNwRSxzQ0FBc0MsQ0FBQyxDQUFDO0tBQzdDO0lBQ0QsSUFBSSxPQUFPLElBQUksSUFBSSxFQUFFO1FBQ25CLE9BQU8sR0FBRyxFQUFFLENBQUM7S0FDZDtJQUVELElBQUksT0FBTyxDQUFDLFNBQVMsSUFBSSxPQUFPLFFBQVEsS0FBSyxRQUFRLEVBQUU7UUFDckQsUUFBUSxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUNsQztJQUNELE1BQU0sS0FBSyxHQUFHLElBQUksVUFBVSxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdEQsTUFBTSxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDbkIsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUM5QixXQUMyRDtJQUU3RCxJQUFJLFdBQVcsSUFBSSxJQUFJLEVBQUU7UUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FDWCxrRUFBa0U7WUFDbEUsc0RBQXNELENBQUMsQ0FBQztLQUM3RDtJQUVELElBQUksU0FBMkIsQ0FBQztJQUNoQyxJQUFJLFdBQVcsWUFBWSxLQUFLLEVBQUU7UUFDaEMsTUFBTSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsR0FBRyxXQUFXLENBQUM7UUFDekMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsa0RBQWtELENBQUMsQ0FBQztTQUNyRTtRQUNELElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLE9BQU8sWUFBWSxXQUFXLENBQUMsRUFBRTtZQUNqRCxNQUFNLElBQUksS0FBSyxDQUNYLHlEQUF5RDtnQkFDekQsWUFBWSxDQUFDLENBQUM7U0FDbkI7UUFDRCxJQUFJLENBQUMsQ0FBQyxlQUFlLElBQUksU0FBUyxDQUFDLEVBQUU7WUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1NBQzVEO1FBQ0QsSUFBSSxDQUFDLENBQUMsaUJBQWlCLElBQUksU0FBUyxDQUFDLEVBQUU7WUFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO1NBQzlEO1FBRUQsTUFBTSxXQUFXLEdBQUcsRUFBRSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDakUsTUFBTSxjQUFjLEdBQ2hCLEVBQUUsQ0FBQyw0QkFBNEIsQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3JFLFNBQVMsR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0tBQy9DO1NBQU0sSUFBSSxNQUFNLElBQUksV0FBVyxFQUFFO1FBQ2hDLGdEQUFnRDtRQUNoRCxTQUFTLEdBQUcsV0FBVyxDQUFDO0tBQ3pCO1NBQU0sSUFDSCxlQUFlLElBQUksV0FBVyxJQUFJLGFBQWEsSUFBSSxXQUFXO1FBQzlELFlBQVksSUFBSSxXQUFXLEVBQUU7UUFDL0IseUNBQXlDO1FBQ3pDLFNBQVMsR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQzVDO1NBQU07UUFDTCxNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUM7S0FDekM7SUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN4QyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDYixPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFFRCxTQUFTLFdBQVcsQ0FBQyxRQUFnQjtJQUNuQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUMzQixRQUFRLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxHQUFHLENBQUM7S0FDN0I7SUFDRCxPQUFPLEdBQUcsUUFBUSxHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixFQUFFLENBQUM7QUFDakUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtkaXNwb3NlLCBJbmZlcmVuY2VNb2RlbCwgaW8sIE1vZGVsUHJlZGljdENvbmZpZywgTmFtZWRUZW5zb3JNYXAsIFRlbnNvciwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0ICogYXMgdGVuc29yZmxvdyBmcm9tICcuLi9kYXRhL2NvbXBpbGVkX2FwaSc7XG5pbXBvcnQge05hbWVkVGVuc29yc01hcCwgVGVuc29ySW5mb30gZnJvbSAnLi4vZGF0YS90eXBlcyc7XG5pbXBvcnQge09wZXJhdGlvbk1hcHBlcn0gZnJvbSAnLi4vb3BlcmF0aW9ucy9vcGVyYXRpb25fbWFwcGVyJztcblxuaW1wb3J0IHtHcmFwaEV4ZWN1dG9yfSBmcm9tICcuL2dyYXBoX2V4ZWN1dG9yJztcbmltcG9ydCB7UmVzb3VyY2VNYW5hZ2VyfSBmcm9tICcuL3Jlc291cmNlX21hbmFnZXInO1xuXG5leHBvcnQgY29uc3QgVEZIVUJfU0VBUkNIX1BBUkFNID0gJz90ZmpzLWZvcm1hdD1maWxlJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX01PREVMX05BTUUgPSAnbW9kZWwuanNvbic7XG50eXBlIFVybCA9IHN0cmluZ3xpby5JT0hhbmRsZXJ8aW8uSU9IYW5kbGVyU3luYztcbnR5cGUgVXJsSU9IYW5kbGVyPFQgZXh0ZW5kcyBVcmw+ID0gVCBleHRlbmRzIHN0cmluZyA/IGlvLklPSGFuZGxlciA6IFQ7XG5cbi8qKlxuICogQSBgdGYuR3JhcGhNb2RlbGAgaXMgYSBkaXJlY3RlZCwgYWN5Y2xpYyBncmFwaCBidWlsdCBmcm9tIGFcbiAqIFNhdmVkTW9kZWwgR3JhcGhEZWYgYW5kIGFsbG93cyBpbmZlcmVuY2UgZXhlY3V0aW9uLlxuICpcbiAqIEEgYHRmLkdyYXBoTW9kZWxgIGNhbiBvbmx5IGJlIGNyZWF0ZWQgYnkgbG9hZGluZyBmcm9tIGEgbW9kZWwgY29udmVydGVkIGZyb21cbiAqIGEgW1RlbnNvckZsb3cgU2F2ZWRNb2RlbF0oaHR0cHM6Ly93d3cudGVuc29yZmxvdy5vcmcvZ3VpZGUvc2F2ZWRfbW9kZWwpIHVzaW5nXG4gKiB0aGUgY29tbWFuZCBsaW5lIGNvbnZlcnRlciB0b29sIGFuZCBsb2FkZWQgdmlhIGB0Zi5sb2FkR3JhcGhNb2RlbGAuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAqL1xuZXhwb3J0IGNsYXNzIEdyYXBoTW9kZWw8TW9kZWxVUkwgZXh0ZW5kcyBVcmwgPSBzdHJpbmcgfCBpby5JT0hhbmRsZXI+IGltcGxlbWVudHNcbiAgICBJbmZlcmVuY2VNb2RlbCB7XG4gIHByaXZhdGUgZXhlY3V0b3I6IEdyYXBoRXhlY3V0b3I7XG4gIHByaXZhdGUgdmVyc2lvbiA9ICduL2EnO1xuICBwcml2YXRlIGhhbmRsZXI6IFVybElPSGFuZGxlcjxNb2RlbFVSTD47XG4gIHByaXZhdGUgYXJ0aWZhY3RzOiBpby5Nb2RlbEFydGlmYWN0cztcbiAgcHJpdmF0ZSBpbml0aWFsaXplcjogR3JhcGhFeGVjdXRvcjtcbiAgcHJpdmF0ZSByZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0OiB7W2tleTogbnVtYmVyXTogVGVuc29yfTtcbiAgcHJpdmF0ZSByZXNvdXJjZU1hbmFnZXI6IFJlc291cmNlTWFuYWdlcjtcbiAgcHJpdmF0ZSBzaWduYXR1cmU6IHRlbnNvcmZsb3cuSVNpZ25hdHVyZURlZjtcbiAgcHJpdmF0ZSBpbml0aWFsaXplclNpZ25hdHVyZTogdGVuc29yZmxvdy5JU2lnbmF0dXJlRGVmO1xuICBwcml2YXRlIHN0cnVjdHVyZWRPdXRwdXRLZXlzOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSByZWFkb25seSBpbzogdHlwZW9mIGlvO1xuXG4gIC8vIFJldHVybnMgdGhlIHZlcnNpb24gaW5mb3JtYXRpb24gZm9yIHRoZSB0ZW5zb3JmbG93IG1vZGVsIEdyYXBoRGVmLlxuICBnZXQgbW9kZWxWZXJzaW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbiAgfVxuXG4gIGdldCBpbnB1dE5vZGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dE5vZGVzO1xuICB9XG5cbiAgZ2V0IG91dHB1dE5vZGVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRvci5vdXRwdXROb2RlcztcbiAgfVxuXG4gIGdldCBpbnB1dHMoKTogVGVuc29ySW5mb1tdIHtcbiAgICByZXR1cm4gdGhpcy5leGVjdXRvci5pbnB1dHM7XG4gIH1cblxuICBnZXQgb3V0cHV0cygpOiBUZW5zb3JJbmZvW10ge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLm91dHB1dHM7XG4gIH1cblxuICBnZXQgd2VpZ2h0cygpOiBOYW1lZFRlbnNvcnNNYXAge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dG9yLndlaWdodE1hcDtcbiAgfVxuXG4gIGdldCBtZXRhZGF0YSgpOiB7fSB7XG4gICAgcmV0dXJuIHRoaXMuYXJ0aWZhY3RzLnVzZXJEZWZpbmVkTWV0YWRhdGE7XG4gIH1cblxuICBnZXQgbW9kZWxTaWduYXR1cmUoKToge30ge1xuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZTtcbiAgfVxuXG4gIGdldCBtb2RlbFN0cnVjdHVyZWRPdXRwdXRLZXlzKCk6IHt9IHtcbiAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkT3V0cHV0S2V5cztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gbW9kZWxVcmwgdXJsIGZvciB0aGUgbW9kZWwsIG9yIGFuIGBpby5JT0hhbmRsZXJgLlxuICAgKiBAcGFyYW0gd2VpZ2h0TWFuaWZlc3RVcmwgdXJsIGZvciB0aGUgd2VpZ2h0IGZpbGUgZ2VuZXJhdGVkIGJ5XG4gICAqIHNjcmlwdHMvY29udmVydC5weSBzY3JpcHQuXG4gICAqIEBwYXJhbSByZXF1ZXN0T3B0aW9uIG9wdGlvbnMgZm9yIFJlcXVlc3QsIHdoaWNoIGFsbG93cyB0byBzZW5kIGNyZWRlbnRpYWxzXG4gICAqIGFuZCBjdXN0b20gaGVhZGVycy5cbiAgICogQHBhcmFtIG9uUHJvZ3Jlc3MgT3B0aW9uYWwsIHByb2dyZXNzIGNhbGxiYWNrIGZ1bmN0aW9uLCBmaXJlZCBwZXJpb2RpY2FsbHlcbiAgICogYmVmb3JlIHRoZSBsb2FkIGlzIGNvbXBsZXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSBtb2RlbFVybDogTW9kZWxVUkwsIHByaXZhdGUgbG9hZE9wdGlvbnM6IGlvLkxvYWRPcHRpb25zID0ge30sXG4gICAgICB0ZmlvID0gaW8pIHtcbiAgICB0aGlzLmlvID0gdGZpbztcbiAgICBpZiAobG9hZE9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5sb2FkT3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLnJlc291cmNlTWFuYWdlciA9IG5ldyBSZXNvdXJjZU1hbmFnZXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgZmluZElPSGFuZGxlcigpIHtcbiAgICB0eXBlIElPSGFuZGxlciA9IFVybElPSGFuZGxlcjxNb2RlbFVSTD47XG4gICAgY29uc3QgcGF0aCA9IHRoaXMubW9kZWxVcmw7XG4gICAgaWYgKChwYXRoIGFzIGlvLklPSGFuZGxlcikubG9hZCAhPSBudWxsKSB7XG4gICAgICAvLyBQYXRoIGlzIGFuIElPIEhhbmRsZXIuXG4gICAgICB0aGlzLmhhbmRsZXIgPSBwYXRoIGFzIElPSGFuZGxlcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMubG9hZE9wdGlvbnMucmVxdWVzdEluaXQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5oYW5kbGVyID0gdGhpcy5pby5icm93c2VySFRUUFJlcXVlc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCBhcyBzdHJpbmcsIHRoaXMubG9hZE9wdGlvbnMpIGFzIElPSGFuZGxlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFuZGxlcnMgPVxuICAgICAgICAgIHRoaXMuaW8uZ2V0TG9hZEhhbmRsZXJzKHBhdGggYXMgc3RyaW5nLCB0aGlzLmxvYWRPcHRpb25zKTtcbiAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGlmIG5vIGxvYWQgaGFuZGxlciBjYW4gYmUgZm91bmQsXG4gICAgICAgIC8vIGFzc3VtZSBpdCBpcyBhIHJlbGF0aXZlIGh0dHAgcGF0aC5cbiAgICAgICAgaGFuZGxlcnMucHVzaChcbiAgICAgICAgICAgIHRoaXMuaW8uYnJvd3NlckhUVFBSZXF1ZXN0KHBhdGggYXMgc3RyaW5nLCB0aGlzLmxvYWRPcHRpb25zKSk7XG4gICAgICB9IGVsc2UgaWYgKGhhbmRsZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZvdW5kIG1vcmUgdGhhbiBvbmUgKCR7aGFuZGxlcnMubGVuZ3RofSkgbG9hZCBoYW5kbGVycyBmb3IgYCArXG4gICAgICAgICAgICBgVVJMICcke1twYXRoXX0nYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyc1swXSBhcyBJT0hhbmRsZXI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRoZSBtb2RlbCBhbmQgd2VpZ2h0IGZpbGVzLCBjb25zdHJ1Y3QgdGhlIGluIG1lbW9yeSB3ZWlnaHQgbWFwIGFuZFxuICAgKiBjb21waWxlIHRoZSBpbmZlcmVuY2UgZ3JhcGguXG4gICAqL1xuICBsb2FkKCk6IFVybElPSGFuZGxlcjxNb2RlbFVSTD4gZXh0ZW5kcyBpby5JT0hhbmRsZXJTeW5jPyBib29sZWFuOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHlwZSBJT0hhbmRsZXIgPSBVcmxJT0hhbmRsZXI8TW9kZWxVUkw+O1xuICAgIHRoaXMuZmluZElPSGFuZGxlcigpO1xuICAgIGlmICh0aGlzLmhhbmRsZXIubG9hZCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgJyArXG4gICAgICAgICAgJ2RvZXMgbm90IGhhdmUgdGhlIGBsb2FkYCBtZXRob2QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuXG4gICAgdHlwZSBSZXN1bHQgPVxuICAgICAgICBJT0hhbmRsZXIgZXh0ZW5kcyBpby5JT0hhbmRsZXJTeW5jID8gYm9vbGVhbiA6IFByb21pc2U8Ym9vbGVhbj47XG5cbiAgICBjb25zdCBsb2FkUmVzdWx0ID0gdGhpcy5oYW5kbGVyLmxvYWQoKSBhcyBSZXR1cm5UeXBlPElPSGFuZGxlclsnbG9hZCddPjtcbiAgICBpZiAodXRpbC5pc1Byb21pc2UobG9hZFJlc3VsdCkpIHtcbiAgICAgIHJldHVybiBsb2FkUmVzdWx0LnRoZW4oYXJ0aWZhY3RzID0+IHRoaXMubG9hZFN5bmMoYXJ0aWZhY3RzKSkgYXMgUmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmxvYWRTeW5jKGxvYWRSZXN1bHQpIGFzIFJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbm91c2x5IGNvbnN0cnVjdCB0aGUgaW4gbWVtb3J5IHdlaWdodCBtYXAgYW5kXG4gICAqIGNvbXBpbGUgdGhlIGluZmVyZW5jZSBncmFwaC5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgaWdub3JlQ0k6IHRydWV9XG4gICAqL1xuICBsb2FkU3luYyhhcnRpZmFjdHM6IGlvLk1vZGVsQXJ0aWZhY3RzKSB7XG4gICAgdGhpcy5hcnRpZmFjdHMgPSBhcnRpZmFjdHM7XG4gICAgY29uc3QgZ3JhcGggPSB0aGlzLmFydGlmYWN0cy5tb2RlbFRvcG9sb2d5IGFzIHRlbnNvcmZsb3cuSUdyYXBoRGVmO1xuXG4gICAgbGV0IHNpZ25hdHVyZSA9IHRoaXMuYXJ0aWZhY3RzLnNpZ25hdHVyZTtcbiAgICBpZiAodGhpcy5hcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuYXJ0aWZhY3RzLnVzZXJEZWZpbmVkTWV0YWRhdGE7XG4gICAgICBpZiAobWV0YWRhdGEuc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2lnbmF0dXJlID0gbWV0YWRhdGEuc2lnbmF0dXJlO1xuICAgICAgfVxuXG4gICAgICBpZiAobWV0YWRhdGEuc3RydWN0dXJlZE91dHB1dEtleXMgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnN0cnVjdHVyZWRPdXRwdXRLZXlzID0gbWV0YWRhdGEuc3RydWN0dXJlZE91dHB1dEtleXMgYXMgc3RyaW5nW107XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuXG4gICAgdGhpcy52ZXJzaW9uID0gYCR7Z3JhcGgudmVyc2lvbnMucHJvZHVjZXJ9LiR7Z3JhcGgudmVyc2lvbnMubWluQ29uc3VtZXJ9YDtcbiAgICBjb25zdCB3ZWlnaHRNYXAgPSB0aGlzLmlvLmRlY29kZVdlaWdodHMoXG4gICAgICAgIHRoaXMuYXJ0aWZhY3RzLndlaWdodERhdGEsIHRoaXMuYXJ0aWZhY3RzLndlaWdodFNwZWNzKTtcbiAgICB0aGlzLmV4ZWN1dG9yID0gbmV3IEdyYXBoRXhlY3V0b3IoXG4gICAgICAgIE9wZXJhdGlvbk1hcHBlci5JbnN0YW5jZS50cmFuc2Zvcm1HcmFwaChncmFwaCwgdGhpcy5zaWduYXR1cmUpKTtcbiAgICB0aGlzLmV4ZWN1dG9yLndlaWdodE1hcCA9IHRoaXMuY29udmVydFRlbnNvck1hcFRvVGVuc29yc01hcCh3ZWlnaHRNYXApO1xuICAgIC8vIEF0dGFjaCBhIG1vZGVsLWxldmVsIHJlc291cmNlTWFuYWdlciB0byBlYWNoIGV4ZWN1dG9yIHRvIHNoYXJlIHJlc291cmNlcyxcbiAgICAvLyBzdWNoIGFzIGBIYXNoVGFibGVgLlxuICAgIHRoaXMuZXhlY3V0b3IucmVzb3VyY2VNYW5hZ2VyID0gdGhpcy5yZXNvdXJjZU1hbmFnZXI7XG5cbiAgICBpZiAoYXJ0aWZhY3RzLm1vZGVsSW5pdGlhbGl6ZXIgIT0gbnVsbCAmJlxuICAgICAgICAoYXJ0aWZhY3RzLm1vZGVsSW5pdGlhbGl6ZXIgYXMgdGVuc29yZmxvdy5JR3JhcGhEZWYpLm5vZGUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgaW5pdGlhbGl6ZXIgPVxuICAgICAgICAgIE9wZXJhdGlvbk1hcHBlci5JbnN0YW5jZS50cmFuc2Zvcm1HcmFwaChhcnRpZmFjdHMubW9kZWxJbml0aWFsaXplcik7XG4gICAgICB0aGlzLmluaXRpYWxpemVyID0gbmV3IEdyYXBoRXhlY3V0b3IoaW5pdGlhbGl6ZXIpO1xuICAgICAgdGhpcy5pbml0aWFsaXplci53ZWlnaHRNYXAgPSB0aGlzLmV4ZWN1dG9yLndlaWdodE1hcDtcbiAgICAgIC8vIEF0dGFjaCBhIG1vZGVsLWxldmVsIHJlc291cmNlTWFuYWdlciB0byB0aGUgaW5pdGlhbGl6ZXIsIHRoZVxuICAgICAgLy8gaGFzaFRhYmxlcyBjcmVhdGVkIGZyb20gd2hlbiBleGVjdXRpbmcgdGhlIGluaXRpYWxpemVyIHdpbGwgYmUgc3RvcmVkXG4gICAgICAvLyBpbiB0aGUgcmVzb3VyY2VNYW5hZ2VyLlxuICAgICAgdGhpcy5pbml0aWFsaXplci5yZXNvdXJjZU1hbmFnZXIgPSB0aGlzLnJlc291cmNlTWFuYWdlcjtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXJTaWduYXR1cmUgPSBhcnRpZmFjdHMuaW5pdGlhbGl6ZXJTaWduYXR1cmU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZSB0aGUgY29uZmlndXJhdGlvbiBhbmQvb3Igd2VpZ2h0cyBvZiB0aGUgR3JhcGhNb2RlbC5cbiAgICpcbiAgICogQW4gYElPSGFuZGxlcmAgaXMgYW4gb2JqZWN0IHRoYXQgaGFzIGEgYHNhdmVgIG1ldGhvZCBvZiB0aGUgcHJvcGVyXG4gICAqIHNpZ25hdHVyZSBkZWZpbmVkLiBUaGUgYHNhdmVgIG1ldGhvZCBtYW5hZ2VzIHRoZSBzdG9yaW5nIG9yXG4gICAqIHRyYW5zbWlzc2lvbiBvZiBzZXJpYWxpemVkIGRhdGEgKFwiYXJ0aWZhY3RzXCIpIHRoYXQgcmVwcmVzZW50IHRoZVxuICAgKiBtb2RlbCdzIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIG9udG8gb3IgdmlhIGEgc3BlY2lmaWMgbWVkaXVtLCBzdWNoIGFzXG4gICAqIGZpbGUgZG93bmxvYWRzLCBsb2NhbCBzdG9yYWdlLCBJbmRleGVkREIgaW4gdGhlIHdlYiBicm93c2VyIGFuZCBIVFRQXG4gICAqIHJlcXVlc3RzIHRvIGEgc2VydmVyLiBUZW5zb3JGbG93LmpzIHByb3ZpZGVzIGBJT0hhbmRsZXJgXG4gICAqIGltcGxlbWVudGF0aW9ucyBmb3IgYSBudW1iZXIgb2YgZnJlcXVlbnRseSB1c2VkIHNhdmluZyBtZWRpdW1zLCBzdWNoIGFzXG4gICAqIGB0Zi5pby5icm93c2VyRG93bmxvYWRzYCBhbmQgYHRmLmlvLmJyb3dzZXJMb2NhbFN0b3JhZ2VgLiBTZWUgYHRmLmlvYFxuICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhbHNvIGFsbG93cyB5b3UgdG8gcmVmZXIgdG8gY2VydGFpbiB0eXBlcyBvZiBgSU9IYW5kbGVyYHNcbiAgICogYXMgVVJMLWxpa2Ugc3RyaW5nIHNob3J0Y3V0cywgc3VjaCBhcyAnbG9jYWxzdG9yYWdlOi8vJyBhbmRcbiAgICogJ2luZGV4ZWRkYjovLycuXG4gICAqXG4gICAqIEV4YW1wbGUgMTogU2F2ZSBgbW9kZWxgJ3MgdG9wb2xvZ3kgYW5kIHdlaWdodHMgdG8gYnJvd3NlciBbbG9jYWxcbiAgICogc3RvcmFnZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9sb2NhbFN0b3JhZ2UpO1xuICAgKiB0aGVuIGxvYWQgaXQgYmFjay5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgbW9kZWxVcmwgPVxuICAgKiAgICAnaHR0cHM6Ly9zdG9yYWdlLmdvb2dsZWFwaXMuY29tL3RmanMtbW9kZWxzL3NhdmVkbW9kZWwvbW9iaWxlbmV0X3YyXzEuMF8yMjQvbW9kZWwuanNvbic7XG4gICAqIGNvbnN0IG1vZGVsID0gYXdhaXQgdGYubG9hZEdyYXBoTW9kZWwobW9kZWxVcmwpO1xuICAgKiBjb25zdCB6ZXJvcyA9IHRmLnplcm9zKFsxLCAyMjQsIDIyNCwgM10pO1xuICAgKiBtb2RlbC5wcmVkaWN0KHplcm9zKS5wcmludCgpO1xuICAgKlxuICAgKiBjb25zdCBzYXZlUmVzdWx0cyA9IGF3YWl0IG1vZGVsLnNhdmUoJ2xvY2Fsc3RvcmFnZTovL215LW1vZGVsLTEnKTtcbiAgICpcbiAgICogY29uc3QgbG9hZGVkTW9kZWwgPSBhd2FpdCB0Zi5sb2FkR3JhcGhNb2RlbCgnbG9jYWxzdG9yYWdlOi8vbXktbW9kZWwtMScpO1xuICAgKiBjb25zb2xlLmxvZygnUHJlZGljdGlvbiBmcm9tIGxvYWRlZCBtb2RlbDonKTtcbiAgICogbW9kZWwucHJlZGljdCh6ZXJvcykucHJpbnQoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBoYW5kbGVyT3JVUkwgQW4gaW5zdGFuY2Ugb2YgYElPSGFuZGxlcmAgb3IgYSBVUkwtbGlrZSxcbiAgICogc2NoZW1lLWJhc2VkIHN0cmluZyBzaG9ydGN1dCBmb3IgYElPSGFuZGxlcmAuXG4gICAqIEBwYXJhbSBjb25maWcgT3B0aW9ucyBmb3Igc2F2aW5nIHRoZSBtb2RlbC5cbiAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgb2YgYFNhdmVSZXN1bHRgLCB3aGljaCBzdW1tYXJpemVzIHRoZSByZXN1bHQgb2ZcbiAgICogdGhlIHNhdmluZywgc3VjaCBhcyBieXRlIHNpemVzIG9mIHRoZSBzYXZlZCBhcnRpZmFjdHMgZm9yIHRoZSBtb2RlbCdzXG4gICAqICAgdG9wb2xvZ3kgYW5kIHdlaWdodCB2YWx1ZXMuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIGlnbm9yZUNJOiB0cnVlfVxuICAgKi9cbiAgYXN5bmMgc2F2ZShoYW5kbGVyT3JVUkw6IGlvLklPSGFuZGxlcnxzdHJpbmcsIGNvbmZpZz86IGlvLlNhdmVDb25maWcpOlxuICAgICAgUHJvbWlzZTxpby5TYXZlUmVzdWx0PiB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyT3JVUkwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuaW8uZ2V0U2F2ZUhhbmRsZXJzKGhhbmRsZXJPclVSTCk7XG4gICAgICBpZiAoaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgZmluZCBhbnkgc2F2ZSBoYW5kbGVycyBmb3IgVVJMICcke2hhbmRsZXJPclVSTH0nYCk7XG4gICAgICB9IGVsc2UgaWYgKGhhbmRsZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZvdW5kIG1vcmUgdGhhbiBvbmUgKCR7aGFuZGxlcnMubGVuZ3RofSkgc2F2ZSBoYW5kbGVycyBmb3IgYCArXG4gICAgICAgICAgICBgVVJMICcke2hhbmRsZXJPclVSTH0nYCk7XG4gICAgICB9XG4gICAgICBoYW5kbGVyT3JVUkwgPSBoYW5kbGVyc1swXTtcbiAgICB9XG4gICAgaWYgKGhhbmRsZXJPclVSTC5zYXZlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnR3JhcGhNb2RlbC5zYXZlKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgSU9IYW5kbGVyICcgK1xuICAgICAgICAgICdwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgc2F2ZWAgYXR0cmlidXRlIGRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhbmRsZXJPclVSTC5zYXZlKHRoaXMuYXJ0aWZhY3RzKTtcbiAgfVxuXG4gIHByaXZhdGUgYWRkU3RydWN0dXJlZE91dHB1dE5hbWVzKG91dHB1dFRlbnNvcnM6IFRlbnNvcnxUZW5zb3JbXSkge1xuICAgIGlmICh0aGlzLnN0cnVjdHVyZWRPdXRwdXRLZXlzKSB7XG4gICAgICBjb25zdCBvdXRwdXRUZW5zb3JzQXJyYXkgPVxuICAgICAgICAgIG91dHB1dFRlbnNvcnMgaW5zdGFuY2VvZiBUZW5zb3IgPyBbb3V0cHV0VGVuc29yc10gOiBvdXRwdXRUZW5zb3JzO1xuICAgICAgY29uc3Qgb3V0cHV0VGVuc29yTWFwOiBOYW1lZFRlbnNvck1hcCA9IHt9O1xuXG4gICAgICBvdXRwdXRUZW5zb3JzQXJyYXkuZm9yRWFjaChcbiAgICAgICAgICAob3V0cHV0VGVuc29yLCBpKSA9PiBvdXRwdXRUZW5zb3JNYXBbdGhpcy5zdHJ1Y3R1cmVkT3V0cHV0S2V5c1tpXV0gPVxuICAgICAgICAgICAgICBvdXRwdXRUZW5zb3IpO1xuXG4gICAgICByZXR1cm4gb3V0cHV0VGVuc29yTWFwO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0VGVuc29ycztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIHRoZSBpbmZlcmVuY2UgZm9yIHRoZSBpbnB1dCB0ZW5zb3JzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRlbnNvcnMsIHdoZW4gdGhlcmUgaXMgc2luZ2xlIGlucHV0IGZvciB0aGUgbW9kZWwsXG4gICAqIGlucHV0cyBwYXJhbSBzaG91bGQgYmUgYSBgdGYuVGVuc29yYC4gRm9yIG1vZGVscyB3aXRoIG11dGxpcGxlIGlucHV0cyxcbiAgICogaW5wdXRzIHBhcmFtcyBzaG91bGQgYmUgaW4gZWl0aGVyIGB0Zi5UZW5zb3JgW10gaWYgdGhlIGlucHV0IG9yZGVyIGlzXG4gICAqIGZpeGVkLCBvciBvdGhlcndpc2UgTmFtZWRUZW5zb3JNYXAgZm9ybWF0LlxuICAgKlxuICAgKiBGb3IgbW9kZWwgd2l0aCBtdWx0aXBsZSBpbnB1dHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIE5hbWVkVGVuc29yTWFwIGFzIHRoZVxuICAgKiBpbnB1dCB0eXBlLCBpZiB5b3UgdXNlIGB0Zi5UZW5zb3JgW10sIHRoZSBvcmRlciBvZiB0aGUgYXJyYXkgbmVlZHMgdG9cbiAgICogZm9sbG93IHRoZVxuICAgKiBvcmRlciBvZiBpbnB1dE5vZGVzIGFycmF5LiBAc2VlIHtAbGluayBHcmFwaE1vZGVsLmlucHV0Tm9kZXN9XG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBmZWVkIGFueSBpbnRlcm1lZGlhdGUgbm9kZXMgdXNpbmcgdGhlIE5hbWVkVGVuc29yTWFwIGFzIHRoZVxuICAgKiBpbnB1dCB0eXBlLiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGdyYXBoXG4gICAqICAgIElucHV0Tm9kZSA9PiBJbnRlcm1lZGlhdGUgPT4gT3V0cHV0Tm9kZSxcbiAgICogeW91IGNhbiBleGVjdXRlIHRoZSBzdWJncmFwaCBJbnRlcm1lZGlhdGUgPT4gT3V0cHV0Tm9kZSBieSBjYWxsaW5nXG4gICAqICAgIG1vZGVsLmV4ZWN1dGUoJ0ludGVybWVkaWF0ZU5vZGUnIDogdGYudGVuc29yKC4uLikpO1xuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9kZWxzIHRoYXQgdXNlcyB0Zi5keW5hbWljX3Jubiwgd2hlcmUgdGhlIGludGVybWVkaWF0ZVxuICAgKiBzdGF0ZSBuZWVkcyB0byBiZSBmZWQgbWFudWFsbHkuXG4gICAqXG4gICAqIEZvciBiYXRjaCBpbmZlcmVuY2UgZXhlY3V0aW9uLCB0aGUgdGVuc29ycyBmb3IgZWFjaCBpbnB1dCBuZWVkIHRvIGJlXG4gICAqIGNvbmNhdGVuYXRlZCB0b2dldGhlci4gRm9yIGV4YW1wbGUgd2l0aCBtb2JpbGVuZXQsIHRoZSByZXF1aXJlZCBpbnB1dCBzaGFwZVxuICAgKiBpcyBbMSwgMjQ0LCAyNDQsIDNdLCB3aGljaCByZXByZXNlbnRzIHRoZSBbYmF0Y2gsIGhlaWdodCwgd2lkdGgsIGNoYW5uZWxdLlxuICAgKiBJZiB3ZSBhcmUgcHJvdmlkZSBhIGJhdGNoZWQgZGF0YSBvZiAxMDAgaW1hZ2VzLCB0aGUgaW5wdXQgdGVuc29yIHNob3VsZCBiZVxuICAgKiBpbiB0aGUgc2hhcGUgb2YgWzEwMCwgMjQ0LCAyNDQsIDNdLlxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIFByZWRpY3Rpb24gY29uZmlndXJhdGlvbiBmb3Igc3BlY2lmeWluZyB0aGUgYmF0Y2ggc2l6ZS5cbiAgICogQ3VycmVudGx5IHRoZSBiYXRjaCBzaXplIG9wdGlvbiBpcyBpZ25vcmVkIGZvciBncmFwaCBtb2RlbC5cbiAgICpcbiAgICogQHJldHVybnMgSW5mZXJlbmNlIHJlc3VsdCB0ZW5zb3JzLiBJZiB0aGUgbW9kZWwgaXMgY29udmVydGVkIGFuZCBpdFxuICAgKiBvcmlnaW5hbGx5IGhhZCBzdHJ1Y3R1cmVkX291dHB1dHMgaW4gdGVuc29yZmxvdywgdGhlbiBhIE5hbWVkVGVuc29yTWFwXG4gICAqIHdpbGwgYmUgcmV0dXJuZWQgbWF0Y2hpbmcgdGhlIHN0cnVjdHVyZWRfb3V0cHV0cy4gSWYgbm8gc3RydWN0dXJlZF9vdXRwdXRzXG4gICAqIGFyZSBwcmVzZW50LCB0aGUgb3V0cHV0IHdpbGwgYmUgc2luZ2xlIGB0Zi5UZW5zb3JgIGlmIHRoZSBtb2RlbCBoYXMgc2luZ2xlXG4gICAqIG91dHB1dCBub2RlLCBvdGhlcndpc2UgVGVuc29yW10uXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBwcmVkaWN0KGlucHV0czogVGVuc29yfFRlbnNvcltdfE5hbWVkVGVuc29yTWFwLCBjb25maWc/OiBNb2RlbFByZWRpY3RDb25maWcpOlxuICAgICAgVGVuc29yfFRlbnNvcltdfE5hbWVkVGVuc29yTWFwIHtcbiAgICBjb25zdCBvdXRwdXRUZW5zb3JzID0gdGhpcy5leGVjdXRlKGlucHV0cywgdGhpcy5vdXRwdXROb2Rlcyk7XG4gICAgcmV0dXJuIHRoaXMuYWRkU3RydWN0dXJlZE91dHB1dE5hbWVzKG91dHB1dFRlbnNvcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIGluZmVyZW5jZSBmb3IgdGhlIGlucHV0IHRlbnNvcnMgaW4gYXN5bmMgZmFzaGlvbiwgdXNlIHRoaXNcbiAgICogbWV0aG9kIHdoZW4geW91ciBtb2RlbCBjb250YWlucyBjb250cm9sIGZsb3cgb3BzLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IHRlbnNvcnMsIHdoZW4gdGhlcmUgaXMgc2luZ2xlIGlucHV0IGZvciB0aGUgbW9kZWwsXG4gICAqIGlucHV0cyBwYXJhbSBzaG91bGQgYmUgYSBgdGYuVGVuc29yYC4gRm9yIG1vZGVscyB3aXRoIG11dGxpcGxlIGlucHV0cyxcbiAgICogaW5wdXRzIHBhcmFtcyBzaG91bGQgYmUgaW4gZWl0aGVyIGB0Zi5UZW5zb3JgW10gaWYgdGhlIGlucHV0IG9yZGVyIGlzXG4gICAqIGZpeGVkLCBvciBvdGhlcndpc2UgTmFtZWRUZW5zb3JNYXAgZm9ybWF0LlxuICAgKlxuICAgKiBGb3IgbW9kZWwgd2l0aCBtdWx0aXBsZSBpbnB1dHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIE5hbWVkVGVuc29yTWFwIGFzIHRoZVxuICAgKiBpbnB1dCB0eXBlLCBpZiB5b3UgdXNlIGB0Zi5UZW5zb3JgW10sIHRoZSBvcmRlciBvZiB0aGUgYXJyYXkgbmVlZHMgdG9cbiAgICogZm9sbG93IHRoZVxuICAgKiBvcmRlciBvZiBpbnB1dE5vZGVzIGFycmF5LiBAc2VlIHtAbGluayBHcmFwaE1vZGVsLmlucHV0Tm9kZXN9XG4gICAqXG4gICAqIFlvdSBjYW4gYWxzbyBmZWVkIGFueSBpbnRlcm1lZGlhdGUgbm9kZXMgdXNpbmcgdGhlIE5hbWVkVGVuc29yTWFwIGFzIHRoZVxuICAgKiBpbnB1dCB0eXBlLiBGb3IgZXhhbXBsZSwgZ2l2ZW4gdGhlIGdyYXBoXG4gICAqICAgIElucHV0Tm9kZSA9PiBJbnRlcm1lZGlhdGUgPT4gT3V0cHV0Tm9kZSxcbiAgICogeW91IGNhbiBleGVjdXRlIHRoZSBzdWJncmFwaCBJbnRlcm1lZGlhdGUgPT4gT3V0cHV0Tm9kZSBieSBjYWxsaW5nXG4gICAqICAgIG1vZGVsLmV4ZWN1dGUoJ0ludGVybWVkaWF0ZU5vZGUnIDogdGYudGVuc29yKC4uLikpO1xuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbW9kZWxzIHRoYXQgdXNlcyB0Zi5keW5hbWljX3Jubiwgd2hlcmUgdGhlIGludGVybWVkaWF0ZVxuICAgKiBzdGF0ZSBuZWVkcyB0byBiZSBmZWQgbWFudWFsbHkuXG4gICAqXG4gICAqIEZvciBiYXRjaCBpbmZlcmVuY2UgZXhlY3V0aW9uLCB0aGUgdGVuc29ycyBmb3IgZWFjaCBpbnB1dCBuZWVkIHRvIGJlXG4gICAqIGNvbmNhdGVuYXRlZCB0b2dldGhlci4gRm9yIGV4YW1wbGUgd2l0aCBtb2JpbGVuZXQsIHRoZSByZXF1aXJlZCBpbnB1dCBzaGFwZVxuICAgKiBpcyBbMSwgMjQ0LCAyNDQsIDNdLCB3aGljaCByZXByZXNlbnRzIHRoZSBbYmF0Y2gsIGhlaWdodCwgd2lkdGgsIGNoYW5uZWxdLlxuICAgKiBJZiB3ZSBhcmUgcHJvdmlkZSBhIGJhdGNoZWQgZGF0YSBvZiAxMDAgaW1hZ2VzLCB0aGUgaW5wdXQgdGVuc29yIHNob3VsZCBiZVxuICAgKiBpbiB0aGUgc2hhcGUgb2YgWzEwMCwgMjQ0LCAyNDQsIDNdLlxuICAgKlxuICAgKiBAcGFyYW0gY29uZmlnIFByZWRpY3Rpb24gY29uZmlndXJhdGlvbiBmb3Igc3BlY2lmeWluZyB0aGUgYmF0Y2ggc2l6ZS5cbiAgICogQ3VycmVudGx5IHRoZSBiYXRjaCBzaXplIG9wdGlvbiBpcyBpZ25vcmVkIGZvciBncmFwaCBtb2RlbC5cbiAgICpcbiAgICogQHJldHVybnMgQSBQcm9taXNlIG9mIGluZmVyZW5jZSByZXN1bHQgdGVuc29ycy4gSWYgdGhlIG1vZGVsIGlzIGNvbnZlcnRlZFxuICAgKiBhbmQgaXQgb3JpZ2luYWxseSBoYWQgc3RydWN0dXJlZF9vdXRwdXRzIGluIHRlbnNvcmZsb3csIHRoZW4gYVxuICAgKiBOYW1lZFRlbnNvck1hcCB3aWxsIGJlIHJldHVybmVkIG1hdGNoaW5nIHRoZSBzdHJ1Y3R1cmVkX291dHB1dHMuIElmIG5vXG4gICAqIHN0cnVjdHVyZWRfb3V0cHV0cyBhcmUgcHJlc2VudCwgdGhlIG91dHB1dCB3aWxsIGJlIHNpbmdsZSBgdGYuVGVuc29yYCBpZlxuICAgKiB0aGUgbW9kZWwgaGFzIHNpbmdsZSBvdXRwdXQgbm9kZSwgb3RoZXJ3aXNlIFRlbnNvcltdLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgYXN5bmMgcHJlZGljdEFzeW5jKFxuICAgICAgaW5wdXRzOiBUZW5zb3J8VGVuc29yW118TmFtZWRUZW5zb3JNYXAsXG4gICAgICBjb25maWc/OiBNb2RlbFByZWRpY3RDb25maWcpOiBQcm9taXNlPFRlbnNvcnxUZW5zb3JbXXxOYW1lZFRlbnNvck1hcD4ge1xuICAgIGNvbnN0IG91dHB1dFRlbnNvcnMgPSBhd2FpdCB0aGlzLmV4ZWN1dGVBc3luYyhpbnB1dHMsIHRoaXMub3V0cHV0Tm9kZXMpO1xuICAgIHJldHVybiB0aGlzLmFkZFN0cnVjdHVyZWRPdXRwdXROYW1lcyhvdXRwdXRUZW5zb3JzKTtcbiAgfVxuXG4gIHByaXZhdGUgbm9ybWFsaXplSW5wdXRzKGlucHV0czogVGVuc29yfFRlbnNvcltdfFxuICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lZFRlbnNvck1hcCk6IE5hbWVkVGVuc29yTWFwIHtcbiAgICBpZiAoIShpbnB1dHMgaW5zdGFuY2VvZiBUZW5zb3IpICYmICFBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgIC8vIFRoZSBpbnB1dCBpcyBhbHJlYWR5IGEgTmFtZWRUZW5zb3JNYXAuXG4gICAgICBjb25zdCBzaWduYXR1cmVJbnB1dHMgPSB0aGlzLnNpZ25hdHVyZT8uaW5wdXRzO1xuICAgICAgaWYgKHNpZ25hdHVyZUlucHV0cyAhPSBudWxsKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5wdXQgaW4gc2lnbmF0dXJlSW5wdXRzKSB7XG4gICAgICAgICAgY29uc3QgdGVuc29yID0gc2lnbmF0dXJlSW5wdXRzW2lucHV0XTtcbiAgICAgICAgICBpZiAodGVuc29yLnJlc291cmNlSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXRzW2lucHV0XSA9IHRoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dFt0ZW5zb3IucmVzb3VyY2VJZF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cbiAgICBpbnB1dHMgPSBBcnJheS5pc0FycmF5KGlucHV0cykgPyBpbnB1dHMgOiBbaW5wdXRzXTtcblxuICAgIGNvbnN0IG51bUNhcHR1cmVkSW5wdXRzID1cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5yZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0KS5sZW5ndGg7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggKyBudW1DYXB0dXJlZElucHV0cyAhPT0gdGhpcy5pbnB1dE5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCB0ZW5zb3IgY291bnQgbWlzbWF0Y2gsIHRoZSBncmFwaCBtb2RlbCBoYXMgJHtcbiAgICAgICAgICB0aGlzLmlucHV0Tm9kZXMubGVuZ3RoIC1cbiAgICAgICAgICBudW1DYXB0dXJlZElucHV0c30gbm9uLXJlc291cmNlIHBsYWNlaG9sZGVycywgd2hpbGUgdGhlcmUgYXJlICR7XG4gICAgICAgICAgaW5wdXRzLmxlbmd0aH0gaW5wdXQgdGVuc29ycyBwcm92aWRlZC5gKTtcbiAgICB9XG5cbiAgICBsZXQgaW5wdXRJbmRleCA9IDA7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXROb2Rlcy5yZWR1Y2UoKG1hcCwgaW5wdXROYW1lKSA9PiB7XG4gICAgICBjb25zdCByZXNvdXJjZUlkID0gdGhpcy5zaWduYXR1cmU/LmlucHV0cz8uW2lucHV0TmFtZV0/LnJlc291cmNlSWQ7XG4gICAgICBpZiAocmVzb3VyY2VJZCAhPSBudWxsKSB7XG4gICAgICAgIG1hcFtpbnB1dE5hbWVdID0gdGhpcy5yZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0W3Jlc291cmNlSWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwW2lucHV0TmFtZV0gPSAoaW5wdXRzIGFzIFRlbnNvcltdKVtpbnB1dEluZGV4KytdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCB7fSBhcyBOYW1lZFRlbnNvck1hcCk7XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZU91dHB1dHMob3V0cHV0czogc3RyaW5nfHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICAgIG91dHB1dHMgPSBvdXRwdXRzIHx8IHRoaXMub3V0cHV0Tm9kZXM7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KG91dHB1dHMpID8gW291dHB1dHNdIDogb3V0cHV0cztcbiAgfVxuXG4gIHByaXZhdGUgZXhlY3V0ZUluaXRpYWxpemVyR3JhcGgoKSB7XG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbml0aWFsaXplclNpZ25hdHVyZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplci5leGVjdXRlKHt9LCBbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVyLmV4ZWN1dGUoXG4gICAgICAgICAge30sIE9iamVjdC5rZXlzKHRoaXMuaW5pdGlhbGl6ZXJTaWduYXR1cmUub3V0cHV0cykpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZXhlY3V0ZUluaXRpYWxpemVyR3JhcGhBc3luYygpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICh0aGlzLmluaXRpYWxpemVyU2lnbmF0dXJlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemVyLmV4ZWN1dGVBc3luYyh7fSwgW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplci5leGVjdXRlQXN5bmMoXG4gICAgICAgICAge30sIE9iamVjdC5rZXlzKHRoaXMuaW5pdGlhbGl6ZXJTaWduYXR1cmUub3V0cHV0cykpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0UmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dChvdXRwdXRzOiBUZW5zb3JbXSkge1xuICAgIHRoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dCA9IHt9O1xuXG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZXJTaWduYXR1cmUpIHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZU91dHB1dHMgPSB0aGlzLmluaXRpYWxpemVyU2lnbmF0dXJlLm91dHB1dHM7XG4gICAgICBjb25zdCBvdXRwdXROYW1lcyA9IE9iamVjdC5rZXlzKHNpZ25hdHVyZU91dHB1dHMpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBvdXRwdXROYW1lID0gb3V0cHV0TmFtZXNbaV07XG4gICAgICAgIGNvbnN0IHRlbnNvckluZm8gPSBzaWduYXR1cmVPdXRwdXRzW291dHB1dE5hbWVdO1xuICAgICAgICB0aGlzLnJlc291cmNlSWRUb0NhcHR1cmVkSW5wdXRbdGVuc29ySW5mby5yZXNvdXJjZUlkXSA9IG91dHB1dHNbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGluZmVyZW5jZSBmb3IgdGhlIG1vZGVsIGZvciBnaXZlbiBpbnB1dCB0ZW5zb3JzLlxuICAgKiBAcGFyYW0gaW5wdXRzIHRlbnNvciwgdGVuc29yIGFycmF5IG9yIHRlbnNvciBtYXAgb2YgdGhlIGlucHV0cyBmb3IgdGhlXG4gICAqIG1vZGVsLCBrZXllZCBieSB0aGUgaW5wdXQgbm9kZSBuYW1lcy5cbiAgICogQHBhcmFtIG91dHB1dHMgb3V0cHV0IG5vZGUgbmFtZSBmcm9tIHRoZSBUZW5zb3JGbG93IG1vZGVsLCBpZiBub1xuICAgKiBvdXRwdXRzIGFyZSBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IG91dHB1dHMgb2YgdGhlIG1vZGVsIHdvdWxkIGJlIHVzZWQuXG4gICAqIFlvdSBjYW4gaW5zcGVjdCBpbnRlcm1lZGlhdGUgbm9kZXMgb2YgdGhlIG1vZGVsIGJ5IGFkZGluZyB0aGVtIHRvIHRoZVxuICAgKiBvdXRwdXRzIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHNpbmdsZSB0ZW5zb3IgaWYgcHJvdmlkZWQgd2l0aCBhIHNpbmdsZSBvdXRwdXQgb3Igbm8gb3V0cHV0c1xuICAgKiBhcmUgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIG9ubHkgb25lIGRlZmF1bHQgb3V0cHV0LCBvdGhlcndpc2UgcmV0dXJuIGFcbiAgICogdGVuc29yIGFycmF5LiBUaGUgb3JkZXIgb2YgdGhlIHRlbnNvciBhcnJheSBpcyB0aGUgc2FtZSBhcyB0aGUgb3V0cHV0c1xuICAgKiBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHRoZSBvcmRlciBvZiBvdXRwdXROb2RlcyBhdHRyaWJ1dGUgb2YgdGhlIG1vZGVsLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgZXhlY3V0ZShpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXXxOYW1lZFRlbnNvck1hcCwgb3V0cHV0cz86IHN0cmluZ3xzdHJpbmdbXSk6XG4gICAgICBUZW5zb3J8VGVuc29yW10ge1xuICAgIGlmICh0aGlzLnJlc291cmNlSWRUb0NhcHR1cmVkSW5wdXQgPT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRSZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0KHRoaXMuZXhlY3V0ZUluaXRpYWxpemVyR3JhcGgoKSk7XG4gICAgfVxuICAgIGlucHV0cyA9IHRoaXMubm9ybWFsaXplSW5wdXRzKGlucHV0cyk7XG4gICAgb3V0cHV0cyA9IHRoaXMubm9ybWFsaXplT3V0cHV0cyhvdXRwdXRzKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmV4ZWN1dG9yLmV4ZWN1dGUoaW5wdXRzLCBvdXRwdXRzKTtcbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDEgPyByZXN1bHQgOiByZXN1bHRbMF07XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgaW5mZXJlbmNlIGZvciB0aGUgbW9kZWwgZm9yIGdpdmVuIGlucHV0IHRlbnNvcnMgaW4gYXN5bmNcbiAgICogZmFzaGlvbiwgdXNlIHRoaXMgbWV0aG9kIHdoZW4geW91ciBtb2RlbCBjb250YWlucyBjb250cm9sIGZsb3cgb3BzLlxuICAgKiBAcGFyYW0gaW5wdXRzIHRlbnNvciwgdGVuc29yIGFycmF5IG9yIHRlbnNvciBtYXAgb2YgdGhlIGlucHV0cyBmb3IgdGhlXG4gICAqIG1vZGVsLCBrZXllZCBieSB0aGUgaW5wdXQgbm9kZSBuYW1lcy5cbiAgICogQHBhcmFtIG91dHB1dHMgb3V0cHV0IG5vZGUgbmFtZSBmcm9tIHRoZSBUZW5zb3JGbG93IG1vZGVsLCBpZiBubyBvdXRwdXRzXG4gICAqIGFyZSBzcGVjaWZpZWQsIHRoZSBkZWZhdWx0IG91dHB1dHMgb2YgdGhlIG1vZGVsIHdvdWxkIGJlIHVzZWQuIFlvdSBjYW5cbiAgICogaW5zcGVjdCBpbnRlcm1lZGlhdGUgbm9kZXMgb2YgdGhlIG1vZGVsIGJ5IGFkZGluZyB0aGVtIHRvIHRoZSBvdXRwdXRzXG4gICAqIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJucyBBIFByb21pc2Ugb2Ygc2luZ2xlIHRlbnNvciBpZiBwcm92aWRlZCB3aXRoIGEgc2luZ2xlIG91dHB1dCBvclxuICAgKiBubyBvdXRwdXRzIGFyZSBwcm92aWRlZCBhbmQgdGhlcmUgaXMgb25seSBvbmUgZGVmYXVsdCBvdXRwdXQsIG90aGVyd2lzZVxuICAgKiByZXR1cm4gYSB0ZW5zb3IgbWFwLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgYXN5bmMgZXhlY3V0ZUFzeW5jKFxuICAgICAgaW5wdXRzOiBUZW5zb3J8VGVuc29yW118TmFtZWRUZW5zb3JNYXAsXG4gICAgICBvdXRwdXRzPzogc3RyaW5nfHN0cmluZ1tdKTogUHJvbWlzZTxUZW5zb3J8VGVuc29yW10+IHtcbiAgICBpZiAodGhpcy5yZXNvdXJjZUlkVG9DYXB0dXJlZElucHV0ID09IG51bGwpIHtcbiAgICAgIHRoaXMuc2V0UmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dChcbiAgICAgICAgICBhd2FpdCB0aGlzLmV4ZWN1dGVJbml0aWFsaXplckdyYXBoQXN5bmMoKSk7XG4gICAgfVxuICAgIGlucHV0cyA9IHRoaXMubm9ybWFsaXplSW5wdXRzKGlucHV0cyk7XG4gICAgb3V0cHV0cyA9IHRoaXMubm9ybWFsaXplT3V0cHV0cyhvdXRwdXRzKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dG9yLmV4ZWN1dGVBc3luYyhpbnB1dHMsIG91dHB1dHMpO1xuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID4gMSA/IHJlc3VsdCA6IHJlc3VsdFswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW50ZXJtZWRpYXRlIHRlbnNvcnMgZm9yIG1vZGVsIGRlYnVnZ2luZyBtb2RlIChmbGFnXG4gICAqIEtFRVBfSU5URVJNRURJQVRFX1RFTlNPUlMgaXMgdHJ1ZSkuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBnZXRJbnRlcm1lZGlhdGVUZW5zb3JzKCk6IE5hbWVkVGVuc29yc01hcCB7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0b3IuZ2V0SW50ZXJtZWRpYXRlVGVuc29ycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgaW50ZXJtZWRpYXRlIHRlbnNvcnMgZm9yIG1vZGVsIGRlYnVnZ2luZyBtb2RlIChmbGFnXG4gICAqIEtFRVBfSU5URVJNRURJQVRFX1RFTlNPUlMgaXMgdHJ1ZSkuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBkaXNwb3NlSW50ZXJtZWRpYXRlVGVuc29ycygpIHtcbiAgICB0aGlzLmV4ZWN1dG9yLmRpc3Bvc2VJbnRlcm1lZGlhdGVUZW5zb3JzKCk7XG4gIH1cblxuICBwcml2YXRlIGNvbnZlcnRUZW5zb3JNYXBUb1RlbnNvcnNNYXAobWFwOiBOYW1lZFRlbnNvck1hcCk6IE5hbWVkVGVuc29yc01hcCB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCkucmVkdWNlKChuZXdNYXA6IE5hbWVkVGVuc29yc01hcCwga2V5KSA9PiB7XG4gICAgICBuZXdNYXBba2V5XSA9IFttYXBba2V5XV07XG4gICAgICByZXR1cm4gbmV3TWFwO1xuICAgIH0sIHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyB0aGUgbWVtb3J5IHVzZWQgYnkgdGhlIHdlaWdodCB0ZW5zb3JzIGFuZCByZXNvdXJjZU1hbmFnZXIuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZXhlY3V0b3IuZGlzcG9zZSgpO1xuXG4gICAgaWYgKHRoaXMuaW5pdGlhbGl6ZXIpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZXIuZGlzcG9zZSgpO1xuICAgICAgaWYgKHRoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dCkge1xuICAgICAgICBkaXNwb3NlKHRoaXMucmVzb3VyY2VJZFRvQ2FwdHVyZWRJbnB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZXNvdXJjZU1hbmFnZXIuZGlzcG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBhIGdyYXBoIG1vZGVsIGdpdmVuIGEgVVJMIHRvIHRoZSBtb2RlbCBkZWZpbml0aW9uLlxuICpcbiAqIEV4YW1wbGUgb2YgbG9hZGluZyBNb2JpbGVOZXRWMiBmcm9tIGEgVVJMIGFuZCBtYWtpbmcgYSBwcmVkaWN0aW9uIHdpdGggYVxuICogemVyb3MgaW5wdXQ6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IG1vZGVsVXJsID1cbiAqICAgICdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdGZqcy1tb2RlbHMvc2F2ZWRtb2RlbC9tb2JpbGVuZXRfdjJfMS4wXzIyNC9tb2RlbC5qc29uJztcbiAqIGNvbnN0IG1vZGVsID0gYXdhaXQgdGYubG9hZEdyYXBoTW9kZWwobW9kZWxVcmwpO1xuICogY29uc3QgemVyb3MgPSB0Zi56ZXJvcyhbMSwgMjI0LCAyMjQsIDNdKTtcbiAqIG1vZGVsLnByZWRpY3QoemVyb3MpLnByaW50KCk7XG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlIG9mIGxvYWRpbmcgTW9iaWxlTmV0VjIgZnJvbSBhIFRGIEh1YiBVUkwgYW5kIG1ha2luZyBhIHByZWRpY3Rpb25cbiAqIHdpdGggYSB6ZXJvcyBpbnB1dDpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbW9kZWxVcmwgPVxuICogICAgJ2h0dHBzOi8vdGZodWIuZGV2L2dvb2dsZS9pbWFnZW5ldC9tb2JpbGVuZXRfdjJfMTQwXzIyNC9jbGFzc2lmaWNhdGlvbi8yJztcbiAqIGNvbnN0IG1vZGVsID0gYXdhaXQgdGYubG9hZEdyYXBoTW9kZWwobW9kZWxVcmwsIHtmcm9tVEZIdWI6IHRydWV9KTtcbiAqIGNvbnN0IHplcm9zID0gdGYuemVyb3MoWzEsIDIyNCwgMjI0LCAzXSk7XG4gKiBtb2RlbC5wcmVkaWN0KHplcm9zKS5wcmludCgpO1xuICogYGBgXG4gKiBAcGFyYW0gbW9kZWxVcmwgVGhlIHVybCBvciBhbiBgaW8uSU9IYW5kbGVyYCB0aGF0IGxvYWRzIHRoZSBtb2RlbC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBIVFRQIHJlcXVlc3QsIHdoaWNoIGFsbG93cyB0byBzZW5kXG4gKiAgICAgY3JlZGVudGlhbHNcbiAqICAgIGFuZCBjdXN0b20gaGVhZGVycy5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0xvYWRpbmcnfVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdyYXBoTW9kZWwoXG4gICAgbW9kZWxVcmw6IHN0cmluZ3xpby5JT0hhbmRsZXIsIG9wdGlvbnM6IGlvLkxvYWRPcHRpb25zID0ge30sXG4gICAgdGZpbyA9IGlvKTogUHJvbWlzZTxHcmFwaE1vZGVsPiB7XG4gIGlmIChtb2RlbFVybCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnbW9kZWxVcmwgaW4gbG9hZEdyYXBoTW9kZWwoKSBjYW5ub3QgYmUgbnVsbC4gUGxlYXNlIHByb3ZpZGUgYSB1cmwgJyArXG4gICAgICAgICdvciBhbiBJT0hhbmRsZXIgdGhhdCBsb2FkcyB0aGUgbW9kZWwnKTtcbiAgfVxuICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZnJvbVRGSHViICYmIHR5cGVvZiBtb2RlbFVybCA9PT0gJ3N0cmluZycpIHtcbiAgICBtb2RlbFVybCA9IGdldFRGSHViVXJsKG1vZGVsVXJsKTtcbiAgfVxuICBjb25zdCBtb2RlbCA9IG5ldyBHcmFwaE1vZGVsKG1vZGVsVXJsLCBvcHRpb25zLCB0ZmlvKTtcbiAgYXdhaXQgbW9kZWwubG9hZCgpO1xuICByZXR1cm4gbW9kZWw7XG59XG5cbi8qKlxuICogTG9hZCBhIGdyYXBoIG1vZGVsIGdpdmVuIGEgc3luY2hyb25vdXMgSU8gaGFuZGxlciB3aXRoIGEgJ2xvYWQnIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gbW9kZWxTb3VyY2UgVGhlIGBpby5JT0hhbmRsZXJTeW5jYCB0aGF0IGxvYWRzIHRoZSBtb2RlbCwgb3IgdGhlXG4gKiAgICAgYGlvLk1vZGVsQXJ0aWZhY3RzYCB0aGF0IGVuY29kZSB0aGUgbW9kZWwsIG9yIGEgdHVwbGUgb2ZcbiAqICAgICBgW2lvLk1vZGVsSlNPTiwgQXJyYXlCdWZmZXJdYCBvZiB3aGljaCB0aGUgZmlyc3QgZWxlbWVudCBlbmNvZGVzIHRoZVxuICogICAgICBtb2RlbCBhbmQgdGhlIHNlY29uZCBjb250YWlucyB0aGUgd2VpZ2h0cy5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0xvYWRpbmcnfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZEdyYXBoTW9kZWxTeW5jKFxuICAgIG1vZGVsU291cmNlOiBpby5JT0hhbmRsZXJTeW5jfFxuICAgIGlvLk1vZGVsQXJ0aWZhY3RzfFtpby5Nb2RlbEpTT04sIC8qIFdlaWdodHMgKi8gQXJyYXlCdWZmZXJdKTpcbiAgICBHcmFwaE1vZGVsPGlvLklPSGFuZGxlclN5bmM+IHtcbiAgaWYgKG1vZGVsU291cmNlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdtb2RlbFVybCBpbiBsb2FkR3JhcGhNb2RlbFN5bmMoKSBjYW5ub3QgYmUgbnVsbC4gUGxlYXNlIHByb3ZpZGUgJyArXG4gICAgICAgICdtb2RlbCBhcnRpZmFjdHMgb3IgYW4gSU9IYW5kbGVyIHRoYXQgbG9hZHMgdGhlIG1vZGVsJyk7XG4gIH1cblxuICBsZXQgaW9IYW5kbGVyOiBpby5JT0hhbmRsZXJTeW5jO1xuICBpZiAobW9kZWxTb3VyY2UgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGNvbnN0IFttb2RlbEpTT04sIHdlaWdodHNdID0gbW9kZWxTb3VyY2U7XG4gICAgaWYgKCFtb2RlbEpTT04pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxKU09OIG11c3QgYmUgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghd2VpZ2h0cyB8fCAhKHdlaWdodHMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQW4gQXJyYXlCdWZmZXIgb2Ygd2VpZ2h0cyBtdXN0IGJlIHRoZSBzZWNvbmQgZWxlbWVudCBvZicgK1xuICAgICAgICAgICcgdGhlIGFycmF5Jyk7XG4gICAgfVxuICAgIGlmICghKCdtb2RlbFRvcG9sb2d5JyBpbiBtb2RlbEpTT04pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZGVsIEpTT04gaXMgbWlzc2luZyBcXCdtb2RlbFRvcG9sb2d5XFwnJyk7XG4gICAgfVxuICAgIGlmICghKCd3ZWlnaHRzTWFuaWZlc3QnIGluIG1vZGVsSlNPTikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTW9kZWwgSlNPTiBpcyBtaXNzaW5nIFxcJ3dlaWdodHNNYW5pZmVzdFxcJycpO1xuICAgIH1cblxuICAgIGNvbnN0IHdlaWdodFNwZWNzID0gaW8uZ2V0V2VpZ2h0U3BlY3MobW9kZWxKU09OLndlaWdodHNNYW5pZmVzdCk7XG4gICAgY29uc3QgbW9kZWxBcnRpZmFjdHMgPVxuICAgICAgICBpby5nZXRNb2RlbEFydGlmYWN0c0ZvckpTT05TeW5jKG1vZGVsSlNPTiwgd2VpZ2h0U3BlY3MsIHdlaWdodHMpO1xuICAgIGlvSGFuZGxlciA9IGlvLmZyb21NZW1vcnlTeW5jKG1vZGVsQXJ0aWZhY3RzKTtcbiAgfSBlbHNlIGlmICgnbG9hZCcgaW4gbW9kZWxTb3VyY2UpIHtcbiAgICAvLyBUaGVuIG1vZGVsU291cmNlIGlzIGFscmVhZHkgYW4gSU9IYW5kbGVyU3luYy5cbiAgICBpb0hhbmRsZXIgPSBtb2RlbFNvdXJjZTtcbiAgfSBlbHNlIGlmIChcbiAgICAgICdtb2RlbFRvcG9sb2d5JyBpbiBtb2RlbFNvdXJjZSAmJiAnd2VpZ2h0U3BlY3MnIGluIG1vZGVsU291cmNlICYmXG4gICAgICAnd2VpZ2h0RGF0YScgaW4gbW9kZWxTb3VyY2UpIHtcbiAgICAvLyBtb2RlbFNvdXJjZSBpcyBvZiB0eXBlIE1vZGVsQXJ0aWZhY3RzLlxuICAgIGlvSGFuZGxlciA9IGlvLmZyb21NZW1vcnlTeW5jKG1vZGVsU291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZWwgZm9ybWF0Jyk7XG4gIH1cblxuICBjb25zdCBtb2RlbCA9IG5ldyBHcmFwaE1vZGVsKGlvSGFuZGxlcik7XG4gIG1vZGVsLmxvYWQoKTtcbiAgcmV0dXJuIG1vZGVsO1xufVxuXG5mdW5jdGlvbiBnZXRURkh1YlVybChtb2RlbFVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFtb2RlbFVybC5lbmRzV2l0aCgnLycpKSB7XG4gICAgbW9kZWxVcmwgPSAobW9kZWxVcmwpICsgJy8nO1xuICB9XG4gIHJldHVybiBgJHttb2RlbFVybH0ke0RFRkFVTFRfTU9ERUxfTkFNRX0ke1RGSFVCX1NFQVJDSF9QQVJBTX1gO1xufVxuIl19