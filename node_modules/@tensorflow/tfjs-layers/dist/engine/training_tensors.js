/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * Interfaces and methods for training models using tf.Tensor objects.
 */
import * as tfc from '@tensorflow/tfjs-core';
import { Tensor } from '@tensorflow/tfjs-core';
import { expandDims, gather, sliceAlongFirstAxis } from '../backend/tfjs_backend';
export function checkBatchSize(batchSize) {
    tfc.util.assert(batchSize > 0 && Number.isInteger(batchSize), () => `batchSize is required to be a positive integer, but got ${batchSize}`);
}
/**
 * Slice a Tensor or an Array of Tensors, by start and stop indices.
 *
 * Porting Note: The `_slice_arrays` function in PyKeras is covered by this
 *   function and `sliceArraysByIndices()` together.
 *
 * @param arrays: the input.
 * @param start: the starting index (inclusive).
 * @param stop: the stopping index (exclusive).
 * @returns The result of the slicing. If `arrays` is an `Array` of
 *   `tf.Tensor`s, the slicing will be applied to all elements of the `Array`
 *   in the same way.
 */
export function sliceArrays(arrays, start, stop) {
    if (arrays == null) {
        return [null];
    }
    else if (Array.isArray(arrays)) {
        return arrays.map(array => sliceAlongFirstAxis(array, start, stop - start));
    }
    else { // Tensor.
        return sliceAlongFirstAxis(arrays, start, stop - start);
    }
}
/**
 * Slice a Tensor or an Array of Tensors, by random-order indices.
 *
 * Porting Note: The `_slice_arrays` function in PyKeras is covered by this
 *   function and `sliceArrays()` together.
 *
 * @param arrays The input `tf.Tensor` or `Array` of `tf.Tensor`s to slice.
 *   If an `Array` of `tf.Tensor`s, all `tf.Tensor`s will be sliced in the
 *   same fashion.
 * @param indices The indices to use for slicing along the first (batch)
 *   dimension.
 * @returns Result(s) of the slicing.
 */
export function sliceArraysByIndices(arrays, indices) {
    return tfc.tidy(() => {
        if (arrays == null) {
            return null;
        }
        else if (Array.isArray(arrays)) {
            return arrays.map(array => sliceArraysByIndices(array, indices));
        }
        else {
            // TODO(cais): indices should be a pre-constructed Tensor1D to avoid
            //   tensor1d() calls.
            return gather(arrays, indices.dtype === 'int32' ? indices : tfc.cast(indices, 'int32'));
        }
    });
}
/**
 * Returns a list of batch indices (tuples of indices).
 * @param size: Integer, total size of the data to slice into batches.
 * @param batchSize: Integer, batch size.
 * @returns An Array of [batchStart, batchEnd] tuples. batchStart is
 *   inclusive; batchEnd is exclusive. I.e., each batch consists of indices x
 *   that satisfy batchStart <= x < batchEnd.
 */
export function makeBatches(size, batchSize) {
    const output = [];
    let batchStart = 0;
    let batchEnd = null;
    while (batchStart < size) {
        batchEnd = batchStart + batchSize;
        if (batchEnd >= size) {
            batchEnd = size;
        }
        output.push([batchStart, batchEnd]);
        batchStart = batchEnd;
    }
    return output;
}
/**
 * Ensure tensors all have a rank of at least 2.
 *
 * If a tensor has a rank of 1, it is dimension-expanded to rank 2.
 * If any tensor has a rank of 0 (i.e., is a scalar), an error will be thrown.
 */
export function ensureTensorsRank2OrHigher(tensors) {
    const outs = [];
    if (tensors instanceof Tensor) {
        tensors = [tensors];
    }
    // Make Tensors at least 2D.
    for (let i = 0; i < tensors.length; ++i) {
        const tensor = tensors[i];
        if (tensor.rank === 1) {
            outs.push(expandDims(tensor, 1));
        }
        else if (tensor.rank === 0) {
            throw new Error('Expected tensor to be at least 1D, but received a 0D tensor ' +
                '(scalar).');
        }
        else {
            outs.push(tensor);
        }
    }
    return outs;
}
/**
 * Compare a set of tensors with a reference (old) set, discard the ones
 * in the new set that are not present in the reference set.
 *
 * This method is used for memory clenaup during calls such as
 * LayersModel.fit().
 *
 * @param tensors New set which may contain Tensors not present in
 *   `refTensors`.
 * @param refTensors Reference Tensor set.
 */
// TODO(cais, kangyizhang): Deduplicate with tfjs-data.
export function disposeNewTensors(tensors, refTensors) {
    if (tensors == null) {
        return;
    }
    const oldTensorIds = [];
    if (refTensors instanceof Tensor) {
        oldTensorIds.push(refTensors.id);
    }
    else if (Array.isArray(refTensors)) {
        refTensors.forEach(t => oldTensorIds.push(t.id));
    }
    else if (refTensors != null) {
        // `oldTensors` is a map from string name to Tensor.
        for (const name in refTensors) {
            const oldTensor = refTensors[name];
            oldTensorIds.push(oldTensor.id);
        }
    }
    const tensorsToDispose = [];
    if (tensors instanceof Tensor) {
        if (oldTensorIds.indexOf(tensors.id) === -1) {
            tensorsToDispose.push(tensors);
        }
    }
    else if (Array.isArray(tensors)) {
        tensors.forEach(t => {
            if (oldTensorIds.indexOf(t.id) === -1) {
                tensorsToDispose.push(t);
            }
        });
    }
    else if (tensors != null) {
        // `oldTensors` is a map from string name to Tensor.
        for (const name in tensors) {
            const tensor = tensors[name];
            if (oldTensorIds.indexOf(tensor.id) === -1) {
                tensorsToDispose.push(tensor);
            }
        }
    }
    tensorsToDispose.forEach(t => {
        if (!t.isDisposed) {
            t.dispose();
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhaW5pbmdfdGVuc29ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9lbmdpbmUvdHJhaW5pbmdfdGVuc29ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsTUFBTSxFQUFXLE1BQU0sdUJBQXVCLENBQUM7QUFDdkQsT0FBTyxFQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQTZJaEYsTUFBTSxVQUFVLGNBQWMsQ0FBQyxTQUFpQjtJQUM5QyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FDWCxTQUFTLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQzVDLEdBQUcsRUFBRSxDQUFDLDJEQUNGLFNBQVMsRUFBRSxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3ZCLE1BQXVCLEVBQUUsS0FBYSxFQUFFLElBQVk7SUFDdEQsSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO1FBQ2xCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNmO1NBQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ2hDLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLG1CQUFtQixDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7S0FDN0U7U0FBTSxFQUFHLFVBQVU7UUFDbEIsT0FBTyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQztLQUN6RDtB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QyxDQUFDLEVBQUU7Z0JBQzFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMvQjtTQUNGO0tBQ0Y7SUFFRCxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDM0IsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUU7WUFDakIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ2I7SUFDSCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEludGVyZmFjZXMgYW5kIG1ldGhvZHMgZm9yIHRyYWluaW5nIG1vZGVscyB1c2luZyB0Zi5UZW5zb3Igb2JqZWN0cy5cbiAqL1xuXG5pbXBvcnQgKiBhcyB0ZmMgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7VGVuc29yLCBUZW5zb3IxRH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7ZXhwYW5kRGltcywgZ2F0aGVyLCBzbGljZUFsb25nRmlyc3RBeGlzfSBmcm9tICcuLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge0Jhc2VDYWxsYmFjaywgQ3VzdG9tQ2FsbGJhY2tBcmdzLCBNb2RlbExvZ2dpbmdWZXJib3NpdHksIFlpZWxkRXZlcnlPcHRpb25zfSBmcm9tICcuLi9iYXNlX2NhbGxiYWNrcyc7XG5pbXBvcnQge0NsYXNzV2VpZ2h0LCBDbGFzc1dlaWdodE1hcH0gZnJvbSAnLi90cmFpbmluZ191dGlscyc7XG5cbi8qKlxuICogSW50ZXJmYWNlIGNvbmZpZ3VyYXRpb24gbW9kZWwgdHJhaW5pbmcgYmFzZWQgb24gZGF0YSBhcyBgdGYuVGVuc29yYHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxGaXRBcmdzIHtcbiAgLyoqXG4gICAqIE51bWJlciBvZiBzYW1wbGVzIHBlciBncmFkaWVudCB1cGRhdGUuIElmIHVuc3BlY2lmaWVkLCBpdFxuICAgKiB3aWxsIGRlZmF1bHQgdG8gMzIuXG4gICAqL1xuICBiYXRjaFNpemU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEludGVnZXIgbnVtYmVyIG9mIHRpbWVzIHRvIGl0ZXJhdGUgb3ZlciB0aGUgdHJhaW5pbmcgZGF0YSBhcnJheXMuXG4gICAqL1xuICBlcG9jaHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFZlcmJvc2l0eSBsZXZlbC5cbiAgICpcbiAgICogRXhwZWN0ZWQgdG8gYmUgMCwgMSwgb3IgMi4gRGVmYXVsdDogMS5cbiAgICpcbiAgICogMCAtIE5vIHByaW50ZWQgbWVzc2FnZSBkdXJpbmcgZml0KCkgY2FsbC5cbiAgICogMSAtIEluIE5vZGUuanMgKHRmanMtbm9kZSksIHByaW50cyB0aGUgcHJvZ3Jlc3MgYmFyLCB0b2dldGhlciB3aXRoXG4gICAqICAgICByZWFsLXRpbWUgdXBkYXRlcyBvZiBsb3NzIGFuZCBtZXRyaWMgdmFsdWVzIGFuZCB0cmFpbmluZyBzcGVlZC5cbiAgICogICAgIEluIHRoZSBicm93c2VyOiBubyBhY3Rpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gICAqIDIgLSBOb3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgKi9cbiAgdmVyYm9zZT86IE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eTtcblxuICAvKipcbiAgICogTGlzdCBvZiBjYWxsYmFja3MgdG8gYmUgY2FsbGVkIGR1cmluZyB0cmFpbmluZy5cbiAgICogQ2FuIGhhdmUgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBjYWxsYmFja3M6XG4gICAqICAgLSBgb25UcmFpbkJlZ2luKGxvZ3MpYDogY2FsbGVkIHdoZW4gdHJhaW5pbmcgc3RhcnRzLlxuICAgKiAgIC0gYG9uVHJhaW5FbmQobG9ncylgOiBjYWxsZWQgd2hlbiB0cmFpbmluZyBlbmRzLlxuICAgKiAgIC0gYG9uRXBvY2hCZWdpbihlcG9jaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IGVwb2NoLlxuICAgKiAgIC0gYG9uRXBvY2hFbmQoZXBvY2gsIGxvZ3MpYDogY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgZXBvY2guXG4gICAqICAgLSBgb25CYXRjaEJlZ2luKGJhdGNoLCBsb2dzKWA6IGNhbGxlZCBhdCB0aGUgc3RhcnQgb2YgZXZlcnkgYmF0Y2guXG4gICAqICAgLSBgb25CYXRjaEVuZChiYXRjaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBiYXRjaC5cbiAgICogICAtIGBvbllpZWxkKGVwb2NoLCBiYXRjaCwgbG9ncylgOiBjYWxsZWQgZXZlcnkgYHlpZWxkRXZlcnlgIG1pbGxpc2Vjb25kc1xuICAgKiAgICAgIHdpdGggdGhlIGN1cnJlbnQgZXBvY2gsIGJhdGNoIGFuZCBsb2dzLiBUaGUgbG9ncyBhcmUgdGhlIHNhbWVcbiAgICogICAgICBhcyBpbiBgb25CYXRjaEVuZCgpYC4gTm90ZSB0aGF0IGBvbllpZWxkYCBjYW4gc2tpcCBiYXRjaGVzIG9yXG4gICAqICAgICAgZXBvY2hzLiBTZWUgYWxzbyBkb2NzIGZvciBgeWllbGRFdmVyeWAgYmVsb3cuXG4gICAqL1xuICBjYWxsYmFja3M/OiBCYXNlQ2FsbGJhY2tbXXxDdXN0b21DYWxsYmFja0FyZ3N8Q3VzdG9tQ2FsbGJhY2tBcmdzW107XG5cbiAgLyoqXG4gICAqIEZsb2F0IGJldHdlZW4gMCBhbmQgMTogZnJhY3Rpb24gb2YgdGhlIHRyYWluaW5nIGRhdGFcbiAgICogdG8gYmUgdXNlZCBhcyB2YWxpZGF0aW9uIGRhdGEuIFRoZSBtb2RlbCB3aWxsIHNldCBhcGFydCB0aGlzIGZyYWN0aW9uIG9mXG4gICAqIHRoZSB0cmFpbmluZyBkYXRhLCB3aWxsIG5vdCB0cmFpbiBvbiBpdCwgYW5kIHdpbGwgZXZhbHVhdGUgdGhlIGxvc3MgYW5kXG4gICAqIGFueSBtb2RlbCBtZXRyaWNzIG9uIHRoaXMgZGF0YSBhdCB0aGUgZW5kIG9mIGVhY2ggZXBvY2guXG4gICAqIFRoZSB2YWxpZGF0aW9uIGRhdGEgaXMgc2VsZWN0ZWQgZnJvbSB0aGUgbGFzdCBzYW1wbGVzIGluIHRoZSBgeGAgYW5kIGB5YFxuICAgKiBkYXRhIHByb3ZpZGVkLCBiZWZvcmUgc2h1ZmZsaW5nLlxuICAgKi9cbiAgdmFsaWRhdGlvblNwbGl0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEYXRhIG9uIHdoaWNoIHRvIGV2YWx1YXRlIHRoZSBsb3NzIGFuZCBhbnkgbW9kZWxcbiAgICogbWV0cmljcyBhdCB0aGUgZW5kIG9mIGVhY2ggZXBvY2guIFRoZSBtb2RlbCB3aWxsIG5vdCBiZSB0cmFpbmVkIG9uIHRoaXNcbiAgICogZGF0YS4gVGhpcyBjb3VsZCBiZSBhIHR1cGxlIFt4VmFsLCB5VmFsXSBvciBhIHR1cGxlIFt4VmFsLCB5VmFsLFxuICAgKiB2YWxTYW1wbGVXZWlnaHRzXS4gVGhlIG1vZGVsIHdpbGwgbm90IGJlIHRyYWluZWQgb24gdGhpcyBkYXRhLlxuICAgKiBgdmFsaWRhdGlvbkRhdGFgIHdpbGwgb3ZlcnJpZGUgYHZhbGlkYXRpb25TcGxpdGAuXG4gICAqL1xuICB2YWxpZGF0aW9uRGF0YT86IFtcbiAgICBUZW5zb3J8VGVuc29yW10sIFRlbnNvcnxUZW5zb3JbXVxuICBdfFtUZW5zb3IgfCBUZW5zb3JbXSwgVGVuc29yfFRlbnNvcltdLCBUZW5zb3J8VGVuc29yW11dO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHNodWZmbGUgdGhlIHRyYWluaW5nIGRhdGEgYmVmb3JlIGVhY2ggZXBvY2guIEhhc1xuICAgKiBubyBlZmZlY3Qgd2hlbiBgc3RlcHNQZXJFcG9jaGAgaXMgbm90IGBudWxsYC5cbiAgICovXG4gIHNodWZmbGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBvYmplY3QgbWFwcGluZyBjbGFzcyBpbmRpY2VzIChpbnRlZ2VycykgdG9cbiAgICogYSB3ZWlnaHQgKGZsb2F0KSB0byBhcHBseSB0byB0aGUgbW9kZWwncyBsb3NzIGZvciB0aGUgc2FtcGxlcyBmcm9tIHRoaXNcbiAgICogY2xhc3MgZHVyaW5nIHRyYWluaW5nLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gdGVsbCB0aGUgbW9kZWwgdG8gXCJwYXkgbW9yZVxuICAgKiBhdHRlbnRpb25cIiB0byBzYW1wbGVzIGZyb20gYW4gdW5kZXItcmVwcmVzZW50ZWQgY2xhc3MuXG4gICAqXG4gICAqIElmIHRoZSBtb2RlbCBoYXMgbXVsdGlwbGUgb3V0cHV0cywgYSBjbGFzcyB3ZWlnaHQgY2FuIGJlIHNwZWNpZmllZCBmb3JcbiAgICogZWFjaCBvZiB0aGUgb3V0cHV0cyBieSBzZXR0aW5nIHRoaXMgZmllbGQgYW4gYXJyYXkgb2Ygd2VpZ2h0IG9iamVjdFxuICAgKiBvciBhbiBvYmplY3QgdGhhdCBtYXBzIG1vZGVsIG91dHB1dCBuYW1lcyAoZS5nLiwgYG1vZGVsLm91dHB1dE5hbWVzWzBdYClcbiAgICogdG8gd2VpZ2h0IG9iamVjdHMuXG4gICAqL1xuICBjbGFzc1dlaWdodD86IENsYXNzV2VpZ2h0fENsYXNzV2VpZ2h0W118Q2xhc3NXZWlnaHRNYXA7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIGFycmF5IG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4LCBjb250YWluaW5nXG4gICAqIHdlaWdodHMgdG8gYXBwbHkgdG8gdGhlIG1vZGVsJ3MgbG9zcyBmb3IgZWFjaCBzYW1wbGUuIEluIHRoZSBjYXNlIG9mXG4gICAqIHRlbXBvcmFsIGRhdGEsIHlvdSBjYW4gcGFzcyBhIDJEIGFycmF5IHdpdGggc2hhcGUgKHNhbXBsZXMsXG4gICAqIHNlcXVlbmNlTGVuZ3RoKSwgdG8gYXBwbHkgYSBkaWZmZXJlbnQgd2VpZ2h0IHRvIGV2ZXJ5IHRpbWVzdGVwIG9mIGV2ZXJ5XG4gICAqIHNhbXBsZS4gSW4gdGhpcyBjYXNlIHlvdSBzaG91bGQgbWFrZSBzdXJlIHRvIHNwZWNpZnlcbiAgICogc2FtcGxlV2VpZ2h0TW9kZT1cInRlbXBvcmFsXCIgaW4gY29tcGlsZSgpLlxuICAgKi9cbiAgc2FtcGxlV2VpZ2h0PzogVGVuc29yO1xuXG4gIC8qKlxuICAgKiBFcG9jaCBhdCB3aGljaCB0byBzdGFydCB0cmFpbmluZyAodXNlZnVsIGZvciByZXN1bWluZyBhIHByZXZpb3VzIHRyYWluaW5nXG4gICAqIHJ1bikuIFdoZW4gdGhpcyBpcyB1c2VkLCBgZXBvY2hzYCBpcyB0aGUgaW5kZXggb2YgdGhlIFwiZmluYWwgZXBvY2hcIi5cbiAgICogVGhlIG1vZGVsIGlzIG5vdCB0cmFpbmVkIGZvciBhIG51bWJlciBvZiBpdGVyYXRpb25zIGdpdmVuIGJ5IGBlcG9jaHNgLFxuICAgKiBidXQgbWVyZWx5IHVudGlsIHRoZSBlcG9jaCBvZiBpbmRleCBgZXBvY2hzYCBpcyByZWFjaGVkLlxuICAgKi9cbiAgaW5pdGlhbEVwb2NoPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBudW1iZXIgb2Ygc3RlcHMgKGJhdGNoZXMgb2Ygc2FtcGxlcykgYmVmb3JlXG4gICAqIGRlY2xhcmluZyBvbmUgZXBvY2ggZmluaXNoZWQgYW5kIHN0YXJ0aW5nIHRoZSBuZXh0IGVwb2NoLiBXaGVuIHRyYWluaW5nXG4gICAqIHdpdGggSW5wdXQgVGVuc29ycyBzdWNoIGFzIFRlbnNvckZsb3cgZGF0YSB0ZW5zb3JzLCB0aGUgZGVmYXVsdCBgbnVsbGAgaXNcbiAgICogZXF1YWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgc2FtcGxlcyBpbiB5b3VyIGRhdGFzZXQgZGl2aWRlZCBieSB0aGVcbiAgICogYmF0Y2ggc2l6ZSwgb3IgMSBpZiB0aGF0IGNhbm5vdCBiZSBkZXRlcm1pbmVkLlxuICAgKi9cbiAgc3RlcHNQZXJFcG9jaD86IG51bWJlcjtcblxuICAvKipcbiAgICogT25seSByZWxldmFudCBpZiBgc3RlcHNQZXJFcG9jaGAgaXMgc3BlY2lmaWVkLiBUb3RhbCBudW1iZXIgb2Ygc3RlcHNcbiAgICogKGJhdGNoZXMgb2Ygc2FtcGxlcykgdG8gdmFsaWRhdGUgYmVmb3JlIHN0b3BwaW5nLlxuICAgKi9cbiAgdmFsaWRhdGlvblN0ZXBzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIHRoZSBmcmVxdWVuY3kgb2YgeWllbGRpbmcgdGhlIG1haW4gdGhyZWFkIHRvIG90aGVyIHRhc2tzLlxuICAgKlxuICAgKiBJbiB0aGUgYnJvd3NlciBlbnZpcm9ubWVudCwgeWllbGRpbmcgdGhlIG1haW4gdGhyZWFkIGNhbiBpbXByb3ZlIHRoZVxuICAgKiByZXNwb25zaXZlbmVzcyBvZiB0aGUgcGFnZSBkdXJpbmcgdHJhaW5pbmcuIEluIHRoZSBOb2RlLmpzIGVudmlyb25tZW50LFxuICAgKiBpdCBjYW4gZW5zdXJlIHRhc2tzIHF1ZXVlZCBpbiB0aGUgZXZlbnQgbG9vcCBjYW4gYmUgaGFuZGxlZCBpbiBhIHRpbWVseVxuICAgKiBtYW5uZXIuXG4gICAqXG4gICAqIFRoZSB2YWx1ZSBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqICAgLSBgJ2F1dG8nYDogVGhlIHlpZWxkaW5nIGhhcHBlbnMgYXQgYSBjZXJ0YWluIGZyYW1lIHJhdGUgKGN1cnJlbnRseSBzZXRcbiAgICogICAgICAgICAgICAgICBhdCAxMjVtcykuIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gICAqICAgLSBgJ2JhdGNoJ2A6IHlpZWxkIGV2ZXJ5IGJhdGNoLlxuICAgKiAgIC0gYCdlcG9jaCdgOiB5aWVsZCBldmVyeSBlcG9jaC5cbiAgICogICAtIGFueSBgbnVtYmVyYDogeWllbGQgZXZlcnkgYG51bWJlcmAgbWlsbGlzZWNvbmRzLlxuICAgKiAgIC0gYCduZXZlcidgOiBuZXZlciB5aWVsZC4gKHlpZWxkaW5nIGNhbiBzdGlsbCBoYXBwZW4gdGhyb3VnaCBgYXdhaXRcbiAgICogICAgICBuZXh0RnJhbWUoKWAgY2FsbHMgaW4gY3VzdG9tIGNhbGxiYWNrcy4pXG4gICAqL1xuICB5aWVsZEV2ZXJ5PzogWWllbGRFdmVyeU9wdGlvbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0JhdGNoU2l6ZShiYXRjaFNpemU6IG51bWJlcikge1xuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICBiYXRjaFNpemUgPiAwICYmIE51bWJlci5pc0ludGVnZXIoYmF0Y2hTaXplKSxcbiAgICAgICgpID0+IGBiYXRjaFNpemUgaXMgcmVxdWlyZWQgdG8gYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBidXQgZ290ICR7XG4gICAgICAgICAgYmF0Y2hTaXplfWApO1xufVxuXG4vKipcbiAqIFNsaWNlIGEgVGVuc29yIG9yIGFuIEFycmF5IG9mIFRlbnNvcnMsIGJ5IHN0YXJ0IGFuZCBzdG9wIGluZGljZXMuXG4gKlxuICogUG9ydGluZyBOb3RlOiBUaGUgYF9zbGljZV9hcnJheXNgIGZ1bmN0aW9uIGluIFB5S2VyYXMgaXMgY292ZXJlZCBieSB0aGlzXG4gKiAgIGZ1bmN0aW9uIGFuZCBgc2xpY2VBcnJheXNCeUluZGljZXMoKWAgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIGFycmF5czogdGhlIGlucHV0LlxuICogQHBhcmFtIHN0YXJ0OiB0aGUgc3RhcnRpbmcgaW5kZXggKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0gc3RvcDogdGhlIHN0b3BwaW5nIGluZGV4IChleGNsdXNpdmUpLlxuICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiB0aGUgc2xpY2luZy4gSWYgYGFycmF5c2AgaXMgYW4gYEFycmF5YCBvZlxuICogICBgdGYuVGVuc29yYHMsIHRoZSBzbGljaW5nIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgZWxlbWVudHMgb2YgdGhlIGBBcnJheWBcbiAqICAgaW4gdGhlIHNhbWUgd2F5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VBcnJheXMoXG4gICAgYXJyYXlzOiBUZW5zb3J8VGVuc29yW10sIHN0YXJ0OiBudW1iZXIsIHN0b3A6IG51bWJlcik6IFRlbnNvcnxUZW5zb3JbXSB7XG4gIGlmIChhcnJheXMgPT0gbnVsbCkge1xuICAgIHJldHVybiBbbnVsbF07XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheXMpKSB7XG4gICAgcmV0dXJuIGFycmF5cy5tYXAoYXJyYXkgPT4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhcnJheSwgc3RhcnQsIHN0b3AgLSBzdGFydCkpO1xuICB9IGVsc2UgeyAgLy8gVGVuc29yLlxuICAgIHJldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGFycmF5cywgc3RhcnQsIHN0b3AgLSBzdGFydCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTbGljZSBhIFRlbnNvciBvciBhbiBBcnJheSBvZiBUZW5zb3JzLCBieSByYW5kb20tb3JkZXIgaW5kaWNlcy5cbiAqXG4gKiBQb3J0aW5nIE5vdGU6IFRoZSBgX3NsaWNlX2FycmF5c2AgZnVuY3Rpb24gaW4gUHlLZXJhcyBpcyBjb3ZlcmVkIGJ5IHRoaXNcbiAqICAgZnVuY3Rpb24gYW5kIGBzbGljZUFycmF5cygpYCB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0gYXJyYXlzIFRoZSBpbnB1dCBgdGYuVGVuc29yYCBvciBgQXJyYXlgIG9mIGB0Zi5UZW5zb3JgcyB0byBzbGljZS5cbiAqICAgSWYgYW4gYEFycmF5YCBvZiBgdGYuVGVuc29yYHMsIGFsbCBgdGYuVGVuc29yYHMgd2lsbCBiZSBzbGljZWQgaW4gdGhlXG4gKiAgIHNhbWUgZmFzaGlvbi5cbiAqIEBwYXJhbSBpbmRpY2VzIFRoZSBpbmRpY2VzIHRvIHVzZSBmb3Igc2xpY2luZyBhbG9uZyB0aGUgZmlyc3QgKGJhdGNoKVxuICogICBkaW1lbnNpb24uXG4gKiBAcmV0dXJucyBSZXN1bHQocykgb2YgdGhlIHNsaWNpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGljZUFycmF5c0J5SW5kaWNlcyhcbiAgICBhcnJheXM6IFRlbnNvcnxUZW5zb3JbXSwgaW5kaWNlczogVGVuc29yMUQpOiBUZW5zb3J8VGVuc29yW10ge1xuICByZXR1cm4gdGZjLnRpZHkoKCkgPT4ge1xuICAgIGlmIChhcnJheXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5cykpIHtcbiAgICAgIHJldHVybiBhcnJheXMubWFwKFxuICAgICAgICAgIGFycmF5ID0+IChzbGljZUFycmF5c0J5SW5kaWNlcyhhcnJheSwgaW5kaWNlcykgYXMgVGVuc29yKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE8oY2Fpcyk6IGluZGljZXMgc2hvdWxkIGJlIGEgcHJlLWNvbnN0cnVjdGVkIFRlbnNvcjFEIHRvIGF2b2lkXG4gICAgICAvLyAgIHRlbnNvcjFkKCkgY2FsbHMuXG4gICAgICByZXR1cm4gZ2F0aGVyKFxuICAgICAgICAgIGFycmF5cyxcbiAgICAgICAgICBpbmRpY2VzLmR0eXBlID09PSAnaW50MzInID8gaW5kaWNlcyA6IHRmYy5jYXN0KGluZGljZXMsICdpbnQzMicpKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBsaXN0IG9mIGJhdGNoIGluZGljZXMgKHR1cGxlcyBvZiBpbmRpY2VzKS5cbiAqIEBwYXJhbSBzaXplOiBJbnRlZ2VyLCB0b3RhbCBzaXplIG9mIHRoZSBkYXRhIHRvIHNsaWNlIGludG8gYmF0Y2hlcy5cbiAqIEBwYXJhbSBiYXRjaFNpemU6IEludGVnZXIsIGJhdGNoIHNpemUuXG4gKiBAcmV0dXJucyBBbiBBcnJheSBvZiBbYmF0Y2hTdGFydCwgYmF0Y2hFbmRdIHR1cGxlcy4gYmF0Y2hTdGFydCBpc1xuICogICBpbmNsdXNpdmU7IGJhdGNoRW5kIGlzIGV4Y2x1c2l2ZS4gSS5lLiwgZWFjaCBiYXRjaCBjb25zaXN0cyBvZiBpbmRpY2VzIHhcbiAqICAgdGhhdCBzYXRpc2Z5IGJhdGNoU3RhcnQgPD0geCA8IGJhdGNoRW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUJhdGNoZXMoXG4gICAgc2l6ZTogbnVtYmVyLCBiYXRjaFNpemU6IG51bWJlcik6IEFycmF5PFtudW1iZXIsIG51bWJlcl0+IHtcbiAgY29uc3Qgb3V0cHV0OiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPiA9IFtdO1xuICBsZXQgYmF0Y2hTdGFydCA9IDA7XG4gIGxldCBiYXRjaEVuZDogbnVtYmVyID0gbnVsbDtcbiAgd2hpbGUgKGJhdGNoU3RhcnQgPCBzaXplKSB7XG4gICAgYmF0Y2hFbmQgPSBiYXRjaFN0YXJ0ICsgYmF0Y2hTaXplO1xuICAgIGlmIChiYXRjaEVuZCA+PSBzaXplKSB7XG4gICAgICBiYXRjaEVuZCA9IHNpemU7XG4gICAgfVxuICAgIG91dHB1dC5wdXNoKFtiYXRjaFN0YXJ0LCBiYXRjaEVuZF0pO1xuICAgIGJhdGNoU3RhcnQgPSBiYXRjaEVuZDtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIEVuc3VyZSB0ZW5zb3JzIGFsbCBoYXZlIGEgcmFuayBvZiBhdCBsZWFzdCAyLlxuICpcbiAqIElmIGEgdGVuc29yIGhhcyBhIHJhbmsgb2YgMSwgaXQgaXMgZGltZW5zaW9uLWV4cGFuZGVkIHRvIHJhbmsgMi5cbiAqIElmIGFueSB0ZW5zb3IgaGFzIGEgcmFuayBvZiAwIChpLmUuLCBpcyBhIHNjYWxhciksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlVGVuc29yc1JhbmsyT3JIaWdoZXIodGVuc29yczogVGVuc29yfFRlbnNvcltdKTogVGVuc29yW10ge1xuICBjb25zdCBvdXRzOiBUZW5zb3JbXSA9IFtdO1xuICBpZiAodGVuc29ycyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgIHRlbnNvcnMgPSBbdGVuc29yc107XG4gIH1cblxuICAvLyBNYWtlIFRlbnNvcnMgYXQgbGVhc3QgMkQuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHRlbnNvciA9IHRlbnNvcnNbaV07XG4gICAgaWYgKHRlbnNvci5yYW5rID09PSAxKSB7XG4gICAgICBvdXRzLnB1c2goZXhwYW5kRGltcyh0ZW5zb3IsIDEpKTtcbiAgICB9IGVsc2UgaWYgKHRlbnNvci5yYW5rID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0V4cGVjdGVkIHRlbnNvciB0byBiZSBhdCBsZWFzdCAxRCwgYnV0IHJlY2VpdmVkIGEgMEQgdGVuc29yICcgK1xuICAgICAgICAgICcoc2NhbGFyKS4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cy5wdXNoKHRlbnNvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRzO1xufVxuXG4vKipcbiAqIENvbXBhcmUgYSBzZXQgb2YgdGVuc29ycyB3aXRoIGEgcmVmZXJlbmNlIChvbGQpIHNldCwgZGlzY2FyZCB0aGUgb25lc1xuICogaW4gdGhlIG5ldyBzZXQgdGhhdCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIHJlZmVyZW5jZSBzZXQuXG4gKlxuICogVGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgbWVtb3J5IGNsZW5hdXAgZHVyaW5nIGNhbGxzIHN1Y2ggYXNcbiAqIExheWVyc01vZGVsLmZpdCgpLlxuICpcbiAqIEBwYXJhbSB0ZW5zb3JzIE5ldyBzZXQgd2hpY2ggbWF5IGNvbnRhaW4gVGVuc29ycyBub3QgcHJlc2VudCBpblxuICogICBgcmVmVGVuc29yc2AuXG4gKiBAcGFyYW0gcmVmVGVuc29ycyBSZWZlcmVuY2UgVGVuc29yIHNldC5cbiAqL1xuLy8gVE9ETyhjYWlzLCBrYW5neWl6aGFuZyk6IERlZHVwbGljYXRlIHdpdGggdGZqcy1kYXRhLlxuZXhwb3J0IGZ1bmN0aW9uIGRpc3Bvc2VOZXdUZW5zb3JzKFxuICAgIHRlbnNvcnM6IFRlbnNvcnxUZW5zb3JbXXx7W2lucHV0TmFtZTogc3RyaW5nXTogVGVuc29yfSxcbiAgICByZWZUZW5zb3JzOiBUZW5zb3J8VGVuc29yW118e1tpbnB1dE5hbWU6IHN0cmluZ106IFRlbnNvcn0pOiB2b2lkIHtcbiAgaWYgKHRlbnNvcnMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvbGRUZW5zb3JJZHM6IG51bWJlcltdID0gW107XG4gIGlmIChyZWZUZW5zb3JzIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgb2xkVGVuc29ySWRzLnB1c2gocmVmVGVuc29ycy5pZCk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZWZUZW5zb3JzKSkge1xuICAgIHJlZlRlbnNvcnMuZm9yRWFjaCh0ID0+IG9sZFRlbnNvcklkcy5wdXNoKHQuaWQpKTtcbiAgfSBlbHNlIGlmIChyZWZUZW5zb3JzICE9IG51bGwpIHtcbiAgICAvLyBgb2xkVGVuc29yc2AgaXMgYSBtYXAgZnJvbSBzdHJpbmcgbmFtZSB0byBUZW5zb3IuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHJlZlRlbnNvcnMpIHtcbiAgICAgIGNvbnN0IG9sZFRlbnNvciA9IHJlZlRlbnNvcnNbbmFtZV07XG4gICAgICBvbGRUZW5zb3JJZHMucHVzaChvbGRUZW5zb3IuaWQpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHRlbnNvcnNUb0Rpc3Bvc2U6IFRlbnNvcltdID0gW107XG4gIGlmICh0ZW5zb3JzIGluc3RhbmNlb2YgVGVuc29yKSB7XG4gICAgaWYgKG9sZFRlbnNvcklkcy5pbmRleE9mKHRlbnNvcnMuaWQpID09PSAtMSkge1xuICAgICAgdGVuc29yc1RvRGlzcG9zZS5wdXNoKHRlbnNvcnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRlbnNvcnMpKSB7XG4gICAgdGVuc29ycy5mb3JFYWNoKHQgPT4ge1xuICAgICAgaWYgKG9sZFRlbnNvcklkcy5pbmRleE9mKHQuaWQpID09PSAtMSkge1xuICAgICAgICB0ZW5zb3JzVG9EaXNwb3NlLnB1c2godCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGVuc29ycyAhPSBudWxsKSB7XG4gICAgLy8gYG9sZFRlbnNvcnNgIGlzIGEgbWFwIGZyb20gc3RyaW5nIG5hbWUgdG8gVGVuc29yLlxuICAgIGZvciAoY29uc3QgbmFtZSBpbiB0ZW5zb3JzKSB7XG4gICAgICBjb25zdCB0ZW5zb3IgPSB0ZW5zb3JzW25hbWVdO1xuICAgICAgaWYgKG9sZFRlbnNvcklkcy5pbmRleE9mKHRlbnNvci5pZCkgPT09IC0xKSB7XG4gICAgICAgIHRlbnNvcnNUb0Rpc3Bvc2UucHVzaCh0ZW5zb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRlbnNvcnNUb0Rpc3Bvc2UuZm9yRWFjaCh0ID0+IHtcbiAgICBpZiAoIXQuaXNEaXNwb3NlZCkge1xuICAgICAgdC5kaXNwb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbiJdfQ==