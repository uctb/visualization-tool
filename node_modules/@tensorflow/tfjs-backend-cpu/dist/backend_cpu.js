/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { backend_util, buffer, DataStorage, engine, env, kernel_impls, KernelBackend, util } from '@tensorflow/tfjs-core';
const whereImpl = kernel_impls.whereImpl;
import { assertNotComplex } from './cpu_util';
export class MathBackendCPU extends KernelBackend {
    constructor() {
        super();
        this.blockSize = 48;
        this.firstUse = true;
        this.data = new DataStorage(this, engine());
    }
    nextDataId() {
        return MathBackendCPU.nextDataId++;
    }
    write(values, shape, dtype) {
        if (this.firstUse) {
            this.firstUse = false;
            if (env().get('IS_NODE')) {
                backend_util.warn('\n============================\n' +
                    'Hi, looks like you are running TensorFlow.js in ' +
                    'Node.js. To speed things up dramatically, install our node ' +
                    'backend, visit https://github.com/tensorflow/tfjs-node for more details. ' +
                    '\n============================');
            }
        }
        const dataId = { id: this.nextDataId() };
        this.data.set(dataId, { values, dtype, refCount: 1 });
        return dataId;
    }
    /**
     * Create a data bucket in cpu backend.
     * @param shape Shape of the `TensorInfo`.
     * @param dtype DType of the `TensorInfo`.
     * @param values The value of the `TensorInfo` stored as a flattened array.
     */
    makeTensorInfo(shape, dtype, values) {
        let outId;
        if (dtype === 'string' && values != null && values.length > 0 &&
            util.isString(values[0])) {
            const encodedValues = values.map(d => util.encodeString(d));
            outId = this.write(encodedValues, shape, dtype);
        }
        else {
            outId = this.write(values, shape, dtype);
        }
        return { dataId: outId, shape, dtype };
    }
    /** Return refCount of a `TensorData`. */
    refCount(dataId) {
        if (this.data.has(dataId)) {
            const tensorData = this.data.get(dataId);
            return tensorData.refCount;
        }
        return 0;
    }
    /** Increase refCount of a `TensorData`. */
    incRef(dataId) {
        const tensorData = this.data.get(dataId);
        tensorData.refCount++;
    }
    /** Decrease refCount of a `TensorData`. */
    decRef(dataId) {
        if (this.data.has(dataId)) {
            const tensorData = this.data.get(dataId);
            tensorData.refCount--;
        }
    }
    move(dataId, values, shape, dtype, refCount) {
        this.data.set(dataId, { values, dtype, refCount });
    }
    numDataIds() {
        return this.data.numDataIds();
    }
    async read(dataId) {
        return this.readSync(dataId);
    }
    readSync(dataId) {
        const { dtype, complexTensorInfos } = this.data.get(dataId);
        if (dtype === 'complex64') {
            const realValues = this.readSync(complexTensorInfos.real.dataId);
            const imagValues = this.readSync(complexTensorInfos.imag.dataId);
            return backend_util.mergeRealAndImagArrays(realValues, imagValues);
        }
        return util.convertBackendValuesAndArrayBuffer(this.data.get(dataId).values, dtype);
    }
    bufferSync(t) {
        const data = this.readSync(t.dataId);
        if (t.dtype === 'string') {
            try {
                // Decode the bytes into string.
                const strings = data.map(d => util.decodeString(d));
                return buffer(t.shape, t.dtype, strings);
            }
            catch (_a) {
                throw new Error('Failed to decode encoded string bytes into utf-8');
            }
        }
        return buffer(t.shape, t.dtype, data);
    }
    makeOutput(values, shape, dtype) {
        return engine().makeTensorFromTensorInfo(this.makeTensorInfo(shape, dtype, values), this);
    }
    /**
     * Dispose the memory if the dataId has 0 refCount. Return true if the memory
     * is released or memory is not managed in this backend, false if memory is
     * not cleared.
     * @param dataId
     * @oaram force Optional, remove the data regardless of refCount
     */
    disposeData(dataId, force = false) {
        if (this.data.has(dataId)) {
            this.data.get(dataId).refCount--;
            if (!force && this.data.get(dataId).refCount > 0) {
                return false;
            }
            const { complexTensorInfos } = this.data.get(dataId);
            if (complexTensorInfos != null) {
                this.disposeData(complexTensorInfos.real.dataId, true);
                this.disposeData(complexTensorInfos.imag.dataId, true);
            }
            this.data.delete(dataId);
        }
        return true;
    }
    disposeIntermediateTensorInfo(tensorInfo) {
        this.disposeData(tensorInfo.dataId);
    }
    async time(f) {
        const start = util.now();
        f();
        const kernelMs = util.now() - start;
        return { kernelMs };
    }
    memory() {
        return {
            // Unreliable due to automatic gc. The numbers above are cumulative.
            unreliable: true,
            reasons: ['The reported memory is an upper bound. Due to automatic garbage ' +
                    'collection, the true allocated memory may be less.']
        };
    }
    where(condition) {
        assertNotComplex([condition], 'where');
        const condVals = this.readSync(condition.dataId);
        return whereImpl(condition.shape, condVals);
    }
    dispose() { }
    floatPrecision() {
        return 32;
    }
    /** Returns the smallest representable number.  */
    epsilon() {
        return super.epsilon();
    }
}
MathBackendCPU.nextDataId = 0;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZF9jcHUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWJhY2tlbmQtY3B1L3NyYy9iYWNrZW5kX2NwdS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsWUFBWSxFQUFxQixNQUFNLEVBQUUsV0FBVyxFQUFZLE1BQU0sRUFBRSxHQUFHLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBMEUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFN04sTUFBTSxTQUFTLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQztBQUN6QyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFnQjVDLE1BQU0sT0FBTyxjQUFlLFNBQVEsYUFBYTtJQVUvQztRQUNFLEtBQUssRUFBRSxDQUFDO1FBVkgsY0FBUyxHQUFHLEVBQUUsQ0FBQztRQUdkLGFBQVEsR0FBRyxJQUFJLENBQUM7UUFRdEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLFdBQVcsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUM5QyxDQUFDO0lBUE8sVUFBVTtRQUNoQixPQUFPLGNBQWMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUNyQyxDQUFDO0lBT1EsS0FBSyxDQUNWLE1BQWtDLEVBQUUsS0FBZSxFQUNuRCxLQUFlO1FBQ2pCLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztZQUN0QixJQUFJLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDeEIsWUFBWSxDQUFDLElBQUksQ0FDYixrQ0FBa0M7b0JBQ2xDLGtEQUFrRDtvQkFDbEQsNkRBQTZEO29CQUM3RCwyRUFBMkU7b0JBQzNFLGdDQUFnQyxDQUFDLENBQUM7YUFDdkM7U0FDRjtRQUNELE1BQU0sTUFBTSxHQUFH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QUFHLEtBQUssQ0FBQztRQUNwQyxPQUFPLEVBQUMsUUFBUSxFQUFDLENBQUM7SUFDcEIsQ0FBQztJQUVRLE1BQU07UUFDYixPQUFPO1lBQ0wsb0VBQW9FO1lBQ3BFLFVBQVUsRUFBRSxJQUFJO1lBQ2hCLE9BQU8sRUFDSCxDQUFDLGtFQUFrRTtvQkFDbEUsb0RBQW9ELENBQUM7U0FDM0QsQ0FBQztJQUNKLENBQUM7SUFFRCxLQUFLLENBQUMsU0FBaUI7UUFDckIsZ0JBQWdCLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUV2QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQWUsQ0FBQztRQUMvRCxPQUFPLFNBQVMsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzlDLENBQUM7SUFFUSxPQUFPLEtBQUksQ0FBQztJQUVaLGNBQWM7UUFDckIsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsa0RBQWtEO0lBQ3pDLE9BQU87UUFDZCxPQUFPLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUN6QixDQUFDOztBQTlMYyx5QkFBVSxHQUFHLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kX3V0aWwsIEJhY2tlbmRUaW1pbmdJbmZvLCBidWZmZXIsIERhdGFTdG9yYWdlLCBEYXRhVHlwZSwgZW5naW5lLCBlbnYsIGtlcm5lbF9pbXBscywgS2VybmVsQmFja2VuZCwgUmFuaywgU2hhcGVNYXAsIFRlbnNvciwgVGVuc29yMkQsIFRlbnNvckJ1ZmZlciwgVGVuc29ySW5mbywgVHlwZWRBcnJheSwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuY29uc3Qgd2hlcmVJbXBsID0ga2VybmVsX2ltcGxzLndoZXJlSW1wbDtcbmltcG9ydCB7YXNzZXJ0Tm90Q29tcGxleH0gZnJvbSAnLi9jcHVfdXRpbCc7XG5cbmludGVyZmFjZSBEYXRhSWQge31cblxuZXhwb3J0IGludGVyZmFjZSBUZW5zb3JEYXRhPEQgZXh0ZW5kcyBEYXRhVHlwZT4ge1xuICB2YWx1ZXM/OiBiYWNrZW5kX3V0aWwuQmFja2VuZFZhbHVlcztcbiAgZHR5cGU6IEQ7XG4gIC8vIEZvciBjb21wbGV4IG51bWJlcnMsIHRoZSByZWFsIGFuZCBpbWFnaW5hcnkgcGFydHMgYXJlIHN0b3JlZCBhcyB0aGVpciBvd25cbiAgLy8gaW5kaXZpZHVhbCB0ZW5zb3JzLCB3aXRoIGEgcGFyZW50IGpvaW5pbmcgdGhlIHR3byB3aXRoIHRoZVxuICAvLyBjb21wbGV4VGVuc29ySW5mb3MgZmllbGQuXG4gIGNvbXBsZXhUZW5zb3JJbmZvcz86IHtyZWFsOiBUZW5zb3JJbmZvLCBpbWFnOiBUZW5zb3JJbmZvfTtcbiAgLy8gcmVmQ291bnQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGVuc29ycyByZWZlcmVuY2UgaXQuIFVzZWQgZm9yIG1lbW9yeVxuICAvLyBtYW5hZ2VtZW50LlxuICByZWZDb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgTWF0aEJhY2tlbmRDUFUgZXh0ZW5kcyBLZXJuZWxCYWNrZW5kIHtcbiAgcHVibGljIGJsb2NrU2l6ZSA9IDQ4O1xuXG4gIGRhdGE6IERhdGFTdG9yYWdlPFRlbnNvckRhdGE8RGF0YVR5cGU+PjtcbiAgcHJpdmF0ZSBmaXJzdFVzZSA9IHRydWU7XG4gIHByaXZhdGUgc3RhdGljIG5leHREYXRhSWQgPSAwO1xuICBwcml2YXRlIG5leHREYXRhSWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aEJhY2tlbmRDUFUubmV4dERhdGFJZCsrO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgRGF0YVN0b3JhZ2UodGhpcywgZW5naW5lKCkpO1xuICB9XG5cbiAgb3ZlcnJpZGUgd3JpdGUoXG4gICAgICB2YWx1ZXM6IGJhY2tlbmRfdXRpbC5CYWNrZW5kVmFsdWVzLCBzaGFwZTogbnVtYmVyW10sXG4gICAgICBkdHlwZTogRGF0YVR5cGUpOiBEYXRhSWQge1xuICAgIGlmICh0aGlzLmZpcnN0VXNlKSB7XG4gICAgICB0aGlzLmZpcnN0VXNlID0gZmFsc2U7XG4gICAgICBpZiAoZW52KCkuZ2V0KCdJU19OT0RFJykpIHtcbiAgICAgICAgYmFja2VuZF91dGlsLndhcm4oXG4gICAgICAgICAgICAnXFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbicgK1xuICAgICAgICAgICAgJ0hpLCBsb29rcyBsaWtlIHlvdSBhcmUgcnVubmluZyBUZW5zb3JGbG93LmpzIGluICcgK1xuICAgICAgICAgICAgJ05vZGUuanMuIFRvIHNwZWVkIHRoaW5ncyB1cCBkcmFtYXRpY2FsbHksIGluc3RhbGwgb3VyIG5vZGUgJyArXG4gICAgICAgICAgICAnYmFja2VuZCwgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy1ub2RlIGZvciBtb3JlIGRldGFpbHMuICcgK1xuICAgICAgICAgICAgJ1xcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YUlkID0ge2lkOiB0aGlzLm5leHREYXRhSWQoKX07XG5cbiAgICB0aGlzLmRhdGEuc2V0KGRhdGFJZCwge3ZhbHVlcywgZHR5cGUsIHJlZkNvdW50OiAxfSk7XG5cbiAgICByZXR1cm4gZGF0YUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGRhdGEgYnVja2V0IGluIGNwdSBiYWNrZW5kLlxuICAgKiBAcGFyYW0gc2hhcGUgU2hhcGUgb2YgdGhlIGBUZW5zb3JJbmZvYC5cbiAgICogQHBhcmFtIGR0eXBlIERUeXBlIG9mIHRoZSBgVGVuc29ySW5mb2AuXG4gICAqIEBwYXJhbSB2YWx1ZXMgVGhlIHZhbHVlIG9mIHRoZSBgVGVuc29ySW5mb2Agc3RvcmVkIGFzIGEgZmxhdHRlbmVkIGFycmF5LlxuICAgKi9cbiAgbWFrZVRlbnNvckluZm8oXG4gICAgICBzaGFwZTogbnVtYmVyW10sIGR0eXBlOiBEYXRhVHlwZSxcbiAgICAgIHZhbHVlcz86IGJhY2tlbmRfdXRpbC5CYWNrZW5kVmFsdWVzfHN0cmluZ1tdKTogVGVuc29ySW5mbyB7XG4gICAgbGV0IG91dElkO1xuICAgIGlmIChkdHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVzICE9IG51bGwgJiYgdmFsdWVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgdXRpbC5pc1N0cmluZyh2YWx1ZXNbMF0pKSB7XG4gICAgICBjb25zdCBlbmNvZGVkVmFsdWVzID1cbiAgICAgICAgICAodmFsdWVzIGFzIHVua25vd24gYXMgc3RyaW5nW10pLm1hcChkID0+IHV0aWwuZW5jb2RlU3RyaW5nKGQpKTtcblxuICAgICAgb3V0SWQgPSB0aGlzLndyaXRlKGVuY29kZWRWYWx1ZXMsIHNoYXBlLCBkdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dElkID0gdGhpcy53cml0ZSh2YWx1ZXMgYXMgVHlwZWRBcnJheSwgc2hhcGUsIGR0eXBlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2RhdGFJZDogb3V0SWQsIHNoYXBlLCBkdHlwZX07XG4gIH1cblxuICAvKiogUmV0dXJuIHJlZkNvdW50IG9mIGEgYFRlbnNvckRhdGFgLiAqL1xuICBvdmVycmlkZSByZWZDb3VudChkYXRhSWQ6IERhdGFJZCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgY29uc3QgdGVuc29yRGF0YSA9IHRoaXMuZGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgIHJldHVybiB0ZW5zb3JEYXRhLnJlZkNvdW50O1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKiBJbmNyZWFzZSByZWZDb3VudCBvZiBhIGBUZW5zb3JEYXRhYC4gKi9cbiAgb3ZlcnJpZGUgaW5jUmVmKGRhdGFJZDogRGF0YUlkKTogdm9pZCB7XG4gICAgY29uc3QgdGVuc29yRGF0YSA9IHRoaXMuZGF0YS5nZXQoZGF0YUlkKTtcbiAgICB0ZW5zb3JEYXRhLnJlZkNvdW50Kys7XG4gIH1cblxuICAvKiogRGVjcmVhc2UgcmVmQ291bnQgb2YgYSBgVGVuc29yRGF0YWAuICovXG4gIGRlY1JlZihkYXRhSWQ6IERhdGFJZCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmRhdGEuaGFzKGRhdGFJZCkpIHtcbiAgICAgIGNvbnN0IHRlbnNvckRhdGEgPSB0aGlzLmRhdGEuZ2V0KGRhdGFJZCk7XG4gICAgICB0ZW5zb3JEYXRhLnJlZkNvdW50LS07XG4gICAgfVxuICB9XG5cbiAgb3ZlcnJpZGUgbW92ZShcbiAgICAgIGRhdGFJZDogRGF0YUlkLCB2YWx1ZXM6IGJhY2tlbmRfdXRpbC5CYWNrZW5kVmFsdWVzLCBzaGFwZTogbnVtYmVyW10sXG4gICAgICBkdHlwZTogRGF0YVR5cGUsIHJlZkNvdW50OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmRhdGEuc2V0KGRhdGFJZCwge3ZhbHVlcywgZHR5cGUsIHJlZkNvdW50fSk7XG4gIH1cblxuICBvdmVycmlkZSBudW1EYXRhSWRzKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5udW1EYXRhSWRzKCk7XG4gIH1cblxuICBvdmVycmlkZSBhc3luYyByZWFkKGRhdGFJZDogRGF0YUlkKTogUHJvbWlzZTxiYWNrZW5kX3V0aWwuQmFja2VuZFZhbHVlcz4ge1xuICAgIHJldHVybiB0aGlzLnJlYWRTeW5jKGRhdGFJZCk7XG4gIH1cbiAgb3ZlcnJpZGUgcmVhZFN5bmMoZGF0YUlkOiBEYXRhSWQpOiBiYWNrZW5kX3V0aWwuQmFja2VuZFZhbHVlcyB7XG4gICAgY29uc3Qge2R0eXBlLCBjb21wbGV4VGVuc29ySW5mb3N9ID0gdGhpcy5kYXRhLmdldChkYXRhSWQpO1xuXG4gICAgaWYgKGR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgICAgY29uc3QgcmVhbFZhbHVlcyA9XG4gICAgICAgICAgdGhpcy5yZWFkU3luYyhjb21wbGV4VGVuc29ySW5mb3MucmVhbC5kYXRhSWQpIGFzIEZsb2F0MzJBcnJheTtcbiAgICAgIGNvbnN0IGltYWdWYWx1ZXMgPVxuICAgICAgICAgIHRoaXMucmVhZFN5bmMoY29tcGxleFRlbnNvckluZm9zLmltYWcuZGF0YUlkKSBhcyBGbG9hdDMyQXJyYXk7XG4gICAgICByZXR1cm4gYmFja2VuZF91dGlsLm1lcmdlUmVhbEFuZEltYWdBcnJheXMocmVhbFZhbHVlcywgaW1hZ1ZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB1dGlsLmNvbnZlcnRCYWNrZW5kVmFsdWVzQW5kQXJyYXlCdWZmZXIoXG4gICAgICAgIHRoaXMuZGF0YS5nZXQoZGF0YUlkKS52YWx1ZXMsIGR0eXBlKTtcbiAgfVxuXG4gIGJ1ZmZlclN5bmM8UiBleHRlbmRzIFJhbmssIEQgZXh0ZW5kcyBEYXRhVHlwZT4odDogVGVuc29ySW5mbyk6XG4gICAgICBUZW5zb3JCdWZmZXI8UiwgRD4ge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlYWRTeW5jKHQuZGF0YUlkKTtcbiAgICBpZiAodC5kdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIERlY29kZSB0aGUgYnl0ZXMgaW50byBzdHJpbmcuXG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSAoZGF0YSBhcyBVaW50OEFycmF5W10pLm1hcChkID0+IHV0aWwuZGVjb2RlU3RyaW5nKGQpKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcih0LnNoYXBlIGFzIFNoYXBlTWFwW1JdLCB0LmR0eXBlLCBzdHJpbmdzKSBhc1xuICAgICAgICAgICAgVGVuc29yQnVmZmVyPFIsIEQ+O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY29kZSBlbmNvZGVkIHN0cmluZyBieXRlcyBpbnRvIHV0Zi04Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIodC5zaGFwZSBhcyBTaGFwZU1hcFtSXSwgdC5kdHlwZSwgZGF0YSBhcyBUeXBlZEFycmF5KSBhc1xuICAgICAgICBUZW5zb3JCdWZmZXI8UiwgRD47XG4gIH1cblxuICBtYWtlT3V0cHV0PFQgZXh0ZW5kcyBUZW5zb3I+KFxuICAgICAgdmFsdWVzOiBiYWNrZW5kX3V0aWwuQmFja2VuZFZhbHVlcywgc2hhcGU6IG51bWJlcltdLCBkdHlwZTogRGF0YVR5cGUpOiBUIHtcbiAgICByZXR1cm4gZW5naW5lKCkubWFrZVRlbnNvckZyb21UZW5zb3JJbmZvKFxuICAgICAgICAgICAgICAgdGhpcy5tYWtlVGVuc29ySW5mbyhzaGFwZSwgZHR5cGUsIHZhbHVlcyksIHRoaXMpIGFzIFQ7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSB0aGUgbWVtb3J5IGlmIHRoZSBkYXRhSWQgaGFzIDAgcmVmQ291bnQuIFJldHVybiB0cnVlIGlmIHRoZSBtZW1vcnlcbiAgICogaXMgcmVsZWFzZWQgb3IgbWVtb3J5IGlzIG5vdCBtYW5hZ2VkIGluIHRoaXMgYmFja2VuZCwgZmFsc2UgaWYgbWVtb3J5IGlzXG4gICAqIG5vdCBjbGVhcmVkLlxuICAgKiBAcGFyYW0gZGF0YUlkXG4gICAqIEBvYXJhbSBmb3JjZSBPcHRpb25hbCwgcmVtb3ZlIHRoZSBkYXRhIHJlZ2FyZGxlc3Mgb2YgcmVmQ291bnRcbiAgICovXG4gIG92ZXJyaWRlIGRpc3Bvc2VEYXRhKGRhdGFJZDogRGF0YUlkLCBmb3JjZSA9IGZhbHNlKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgdGhpcy5kYXRhLmdldChkYXRhSWQpLnJlZkNvdW50LS07XG4gICAgICBpZiAoIWZvcmNlICYmIHRoaXMuZGF0YS5nZXQoZGF0YUlkKS5yZWZDb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7Y29tcGxleFRlbnNvckluZm9zfSA9IHRoaXMuZGF0YS5nZXQoZGF0YUlkKTtcblxuICAgICAgaWYgKGNvbXBsZXhUZW5zb3JJbmZvcyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZURhdGEoY29tcGxleFRlbnNvckluZm9zLnJlYWwuZGF0YUlkLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlRGF0YShjb21wbGV4VGVuc29ySW5mb3MuaW1hZy5kYXRhSWQsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRhdGEuZGVsZXRlKGRhdGFJZCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZGlzcG9zZUludGVybWVkaWF0ZVRlbnNvckluZm8odGVuc29ySW5mbzogVGVuc29ySW5mbyk6IHZvaWQge1xuICAgIHRoaXMuZGlzcG9zZURhdGEodGVuc29ySW5mby5kYXRhSWQpO1xuICB9XG5cbiAgb3ZlcnJpZGUgYXN5bmMgdGltZShmOiAoKSA9PiB2b2lkKTogUHJvbWlzZTxCYWNrZW5kVGltaW5nSW5mbz4ge1xuICAgIGNvbnN0IHN0YXJ0ID0gdXRpbC5ub3coKTtcbiAgICBmKCk7XG4gICAgY29uc3Qga2VybmVsTXMgPSB1dGlsLm5vdygpIC0gc3RhcnQ7XG4gICAgcmV0dXJuIHtrZXJuZWxNc307XG4gIH1cblxuICBvdmVycmlkZSBtZW1vcnkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFVucmVsaWFibGUgZHVlIHRvIGF1dG9tYXRpYyBnYy4gVGhlIG51bWJlcnMgYWJvdmUgYXJlIGN1bXVsYXRpdmUuXG4gICAgICB1bnJlbGlhYmxlOiB0cnVlLFxuICAgICAgcmVhc29uczpcbiAgICAgICAgICBbJ1RoZSByZXBvcnRlZCBtZW1vcnkgaXMgYW4gdXBwZXIgYm91bmQuIER1ZSB0byBhdXRvbWF0aWMgZ2FyYmFnZSAnICtcbiAgICAgICAgICAgJ2NvbGxlY3Rpb24sIHRoZSB0cnVlIGFsbG9jYXRlZCBtZW1vcnkgbWF5IGJlIGxlc3MuJ11cbiAgICB9O1xuICB9XG5cbiAgd2hlcmUoY29uZGl0aW9uOiBUZW5zb3IpOiBUZW5zb3IyRCB7XG4gICAgYXNzZXJ0Tm90Q29tcGxleChbY29uZGl0aW9uXSwgJ3doZXJlJyk7XG5cbiAgICBjb25zdCBjb25kVmFscyA9IHRoaXMucmVhZFN5bmMoY29uZGl0aW9uLmRhdGFJZCkgYXMgVHlwZWRBcnJheTtcbiAgICByZXR1cm4gd2hlcmVJbXBsKGNvbmRpdGlvbi5zaGFwZSwgY29uZFZhbHMpO1xuICB9XG5cbiAgb3ZlcnJpZGUgZGlzcG9zZSgpIHt9XG5cbiAgb3ZlcnJpZGUgZmxvYXRQcmVjaXNpb24oKTogMTZ8MzIge1xuICAgIHJldHVybiAzMjtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRoZSBzbWFsbGVzdCByZXByZXNlbnRhYmxlIG51bWJlci4gICovXG4gIG92ZXJyaWRlIGVwc2lsb24oKTogbnVtYmVyIHtcbiAgICByZXR1cm4gc3VwZXIuZXBzaWxvbigpO1xuICB9XG59XG4iXX0=