'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var max = require('ml-array-max');
var min = require('ml-array-min');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var max__default = /*#__PURE__*/_interopDefaultLegacy(max);
var min__default = /*#__PURE__*/_interopDefaultLegacy(min);

/**
 * Returns the average path length of the nodes in a tree from the root given the number of training data points
 * @param {number} sizeDataset - the number of data training points
 * @returns - the average path length from the root
 */
function averagePathLengthFromRoot(sizeDataset) {
  if (sizeDataset === 0 || sizeDataset === 1) {
    return 0;
  } else if (sizeDataset === 2) {
    return 1;
  }
  return (
    2 * Math.log(sizeDataset - 1) +
    0.57721 -
    (2 * (sizeDataset - 1)) / sizeDataset
  );
}

class TreeNode {
  /**
   * Constructor for a tree node used in an isolation forest
   * @param {object} options - options for the TreeNode
   * @param {number} options.depth - the depth of the TreeNode
   * @param {number} options.maxDepth - the maximum depth possible for the TreeNode
   * @constructor
   */
  constructor(options) {
    if (options) {
      this.depth = options.depth;
      this.maxDepth = options.maxDepth;
    }
  }

  /**
   * Train a node for the isolation forest given the training set
   * @param {number[][]} trainingSet - training set used to train the isolation tree
   * @param {number} currentDepth - depth of the node which is currently trained
   */
  train(trainingSet, currentDepth) {
    if (currentDepth <= this.maxDepth && trainingSet.length > 1) {
      this.left = new TreeNode(this);
      this.right = new TreeNode(this);

      const numberFeatures = trainingSet[0].length;
      this.splitColumn = Math.floor(Math.random() * numberFeatures);
      const valuesForFeature = trainingSet.map((row) => row[this.splitColumn]);

      const maxValueFeature = max__default["default"](valuesForFeature);
      const minValueFeature = min__default["default"](valuesForFeature);

      this.splitValue =
        Math.random() * (maxValueFeature - minValueFeature) + minValueFeature;

      const smallerThanSplitValue = trainingSet.filter(
        (row) => row[this.splitColumn] < this.splitValue,
      );
      const biggerThanSplitValue = trainingSet.filter(
        (row) => row[this.splitColumn] >= this.splitValue,
      );

      this.left.train(smallerThanSplitValue, currentDepth + 1);
      this.right.train(biggerThanSplitValue, currentDepth + 1);
    } else {
      this.trainingSet = trainingSet;
    }
  }

  /**
   * Verifies whether the current node is a leaf node in the tree it belongs to
   * @returns a boolean
   */
  isLeafNode() {
    return this.left === undefined && this.right === undefined;
  }

  /**
   * Verifies whether the current node is an inner node in the tree it belongs to
   * @returns a boolean
   */
  isInnerNode() {
    return this.left !== undefined && this.right !== undefined;
  }

  /**
   * Returns the number of data points in the current node
   * @returns the number of data points
   */
  numberDataPoints() {
    if (this.trainingSet !== undefined) {
      return this.trainingSet.length;
    }
    return 0;
  }

  /**
   * Returns the length of the path from the root to isolate the data point
   * @param {number[]} data - data point for which to predict the anomaly score
   * @param {number} currentPathLengthFromRoot - the current path length from the root
   * @returns
   */
  pathLengthFromRoot(data, currentPathLengthFromRoot) {
    if (this.isLeafNode()) {
      return (
        currentPathLengthFromRoot +
        averagePathLengthFromRoot(this.numberDataPoints())
      );
    }
    const splitColumn = this.splitColumn;
    if (data[splitColumn] < this.splitValue) {
      return this.left.pathLengthFromRoot(data, currentPathLengthFromRoot + 1);
    } else {
      return this.right.pathLengthFromRoot(data, currentPathLengthFromRoot + 1);
    }
  }
}

class IsolationForest {
  /**
   * Create a new instance of IsolationForest
   * @constructor
   * @param {object} options - options for the IsolationForest
   * @param {number} [options.nEstimators=100] - number of trees/estimators to use in the forest
   */
  constructor(options) {
    if (options) {
      this.nEstimators = options.nEstimators || 100;
    }
    this.nEstimators = this.nEstimators || 100;
    this.forest = [];
  }

  /**
   * Train the trees in the Isolation Forest with the given training set
   * @param {number[][]} - trainingSet for building the isolation forest
   */
  train(trainingSet) {
    this.trainingSet = trainingSet;
    const maxDepth = Math.ceil(Math.log2(this.trainingSet.length));

    for (let i = 0; i < this.nEstimators; i++) {
      const tree = new TreeNode({ depth: 0, maxDepth: maxDepth });
      tree.train(trainingSet, 0);
      this.forest.push(tree);
    }
  }

  /**
   * Predict the anomalies in the set
   * @param {number[][]} - set of data for which to find the anomalies
   * @return {number[]} - returns the anomaly scores for the data points
   */
  predict(data) {
    const anomalyScores = [];
    for (const row of data) {
      let totalLengthsOfPathsFromRoot = 0;
      for (let i = 0; i < this.nEstimators; i++) {
        totalLengthsOfPathsFromRoot += this.forest[i].pathLengthFromRoot(
          row,
          0,
        );
      }
      const averagePathLength = totalLengthsOfPathsFromRoot / this.nEstimators;
      const anomalyScore =
        2 **
        (-averagePathLength /
          averagePathLengthFromRoot(this.trainingSet.length));
      anomalyScores.push(anomalyScore);
    }
    return anomalyScores;
  }
}

exports.IsolationForest = IsolationForest;
