/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../engine';
import { GatherNd } from '../kernel_names';
import { convertToTensor } from '../tensor_util_env';
import { op } from './operation';
/**
 * Gather slices from input tensor into a Tensor with shape specified by
 * `indices`.
 *
 * `indices` is a K-dimensional integer tensor, best thought of as a
 * (K-1)-dimensional tensor of indices into input, where each element defines a
 * slice of input:
 * output[\\(i_0, ..., i_{K-2}\\)] = input[indices[\\(i_0, ..., i_{K-2}\\)]]
 *
 * Whereas in `tf.gather`, `indices` defines slices into the first dimension of
 * input, in `tf.gatherND`, `indices` defines slices into the first N dimensions
 * of input, where N = indices.shape[-1].
 *
 * The last dimension of indices can be at most the rank of input:
 * indices.shape[-1] <= input.rank
 *
 * The last dimension of `indices` corresponds to elements
 * (if indices.shape[-1] == input.rank) or slices
 * (if indices.shape[-1] < input.rank) along dimension indices.shape[-1] of
 * input.
 * The output tensor has shape
 * indices.shape[:-1] + input.shape[indices.shape[-1]:]
 *
 * Note that on CPU, if an out of bound index is found, an error is returned. On
 * GPU, if an out of bound index is found, a 0 is stored in the corresponding
 * output value.
 *
 * ```js
 * const indices = tf.tensor2d([0, 1, 1, 0], [2,2], 'int32');
 * const input = tf.tensor2d([9, 10, 11, 12], [2, 2]);
 * tf.gatherND(input, indices).print() // [10, 11]
 * ```
 *
 * @param x The tensor from which to gather values.
 * @param indices Index tensor, must be of type int32.
 *
 * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}
 */
function gatherND_(x, indices) {
    const $indices = convertToTensor(indices, 'indices', 'gatherND', 'int32');
    const $x = convertToTensor(x, 'x', 'gatherND', 'string_or_numeric');
    const inputs = { params: $x, indices: $indices };
    return ENGINE.runKernel(GatherNd, inputs);
}
export const gatherND = op({ gatherND_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2F0aGVyX25kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvZ2F0aGVyX25kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDakMsT0FBTyxFQUFDLFFBQVEsRUFBaUIsTUFBTSxpQkFBaUIsQ0FBQztBQUd6RCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFbkQsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUUvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFDRztBQUNILFNBQVMsU0FBUyxDQUFDLENBQW9CLEVBQUUsT0FBMEI7SUFDakUsTUFBTSxRQUFRLEdBQUcsZUFBZSxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzFFLE1BQU0sRUFBRSxHQUFHLGVBQWUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBRXBFLE1BQU0sTUFBTSxHQUFtQixFQUFDLE1BQU0sRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBQyxDQUFDO0lBRS9ELE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsTUFBOEIsQ0FBQyxDQUFDO0FBQ3BFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLEVBQUMsU0FBUyxFQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi9lbmdpbmUnO1xuaW1wb3J0IHtHYXRoZXJOZCwgR2F0aGVyTmRJbnB1dHN9IGZyb20gJy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7TmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7VGVuc29yTGlrZX0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtvcH0gZnJvbSAnLi9vcGVyYXRpb24nO1xuXG4vKipcbiAqIEdhdGhlciBzbGljZXMgZnJvbSBpbnB1dCB0ZW5zb3IgaW50byBhIFRlbnNvciB3aXRoIHNoYXBlIHNwZWNpZmllZCBieVxuICogYGluZGljZXNgLlxuICpcbiAqIGBpbmRpY2VzYCBpcyBhIEstZGltZW5zaW9uYWwgaW50ZWdlciB0ZW5zb3IsIGJlc3QgdGhvdWdodCBvZiBhcyBhXG4gKiAoSy0xKS1kaW1lbnNpb25hbCB0ZW5zb3Igb2YgaW5kaWNlcyBpbnRvIGlucHV0LCB3aGVyZSBlYWNoIGVsZW1lbnQgZGVmaW5lcyBhXG4gKiBzbGljZSBvZiBpbnB1dDpcbiAqIG91dHB1dFtcXFxcKGlfMCwgLi4uLCBpX3tLLTJ9XFxcXCldID0gaW5wdXRbaW5kaWNlc1tcXFxcKGlfMCwgLi4uLCBpX3tLLTJ9XFxcXCldXVxuICpcbiAqIFdoZXJlYXMgaW4gYHRmLmdhdGhlcmAsIGBpbmRpY2VzYCBkZWZpbmVzIHNsaWNlcyBpbnRvIHRoZSBmaXJzdCBkaW1lbnNpb24gb2ZcbiAqIGlucHV0LCBpbiBgdGYuZ2F0aGVyTkRgLCBgaW5kaWNlc2AgZGVmaW5lcyBzbGljZXMgaW50byB0aGUgZmlyc3QgTiBkaW1lbnNpb25zXG4gKiBvZiBpbnB1dCwgd2hlcmUgTiA9IGluZGljZXMuc2hhcGVbLTFdLlxuICpcbiAqIFRoZSBsYXN0IGRpbWVuc2lvbiBvZiBpbmRpY2VzIGNhbiBiZSBhdCBtb3N0IHRoZSByYW5rIG9mIGlucHV0OlxuICogaW5kaWNlcy5zaGFwZVstMV0gPD0gaW5wdXQucmFua1xuICpcbiAqIFRoZSBsYXN0IGRpbWVuc2lvbiBvZiBgaW5kaWNlc2AgY29ycmVzcG9uZHMgdG8gZWxlbWVudHNcbiAqIChpZiBpbmRpY2VzLnNoYXBlWy0xXSA9PSBpbnB1dC5yYW5rKSBvciBzbGljZXNcbiAqIChpZiBpbmRpY2VzLnNoYXBlWy0xXSA8IGlucHV0LnJhbmspIGFsb25nIGRpbWVuc2lvbiBpbmRpY2VzLnNoYXBlWy0xXSBvZlxuICogaW5wdXQuXG4gKiBUaGUgb3V0cHV0IHRlbnNvciBoYXMgc2hhcGVcbiAqIGluZGljZXMuc2hhcGVbOi0xXSArIGlucHV0LnNoYXBlW2luZGljZXMuc2hhcGVbLTFdOl1cbiAqXG4gKiBOb3RlIHRoYXQgb24gQ1BVLCBpZiBhbiBvdXQgb2YgYm91bmQgaW5kZXggaXMgZm91bmQsIGFuIGVycm9yIGlzIHJldHVybmVkLiBPblxuICogR1BVLCBpZiBhbiBvdXQgb2YgYm91bmQgaW5kZXggaXMgZm91bmQsIGEgMCBpcyBzdG9yZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIG91dHB1dCB2YWx1ZS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgaW5kaWNlcyA9IHRmLnRlbnNvcjJkKFswLCAxLCAxLCAwXSwgWzIsMl0sICdpbnQzMicpO1xuICogY29uc3QgaW5wdXQgPSB0Zi50ZW5zb3IyZChbOSwgMTAsIDExLCAxMl0sIFsyLCAyXSk7XG4gKiB0Zi5nYXRoZXJORChpbnB1dCwgaW5kaWNlcykucHJpbnQoKSAvLyBbMTAsIDExXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHggVGhlIHRlbnNvciBmcm9tIHdoaWNoIHRvIGdhdGhlciB2YWx1ZXMuXG4gKiBAcGFyYW0gaW5kaWNlcyBJbmRleCB0ZW5zb3IsIG11c3QgYmUgb2YgdHlwZSBpbnQzMi5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJ31cbiAqL1xuZnVuY3Rpb24gZ2F0aGVyTkRfKHg6IFRlbnNvcnxUZW5zb3JMaWtlLCBpbmRpY2VzOiBUZW5zb3J8VGVuc29yTGlrZSk6IFRlbnNvciB7XG4gIGNvbnN0ICRpbmRpY2VzID0gY29udmVydFRvVGVuc29yKGluZGljZXMsICdpbmRpY2VzJywgJ2dhdGhlck5EJywgJ2ludDMyJyk7XG4gIGNvbnN0ICR4ID0gY29udmVydFRvVGVuc29yKHgsICd4JywgJ2dhdGhlck5EJywgJ3N0cmluZ19vcl9udW1lcmljJyk7XG5cbiAgY29uc3QgaW5wdXRzOiBHYXRoZXJOZElucHV0cyA9IHtwYXJhbXM6ICR4LCBpbmRpY2VzOiAkaW5kaWNlc307XG5cbiAgcmV0dXJuIEVOR0lORS5ydW5LZXJuZWwoR2F0aGVyTmQsIGlucHV0cyBhcyB7fSBhcyBOYW1lZFRlbnNvck1hcCk7XG59XG5cbmV4cG9ydCBjb25zdCBnYXRoZXJORCA9IG9wKHtnYXRoZXJORF99KTtcbiJdfQ==