/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../engine';
import { RaggedTensorToTensor } from '../kernel_names';
import { convertToTensor } from '../tensor_util_env';
import { op } from './operation';
/**
 * Create a dense tensor from a ragged tensor, possibly altering its shape.
 *
 * The raggedTensorToTensor op creates a dense tensor from am array of row
 * partition tensors, a value vector, and default values. If the shape is
 * unspecified, the minimal shape required to contain all the elements in the
 * ragged tensor (the natural shape) will be used. If some dimensions are left
 * unspecified, then the size of the natural shape is used in that dimension.
 *
 * The defaultValue will be broadcast to the output shape. After that, the
 * values from the ragged tensor overwrite the default values. Note that the
 * defaultValue must have less dimensions than the value.
 *
 * The row partition tensors are in the order of the dimensions. At present, the
 * types can be: "ROW_SPLITS": the row_splits tensor from the ragged tensor.
 *   "VALUE_ROWIDS": the value_rowids tensor from the ragged tensor.
 *   "FIRST_DIM_SIZE": if value_rowids is used for the first dimension, then it
 * is preceded by "FIRST_DIM_SIZE".
 * ```
 * @param shape: A Tensor. Must be one of the following types: 'int32'. The
 *     desired shape of the output tensor. If left unspecified (empty), the
 *     minimal shape required to contain all the elements in the ragged tensor
 *     (the natural shape) will be used. If some dimensions are left
 *     unspecified, then the size of the natural shape is used in that
 *     dimension.
 *
 *     Note that dense dimensions cannot be modified by the shape argument.
 *     Trying to change the size of a dense dimension will cause the op to fail.
 *     Examples: natural shape: [4, 5, 6] shape: -1 output shape: [4, 5, 6]
 *
 *     natural shape: [4, 5, 6] shape: [3, -1, 2] output shape: [3, 5, 2]
 *
 *     natural shape: [4, 5, 6] shape: [3, 7, 2] output shape: [3, 7, 2]
 * @param values: A Tensor. A 1D tensor representing the values of the ragged
 *     tensor.
 * @param defaultValue: A Tensor. Must have the same type as values. The
 *     defaultValue when the shape is larger than the ragged tensor. The
 *     defaultValue is broadcast until it is the shape of the output tensor,
 *     and then overwritten by values in the ragged tensor. The default value
 *     must be compatible with this broadcast operation, and must have fewer
 *     dimensions than the value tensor.
 * @param rowPartitionTensors: A list of at least 1 Tensor objects with the same
 *     type in: 'int32'.
 * @param rowPartitionTypes: A list of strings. The types of the row partition
 *     tensors. At present, these can be:
 *     "ROW_SPLITS": the row_splits tensor from the ragged tensor.
 *     "VALUE_ROWIDS": the value_rowids tensor from the ragged tensor.
 *     "FIRST_DIM_SIZE": if value_rowids is used for the first dimension, then
 *         it is preceeded by "FIRST_DIM_SIZE". The tensors are in the order of
 *         the dimensions.
 * @return A Tensor. Has the same type as values.
 * @doc {heading: 'Operations', subheading: 'Ragged'}
 */
function raggedTensorToTensor_(shape, values, defaultValue, rowPartitionTensors, rowPartitionTypes) {
    const $shape = convertToTensor(shape, 'shape', 'raggedTensorToTensor', 'int32');
    const $values = convertToTensor(values, 'values', 'raggedTensorToTensor');
    const $defaultValue = convertToTensor(defaultValue, 'defaultValue', 'raggedTensorToTensor', $values.dtype);
    const $rowPartitionTensors = rowPartitionTensors.map((t, i) => convertToTensor(t, `tensors${i}`, 'raggedTensorToTensor', 'int32'));
    const inputs = {
        shape: $shape,
        values: $values,
        defaultValue: $defaultValue,
        rowPartitionTensors: $rowPartitionTensors
    };
    const attrs = { rowPartitionTypes };
    return ENGINE.runKernel(RaggedTensorToTensor, inputs, attrs);
}
export const raggedTensorToTensor = op({ raggedTensorToTensor_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFnZ2VkX3RlbnNvcl90b190ZW5zb3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9yYWdnZWRfdGVuc29yX3RvX3RlbnNvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ2pDLE9BQU8sRUFBQyxvQkFBb0IsRUFBd0QsTUFBTSxpQkFBaUIsQ0FBQztBQUU1RyxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFbkQsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUUvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9ERztBQUNILFNBQVMscUJBQXFCLENBQzFCLEtBQXdCLEVBQUUsTUFBeUIsRUFDbkQsWUFBK0IsRUFBRSxtQkFBNkIsRUFDOUQsaUJBQTJCO0lBQzdCLE1BQU0sTUFBTSxHQUNSLGVBQWUsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3JFLE1BQU0sT0FBTyxHQUFHLGVBQWUsQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLHNCQUFzQixDQUFDLENBQUM7SUFDMUUsTUFBTSxhQUFhLEdBQUcsZUFBZSxDQUNqQyxZQUFZLEVBQUUsY0FBYyxFQUFFLHNCQUFzQixFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6RSxNQUFNLG9CQUFvQixHQUFHLG1CQUFtQixDQUFDLEdBQUcsQ0FDaEQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDTCxlQUFlLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxFQUFFLEVBQUUsc0JBQXNCLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUU1RSxNQUFNLE1BQU0sR0FBK0I7UUFDekMsS0FBSyxFQUFFLE1BQU07UUFDYixNQUFNLEVBQUUsT0FBTztRQUNmLFlBQVksRUFBRSxhQUFhO1FBQzNCLG1CQUFtQixFQUFFLG9CQUFvQjtLQUMxQyxDQUFDO0lBQ0YsTUFBTSxLQUFLLEdBQThCLEVBQUMsaUJBQWlCLEVBQUMsQ0FBQztJQUU3RCxPQUFPLE1BQU0sQ0FBQyxTQUFTLENBQUMsb0JBQW9CLEVBQUUsTUFBWSxFQUFFLEtBQVcsQ0FBQyxDQUFDO0FBQzNFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxvQkFBb0IsR0FBRyxFQUFFLENBQUMsRUFBQyxxQkFBcUIsRUFBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMiBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi9lbmdpbmUnO1xuaW1wb3J0IHtSYWdnZWRUZW5zb3JUb1RlbnNvciwgUmFnZ2VkVGVuc29yVG9UZW5zb3JBdHRycywgUmFnZ2VkVGVuc29yVG9UZW5zb3JJbnB1dHN9IGZyb20gJy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge29wfSBmcm9tICcuL29wZXJhdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVuc2UgdGVuc29yIGZyb20gYSByYWdnZWQgdGVuc29yLCBwb3NzaWJseSBhbHRlcmluZyBpdHMgc2hhcGUuXG4gKlxuICogVGhlIHJhZ2dlZFRlbnNvclRvVGVuc29yIG9wIGNyZWF0ZXMgYSBkZW5zZSB0ZW5zb3IgZnJvbSBhbSBhcnJheSBvZiByb3dcbiAqIHBhcnRpdGlvbiB0ZW5zb3JzLCBhIHZhbHVlIHZlY3RvciwgYW5kIGRlZmF1bHQgdmFsdWVzLiBJZiB0aGUgc2hhcGUgaXNcbiAqIHVuc3BlY2lmaWVkLCB0aGUgbWluaW1hbCBzaGFwZSByZXF1aXJlZCB0byBjb250YWluIGFsbCB0aGUgZWxlbWVudHMgaW4gdGhlXG4gKiByYWdnZWQgdGVuc29yICh0aGUgbmF0dXJhbCBzaGFwZSkgd2lsbCBiZSB1c2VkLiBJZiBzb21lIGRpbWVuc2lvbnMgYXJlIGxlZnRcbiAqIHVuc3BlY2lmaWVkLCB0aGVuIHRoZSBzaXplIG9mIHRoZSBuYXR1cmFsIHNoYXBlIGlzIHVzZWQgaW4gdGhhdCBkaW1lbnNpb24uXG4gKlxuICogVGhlIGRlZmF1bHRWYWx1ZSB3aWxsIGJlIGJyb2FkY2FzdCB0byB0aGUgb3V0cHV0IHNoYXBlLiBBZnRlciB0aGF0LCB0aGVcbiAqIHZhbHVlcyBmcm9tIHRoZSByYWdnZWQgdGVuc29yIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCB2YWx1ZXMuIE5vdGUgdGhhdCB0aGVcbiAqIGRlZmF1bHRWYWx1ZSBtdXN0IGhhdmUgbGVzcyBkaW1lbnNpb25zIHRoYW4gdGhlIHZhbHVlLlxuICpcbiAqIFRoZSByb3cgcGFydGl0aW9uIHRlbnNvcnMgYXJlIGluIHRoZSBvcmRlciBvZiB0aGUgZGltZW5zaW9ucy4gQXQgcHJlc2VudCwgdGhlXG4gKiB0eXBlcyBjYW4gYmU6IFwiUk9XX1NQTElUU1wiOiB0aGUgcm93X3NwbGl0cyB0ZW5zb3IgZnJvbSB0aGUgcmFnZ2VkIHRlbnNvci5cbiAqICAgXCJWQUxVRV9ST1dJRFNcIjogdGhlIHZhbHVlX3Jvd2lkcyB0ZW5zb3IgZnJvbSB0aGUgcmFnZ2VkIHRlbnNvci5cbiAqICAgXCJGSVJTVF9ESU1fU0laRVwiOiBpZiB2YWx1ZV9yb3dpZHMgaXMgdXNlZCBmb3IgdGhlIGZpcnN0IGRpbWVuc2lvbiwgdGhlbiBpdFxuICogaXMgcHJlY2VkZWQgYnkgXCJGSVJTVF9ESU1fU0laRVwiLlxuICogYGBgXG4gKiBAcGFyYW0gc2hhcGU6IEEgVGVuc29yLiBNdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHR5cGVzOiAnaW50MzInLiBUaGVcbiAqICAgICBkZXNpcmVkIHNoYXBlIG9mIHRoZSBvdXRwdXQgdGVuc29yLiBJZiBsZWZ0IHVuc3BlY2lmaWVkIChlbXB0eSksIHRoZVxuICogICAgIG1pbmltYWwgc2hhcGUgcmVxdWlyZWQgdG8gY29udGFpbiBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSByYWdnZWQgdGVuc29yXG4gKiAgICAgKHRoZSBuYXR1cmFsIHNoYXBlKSB3aWxsIGJlIHVzZWQuIElmIHNvbWUgZGltZW5zaW9ucyBhcmUgbGVmdFxuICogICAgIHVuc3BlY2lmaWVkLCB0aGVuIHRoZSBzaXplIG9mIHRoZSBuYXR1cmFsIHNoYXBlIGlzIHVzZWQgaW4gdGhhdFxuICogICAgIGRpbWVuc2lvbi5cbiAqXG4gKiAgICAgTm90ZSB0aGF0IGRlbnNlIGRpbWVuc2lvbnMgY2Fubm90IGJlIG1vZGlmaWVkIGJ5IHRoZSBzaGFwZSBhcmd1bWVudC5cbiAqICAgICBUcnlpbmcgdG8gY2hhbmdlIHRoZSBzaXplIG9mIGEgZGVuc2UgZGltZW5zaW9uIHdpbGwgY2F1c2UgdGhlIG9wIHRvIGZhaWwuXG4gKiAgICAgRXhhbXBsZXM6IG5hdHVyYWwgc2hhcGU6IFs0LCA1LCA2XSBzaGFwZTogLTEgb3V0cHV0IHNoYXBlOiBbNCwgNSwgNl1cbiAqXG4gKiAgICAgbmF0dXJhbCBzaGFwZTogWzQsIDUsIDZdIHNoYXBlOiBbMywgLTEsIDJdIG91dHB1dCBzaGFwZTogWzMsIDUsIDJdXG4gKlxuICogICAgIG5hdHVyYWwgc2hhcGU6IFs0LCA1LCA2XSBzaGFwZTogWzMsIDcsIDJdIG91dHB1dCBzaGFwZTogWzMsIDcsIDJdXG4gKiBAcGFyYW0gdmFsdWVzOiBBIFRlbnNvci4gQSAxRCB0ZW5zb3IgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZXMgb2YgdGhlIHJhZ2dlZFxuICogICAgIHRlbnNvci5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWU6IEEgVGVuc29yLiBNdXN0IGhhdmUgdGhlIHNhbWUgdHlwZSBhcyB2YWx1ZXMuIFRoZVxuICogICAgIGRlZmF1bHRWYWx1ZSB3aGVuIHRoZSBzaGFwZSBpcyBsYXJnZXIgdGhhbiB0aGUgcmFnZ2VkIHRlbnNvci4gVGhlXG4gKiAgICAgZGVmYXVsdFZhbHVlIGlzIGJyb2FkY2FzdCB1bnRpbCBpdCBpcyB0aGUgc2hhcGUgb2YgdGhlIG91dHB1dCB0ZW5zb3IsXG4gKiAgICAgYW5kIHRoZW4gb3ZlcndyaXR0ZW4gYnkgdmFsdWVzIGluIHRoZSByYWdnZWQgdGVuc29yLiBUaGUgZGVmYXVsdCB2YWx1ZVxuICogICAgIG11c3QgYmUgY29tcGF0aWJsZSB3aXRoIHRoaXMgYnJvYWRjYXN0IG9wZXJhdGlvbiwgYW5kIG11c3QgaGF2ZSBmZXdlclxuICogICAgIGRpbWVuc2lvbnMgdGhhbiB0aGUgdmFsdWUgdGVuc29yLlxuICogQHBhcmFtIHJvd1BhcnRpdGlvblRlbnNvcnM6IEEgbGlzdCBvZiBhdCBsZWFzdCAxIFRlbnNvciBvYmplY3RzIHdpdGggdGhlIHNhbWVcbiAqICAgICB0eXBlIGluOiAnaW50MzInLlxuICogQHBhcmFtIHJvd1BhcnRpdGlvblR5cGVzOiBBIGxpc3Qgb2Ygc3RyaW5ncy4gVGhlIHR5cGVzIG9mIHRoZSByb3cgcGFydGl0aW9uXG4gKiAgICAgdGVuc29ycy4gQXQgcHJlc2VudCwgdGhlc2UgY2FuIGJlOlxuICogICAgIFwiUk9XX1NQTElUU1wiOiB0aGUgcm93X3NwbGl0cyB0ZW5zb3IgZnJvbSB0aGUgcmFnZ2VkIHRlbnNvci5cbiAqICAgICBcIlZBTFVFX1JPV0lEU1wiOiB0aGUgdmFsdWVfcm93aWRzIHRlbnNvciBmcm9tIHRoZSByYWdnZWQgdGVuc29yLlxuICogICAgIFwiRklSU1RfRElNX1NJWkVcIjogaWYgdmFsdWVfcm93aWRzIGlzIHVzZWQgZm9yIHRoZSBmaXJzdCBkaW1lbnNpb24sIHRoZW5cbiAqICAgICAgICAgaXQgaXMgcHJlY2VlZGVkIGJ5IFwiRklSU1RfRElNX1NJWkVcIi4gVGhlIHRlbnNvcnMgYXJlIGluIHRoZSBvcmRlciBvZlxuICogICAgICAgICB0aGUgZGltZW5zaW9ucy5cbiAqIEByZXR1cm4gQSBUZW5zb3IuIEhhcyB0aGUgc2FtZSB0eXBlIGFzIHZhbHVlcy5cbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ1JhZ2dlZCd9XG4gKi9cbmZ1bmN0aW9uIHJhZ2dlZFRlbnNvclRvVGVuc29yXyhcbiAgICBzaGFwZTogVGVuc29yfFRlbnNvckxpa2UsIHZhbHVlczogVGVuc29yfFRlbnNvckxpa2UsXG4gICAgZGVmYXVsdFZhbHVlOiBUZW5zb3J8VGVuc29yTGlrZSwgcm93UGFydGl0aW9uVGVuc29yczogVGVuc29yW10sXG4gICAgcm93UGFydGl0aW9uVHlwZXM6IHN0cmluZ1tdKTogVGVuc29yIHtcbiAgY29uc3QgJHNoYXBlID1cbiAgICAgIGNvbnZlcnRUb1RlbnNvcihzaGFwZSwgJ3NoYXBlJywgJ3JhZ2dlZFRlbnNvclRvVGVuc29yJywgJ2ludDMyJyk7XG4gIGNvbnN0ICR2YWx1ZXMgPSBjb252ZXJ0VG9UZW5zb3IodmFsdWVzLCAndmFsdWVzJywgJ3JhZ2dlZFRlbnNvclRvVGVuc29yJyk7XG4gIGNvbnN0ICRkZWZhdWx0VmFsdWUgPSBjb252ZXJ0VG9UZW5zb3IoXG4gICAgICBkZWZhdWx0VmFsdWUsICdkZWZhdWx0VmFsdWUnLCAncmFnZ2VkVGVuc29yVG9UZW5zb3InLCAkdmFsdWVzLmR0eXBlKTtcbiAgY29uc3QgJHJvd1BhcnRpdGlvblRlbnNvcnMgPSByb3dQYXJ0aXRpb25UZW5zb3JzLm1hcChcbiAgICAgICh0LCBpKSA9PlxuICAgICAgICAgIGNvbnZlcnRUb1RlbnNvcih0LCBgdGVuc29ycyR7aX1gLCAncmFnZ2VkVGVuc29yVG9UZW5zb3InLCAnaW50MzInKSk7XG5cbiAgY29uc3QgaW5wdXRzOiBSYWdnZWRUZW5zb3JUb1RlbnNvcklucHV0cyA9IHtcbiAgICBzaGFwZTogJHNoYXBlLFxuICAgIHZhbHVlczogJHZhbHVlcyxcbiAgICBkZWZhdWx0VmFsdWU6ICRkZWZhdWx0VmFsdWUsXG4gICAgcm93UGFydGl0aW9uVGVuc29yczogJHJvd1BhcnRpdGlvblRlbnNvcnNcbiAgfTtcbiAgY29uc3QgYXR0cnM6IFJhZ2dlZFRlbnNvclRvVGVuc29yQXR0cnMgPSB7cm93UGFydGl0aW9uVHlwZXN9O1xuXG4gIHJldHVybiBFTkdJTkUucnVuS2VybmVsKFJhZ2dlZFRlbnNvclRvVGVuc29yLCBpbnB1dHMgYXMge30sIGF0dHJzIGFzIHt9KTtcbn1cblxuZXhwb3J0IGNvbnN0IHJhZ2dlZFRlbnNvclRvVGVuc29yID0gb3Aoe3JhZ2dlZFRlbnNvclRvVGVuc29yX30pO1xuIl19