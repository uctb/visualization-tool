/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { convertToTensor } from '../tensor_util_env';
import { parseAxisParam } from '../util';
import { abs } from './abs';
import * as axis_util from './axis_util';
import { max } from './max';
import { min } from './min';
import { op } from './operation';
import { pow } from './pow';
import { reshape } from './reshape';
import { scalar } from './scalar';
import { sqrt } from './sqrt';
import { square } from './square';
import { sum } from './sum';
/**
 * Computes the norm of scalar, vectors, and matrices.
 * This function can compute several different vector norms (the 1-norm, the
 * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)
 * and matrix norms (Frobenius, 1-norm, and inf-norm).
 *
 * ```js
 * const x = tf.tensor1d([1, 2, 3, 4]);
 *
 * x.norm().print();  // or tf.norm(x)
 * ```
 *
 * @param x The input array.
 * @param ord Optional. Order of the norm. Supported norm types are
 * following:
 *
 *  | ord        | norm for matrices         | norm for vectors
 *  |------------|---------------------------|---------------------
 *  |'euclidean' |Frobenius norm             |2-norm
 *  |'fro'       |Frobenius norm	           |
 *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))
 *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))
 *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))
 *  |2           |                           |sum(abs(x)^2)^(1/2)
 *
 * @param axis Optional. If axis is null (the default), the input is
 * considered a vector and a single vector norm is computed over the entire
 * set of values in the Tensor, i.e. norm(x, ord) is equivalent
 * to norm(x.reshape([-1]), ord). If axis is an integer, the input
 * is considered a batch of vectors, and axis determines the axis in x
 * over which to compute vector norms. If axis is a 2-tuple of integer it is
 * considered a batch of matrices and axis determines the axes in NDArray
 * over which to compute a matrix norm.
 * @param keepDims Optional. If true, the norm has the same dimensionality
 * as the input.
 *
 * @doc {heading: 'Operations', subheading: 'Matrices'}
 */
function norm_(x, ord = 'euclidean', axis = null, keepDims = false) {
    x = convertToTensor(x, 'x', 'norm');
    const norm = normImpl(x, ord, axis);
    let keepDimsShape = norm.shape;
    if (keepDims) {
        const axes = parseAxisParam(axis, x.shape);
        keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);
    }
    return reshape(norm, keepDimsShape);
}
function normImpl(x, p, axis = null) {
    if (x.rank === 0) {
        return abs(x);
    }
    // consider vector when no axis is specified
    if (x.rank !== 1 && axis === null) {
        return normImpl(reshape(x, [-1]), p, axis);
    }
    // vector
    if (x.rank === 1 || typeof axis === 'number' ||
        Array.isArray(axis) && axis.length === 1) {
        if (p === 1) {
            return sum(abs(x), axis);
        }
        if (p === Infinity) {
            return max(abs(x), axis);
        }
        if (p === -Infinity) {
            return min(abs(x), axis);
        }
        if (p === 'euclidean' || p === 2) {
            // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2
            return sqrt(sum(pow(abs(x), scalar(2, 'int32')), axis));
        }
        throw new Error(`Error in norm: invalid ord value: ${p}`);
    }
    // matrix (assumption axis[0] < axis[1])
    if (Array.isArray(axis) && axis.length === 2) {
        if (p === 1) {
            return max(sum(abs(x), axis[0]), axis[1] - 1);
        }
        if (p === Infinity) {
            return max(sum(abs(x), axis[1]), axis[0]);
        }
        if (p === -Infinity) {
            return min(sum(abs(x), axis[1]), axis[0]);
        }
        if (p === 'fro' || p === 'euclidean') {
            // norm(x) = sqrt(sum(pow(x, 2)))
            return sqrt(sum(square(x), axis));
        }
        throw new Error(`Error in norm: invalid ord value: ${p}`);
    }
    throw new Error(`Error in norm: invalid axis: ${axis}`);
}
export const norm = op({ norm_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9ybS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtY29yZS9zcmMvb3BzL25vcm0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBRW5ELE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFFdkMsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLE9BQU8sQ0FBQztBQUMxQixPQUFPLEtBQUssU0FBUyxNQUFNLGFBQWEsQ0FBQztBQUN6QyxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBQzFCLE9BQU8sRUFBQyxHQUFHLEVBQUMsTUFBTSxPQUFPLENBQUM7QUFDMUIsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUMvQixPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBQzFCLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDbEMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUNoQyxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sUUFBUSxDQUFDO0FBQzVCLE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDaEMsT0FBTyxFQUFDLEdBQUcsRUFBQyxNQUFNLE9BQU8sQ0FBQztBQUUxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFDRztBQUNILFNBQVMsS0FBSyxDQUNWLENBQW9CLEVBQUUsTUFBZ0MsV0FBVyxFQUNqRSxPQUF3QixJQUFJLEVBQUUsUUFBUSxHQUFHLEtBQUs7SUFDaEQsQ0FBQyxHQUFHLGVBQWUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRXBDLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3BDLElBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDL0IsSUFBSSxRQUFRLEVBQUU7UUFDWixNQUFNLElBQUksR0FBRyxjQUFjLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMzQyxhQUFhLEdBQUcsU0FBUyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDbEU7SUFDRCxPQUFPLE9BQU8sQ0FBQyxJQUFJLEVBQUUsYUFBYSxDQUFDLENBQUM7QUFDdEMsQ0FBQztBQUVELFNBQVMsUUFBUSxDQUNiLENBQVMsRUFBRSxDQUFnQixFQUFFLE9BQXdCLElBQUk7SUFDM0QsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtRQUNoQixPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNmO0lBRUQsNENBQTRDO0lBQzVDLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLElBQUksSUFBSSxLQUFLLElBQUksRUFBRTtRQUNqQyxPQUFPLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztLQUM1QztJQUVELFNBQVM7SUFDVCxJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVE7UUFDeEMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUM1QyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDWCxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDMUI7UUFDRCxJQUFJLENBQUMsS0FBSyxRQUFRLEVBQUU7WUFDbEIsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzFCO1FBQ0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7WUFDbkIsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzFCO1FBQ0QsSUFBSSxDQUFDLEtBQUssV0FBVyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDaEMsc0NBQXNDO1lBQ3RDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ3pEO1FBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUMzRDtJQUVELHdDQUF3QztJQUN4QyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDNUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ1gsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDL0M7UUFDRCxJQUFJLENBQUMsS0FBSyxRQUFRLEVBQUU7WUFDbEIsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzQztRQUNELElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFO1lBQ25CLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDM0M7UUFDRCxJQUFJLENBQUMsS0FBSyxLQUFLLElBQUksQ0FBQyxLQUFLLFdBQVcsRUFBRTtZQUNwQyxpQ0FBaUM7WUFDakMsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ25DO1FBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBcUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUMzRDtJQUVELE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLElBQUksRUFBRSxDQUFDLENBQUM7QUFDMUQsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLElBQUksR0FBRyxFQUFFLENBQUMsRUFBQyxLQUFLLEVBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge1RlbnNvcn0gZnJvbSAnLi4vdGVuc29yJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge3BhcnNlQXhpc1BhcmFtfSBmcm9tICcuLi91dGlsJztcblxuaW1wb3J0IHthYnN9IGZyb20gJy4vYWJzJztcbmltcG9ydCAqIGFzIGF4aXNfdXRpbCBmcm9tICcuL2F4aXNfdXRpbCc7XG5pbXBvcnQge21heH0gZnJvbSAnLi9tYXgnO1xuaW1wb3J0IHttaW59IGZyb20gJy4vbWluJztcbmltcG9ydCB7b3B9IGZyb20gJy4vb3BlcmF0aW9uJztcbmltcG9ydCB7cG93fSBmcm9tICcuL3Bvdyc7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4vcmVzaGFwZSc7XG5pbXBvcnQge3NjYWxhcn0gZnJvbSAnLi9zY2FsYXInO1xuaW1wb3J0IHtzcXJ0fSBmcm9tICcuL3NxcnQnO1xuaW1wb3J0IHtzcXVhcmV9IGZyb20gJy4vc3F1YXJlJztcbmltcG9ydCB7c3VtfSBmcm9tICcuL3N1bSc7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIG5vcm0gb2Ygc2NhbGFyLCB2ZWN0b3JzLCBhbmQgbWF0cmljZXMuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBjb21wdXRlIHNldmVyYWwgZGlmZmVyZW50IHZlY3RvciBub3JtcyAodGhlIDEtbm9ybSwgdGhlXG4gKiBFdWNsaWRlYW4gb3IgMi1ub3JtLCB0aGUgaW5mLW5vcm0sIGFuZCBpbiBnZW5lcmFsIHRoZSBwLW5vcm0gZm9yIHAgPiAwKVxuICogYW5kIG1hdHJpeCBub3JtcyAoRnJvYmVuaXVzLCAxLW5vcm0sIGFuZCBpbmYtbm9ybSkuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHggPSB0Zi50ZW5zb3IxZChbMSwgMiwgMywgNF0pO1xuICpcbiAqIHgubm9ybSgpLnByaW50KCk7ICAvLyBvciB0Zi5ub3JtKHgpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geCBUaGUgaW5wdXQgYXJyYXkuXG4gKiBAcGFyYW0gb3JkIE9wdGlvbmFsLiBPcmRlciBvZiB0aGUgbm9ybS4gU3VwcG9ydGVkIG5vcm0gdHlwZXMgYXJlXG4gKiBmb2xsb3dpbmc6XG4gKlxuICogIHwgb3JkICAgICAgICB8IG5vcm0gZm9yIG1hdHJpY2VzICAgICAgICAgfCBub3JtIGZvciB2ZWN0b3JzXG4gKiAgfC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgfCdldWNsaWRlYW4nIHxGcm9iZW5pdXMgbm9ybSAgICAgICAgICAgICB8Mi1ub3JtXG4gKiAgfCdmcm8nICAgICAgIHxGcm9iZW5pdXMgbm9ybVx0ICAgICAgICAgICB8XG4gKiAgfEluZmluaXR5ICAgIHxtYXgoc3VtKGFicyh4KSwgYXhpcz0xKSkgICB8bWF4KGFicyh4KSlcbiAqICB8LUluZmluaXR5ICAgfG1pbihzdW0oYWJzKHgpLCBheGlzPTEpKSAgIHxtaW4oYWJzKHgpKVxuICogIHwxICAgICAgICAgICB8bWF4KHN1bShhYnMoeCksIGF4aXM9MCkpICAgfHN1bShhYnMoeCkpXG4gKiAgfDIgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICB8c3VtKGFicyh4KV4yKV4oMS8yKVxuICpcbiAqIEBwYXJhbSBheGlzIE9wdGlvbmFsLiBJZiBheGlzIGlzIG51bGwgKHRoZSBkZWZhdWx0KSwgdGhlIGlucHV0IGlzXG4gKiBjb25zaWRlcmVkIGEgdmVjdG9yIGFuZCBhIHNpbmdsZSB2ZWN0b3Igbm9ybSBpcyBjb21wdXRlZCBvdmVyIHRoZSBlbnRpcmVcbiAqIHNldCBvZiB2YWx1ZXMgaW4gdGhlIFRlbnNvciwgaS5lLiBub3JtKHgsIG9yZCkgaXMgZXF1aXZhbGVudFxuICogdG8gbm9ybSh4LnJlc2hhcGUoWy0xXSksIG9yZCkuIElmIGF4aXMgaXMgYW4gaW50ZWdlciwgdGhlIGlucHV0XG4gKiBpcyBjb25zaWRlcmVkIGEgYmF0Y2ggb2YgdmVjdG9ycywgYW5kIGF4aXMgZGV0ZXJtaW5lcyB0aGUgYXhpcyBpbiB4XG4gKiBvdmVyIHdoaWNoIHRvIGNvbXB1dGUgdmVjdG9yIG5vcm1zLiBJZiBheGlzIGlzIGEgMi10dXBsZSBvZiBpbnRlZ2VyIGl0IGlzXG4gKiBjb25zaWRlcmVkIGEgYmF0Y2ggb2YgbWF0cmljZXMgYW5kIGF4aXMgZGV0ZXJtaW5lcyB0aGUgYXhlcyBpbiBOREFycmF5XG4gKiBvdmVyIHdoaWNoIHRvIGNvbXB1dGUgYSBtYXRyaXggbm9ybS5cbiAqIEBwYXJhbSBrZWVwRGltcyBPcHRpb25hbC4gSWYgdHJ1ZSwgdGhlIG5vcm0gaGFzIHRoZSBzYW1lIGRpbWVuc2lvbmFsaXR5XG4gKiBhcyB0aGUgaW5wdXQuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTWF0cmljZXMnfVxuICovXG5mdW5jdGlvbiBub3JtXyhcbiAgICB4OiBUZW5zb3J8VGVuc29yTGlrZSwgb3JkOiBudW1iZXJ8J2V1Y2xpZGVhbid8J2ZybycgPSAnZXVjbGlkZWFuJyxcbiAgICBheGlzOiBudW1iZXJ8bnVtYmVyW10gPSBudWxsLCBrZWVwRGltcyA9IGZhbHNlKTogVGVuc29yIHtcbiAgeCA9IGNvbnZlcnRUb1RlbnNvcih4LCAneCcsICdub3JtJyk7XG5cbiAgY29uc3Qgbm9ybSA9IG5vcm1JbXBsKHgsIG9yZCwgYXhpcyk7XG4gIGxldCBrZWVwRGltc1NoYXBlID0gbm9ybS5zaGFwZTtcbiAgaWYgKGtlZXBEaW1zKSB7XG4gICAgY29uc3QgYXhlcyA9IHBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgIGtlZXBEaW1zU2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0obm9ybS5zaGFwZSwgYXhlcyk7XG4gIH1cbiAgcmV0dXJuIHJlc2hhcGUobm9ybSwga2VlcERpbXNTaGFwZSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1JbXBsKFxuICAgIHg6IFRlbnNvciwgcDogbnVtYmVyfHN0cmluZywgYXhpczogbnVtYmVyfG51bWJlcltdID0gbnVsbCk6IFRlbnNvciB7XG4gIGlmICh4LnJhbmsgPT09IDApIHtcbiAgICByZXR1cm4gYWJzKHgpO1xuICB9XG5cbiAgLy8gY29uc2lkZXIgdmVjdG9yIHdoZW4gbm8gYXhpcyBpcyBzcGVjaWZpZWRcbiAgaWYgKHgucmFuayAhPT0gMSAmJiBheGlzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG5vcm1JbXBsKHJlc2hhcGUoeCwgWy0xXSksIHAsIGF4aXMpO1xuICB9XG5cbiAgLy8gdmVjdG9yXG4gIGlmICh4LnJhbmsgPT09IDEgfHwgdHlwZW9mIGF4aXMgPT09ICdudW1iZXInIHx8XG4gICAgICBBcnJheS5pc0FycmF5KGF4aXMpICYmIGF4aXMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHAgPT09IDEpIHtcbiAgICAgIHJldHVybiBzdW0oYWJzKHgpLCBheGlzKTtcbiAgICB9XG4gICAgaWYgKHAgPT09IEluZmluaXR5KSB7XG4gICAgICByZXR1cm4gbWF4KGFicyh4KSwgYXhpcyk7XG4gICAgfVxuICAgIGlmIChwID09PSAtSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBtaW4oYWJzKHgpLCBheGlzKTtcbiAgICB9XG4gICAgaWYgKHAgPT09ICdldWNsaWRlYW4nIHx8IHAgPT09IDIpIHtcbiAgICAgIC8vIG5vcm0oeCwgMikgPSBzdW0oYWJzKHhpKSBeIDIpIF4gMS8yXG4gICAgICByZXR1cm4gc3FydChzdW0ocG93KGFicyh4KSwgc2NhbGFyKDIsICdpbnQzMicpKSwgYXhpcykpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6ICR7cH1gKTtcbiAgfVxuXG4gIC8vIG1hdHJpeCAoYXNzdW1wdGlvbiBheGlzWzBdIDwgYXhpc1sxXSlcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXhpcykgJiYgYXhpcy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAocCA9PT0gMSkge1xuICAgICAgcmV0dXJuIG1heChzdW0oYWJzKHgpLCBheGlzWzBdKSwgYXhpc1sxXSAtIDEpO1xuICAgIH1cbiAgICBpZiAocCA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBtYXgoc3VtKGFicyh4KSwgYXhpc1sxXSksIGF4aXNbMF0pO1xuICAgIH1cbiAgICBpZiAocCA9PT0gLUluZmluaXR5KSB7XG4gICAgICByZXR1cm4gbWluKHN1bShhYnMoeCksIGF4aXNbMV0pLCBheGlzWzBdKTtcbiAgICB9XG4gICAgaWYgKHAgPT09ICdmcm8nIHx8IHAgPT09ICdldWNsaWRlYW4nKSB7XG4gICAgICAvLyBub3JtKHgpID0gc3FydChzdW0ocG93KHgsIDIpKSlcbiAgICAgIHJldHVybiBzcXJ0KHN1bShzcXVhcmUoeCksIGF4aXMpKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIG5vcm06IGludmFsaWQgb3JkIHZhbHVlOiAke3B9YCk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIG5vcm06IGludmFsaWQgYXhpczogJHtheGlzfWApO1xufVxuXG5leHBvcnQgY29uc3Qgbm9ybSA9IG9wKHtub3JtX30pO1xuIl19