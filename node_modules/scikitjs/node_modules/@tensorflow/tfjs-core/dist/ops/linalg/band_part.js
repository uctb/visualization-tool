/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { convertToTensor } from '../../tensor_util_env';
import { assert } from '../../util';
import { greaterEqual } from '../greater_equal';
import { lessEqual } from '../less_equal';
import { logicalAnd } from '../logical_and';
import { op } from '../operation';
import { range } from '../range';
import { reshape } from '../reshape';
import { scalar } from '../scalar';
import { stack } from '../stack';
import { sub } from '../sub';
import { unstack } from '../unstack';
import { where } from '../where';
import { zeros } from '../zeros';
/**
 * Copy a tensor setting everything outside a central band in each innermost
 * matrix to zero.
 *
 * The band part is computed as follows: Assume input has `k` dimensions
 * `[I, J, K, ..., M, N]`, then the output is a tensor with the same shape where
 * `band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.
 * The indicator function
 * `in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower)`
 * `&& (num_upper < 0 || (n-m) <= num_upper)`
 *
 * ```js
 * const x = tf.tensor2d([[ 0,  1,  2, 3],
 *                        [-1,  0,  1, 2],
 *                        [-2, -1,  0, 1],
 *                        [-3, -2, -1, 0]]);
 * let y = tf.linalg.bandPart(x, 1, -1);
 * y.print(); // [[ 0,  1,  2, 3],
 *            //  [-1,  0,  1, 2],
 *            //  [ 0, -1,  0, 1],
 *            //  [ 0, 0 , -1, 0]]
 * let z = tf.linalg.bandPart(x, 2, 1);
 * z.print(); // [[ 0,  1,  0, 0],
 *            //  [-1,  0,  1, 0],
 *            //  [-2, -1,  0, 1],
 *            //  [ 0, -2, -1, 0]]
 * ```
 *
 * @param x Rank `k` tensor
 * @param numLower Number of subdiagonals to keep.
 *   If negative, keep entire lower triangle.
 * @param numUpper Number of subdiagonals to keep.
 *   If negative, keep entire upper triangle.
 * @returns Rank `k` tensor of the same shape as input.
 *   The extracted banded tensor.
 *
 * @doc {heading:'Operations', subheading:'Linear Algebra', namespace:'linalg'}
 */
function bandPart_(a, numLower, numUpper) {
    assert(numLower % 1 === 0, () => `bandPart(): numLower must be an integer, got ${numLower}.`);
    assert(numUpper % 1 === 0, () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);
    const $a = convertToTensor(a, 'a', 'bandPart');
    assert($a.rank >= 2, () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);
    const shape = $a.shape;
    const [M, N] = $a.shape.slice(-2);
    if (!(numLower <= M)) {
        throw new Error(`bandPart(): numLower (${numLower})` +
            ` must not be greater than the number of rows (${M}).`);
    }
    if (!(numUpper <= N)) {
        throw new Error(`bandPart(): numUpper (${numUpper})` +
            ` must not be greater than the number of columns (${N}).`);
    }
    if (numLower < 0) {
        numLower = M;
    }
    if (numUpper < 0) {
        numUpper = N;
    }
    const i = reshape(range(0, M, 1, 'int32'), [-1, 1]);
    const j = range(0, N, 1, 'int32');
    const ij = sub(i, j);
    const inBand = logicalAnd(lessEqual(ij, scalar(+numLower, 'int32')), greaterEqual(ij, scalar(-numUpper, 'int32')));
    const zero = zeros([M, N], $a.dtype);
    return reshape(stack(unstack(reshape($a, [-1, M, N]))
        .map(mat => where(inBand, mat, zero))), shape);
}
export const bandPart = op({ bandPart_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFuZF9wYXJ0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvbGluYWxnL2JhbmRfcGFydC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFHSCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFlBQVksQ0FBQztBQUVsQyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDOUMsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN4QyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUMsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUNoQyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQy9CLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDbkMsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQy9CLE9BQU8sRUFBQyxHQUFHLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFDM0IsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNuQyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQy9CLE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFFL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FxQ0c7QUFDSCxTQUFTLFNBQVMsQ0FDZCxDQUFlLEVBQUUsUUFBZ0IsRUFBRSxRQUFnQjtJQUNyRCxNQUFNLENBQ0YsUUFBUSxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQ2xCLEdBQUcsRUFBRSxDQUFDLGdEQUFnRCxRQUFRLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZFLE1BQU0sQ0FDRixRQUFRLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFDbEIsR0FBRyxFQUFFLENBQUMsZ0RBQWdELFFBQVEsR0FBRyxDQUFDLENBQUM7SUFFdkUsTUFBTSxFQUFFLEdBQUcsZUFBZSxDQUFDLENBQUMsRUFBRSxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFL0MsTUFBTSxDQUNGLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUNaLEdBQUcsRUFBRSxDQUFDLDRDQUE0QyxFQUFFLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztJQUVsRSxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDO0lBQ3ZCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVsQyxJQUFJLENBQUMsQ0FBQyxRQUFRLElBQUksQ0FBQyxDQUFDLEVBQUU7UUFDcEIsTUFBTSxJQUFJLEtBQUssQ0FDWCx5QkFBeUIsUUFBUSxHQUFHO1lBQ3BDLGlEQUFpRCxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzdEO0lBQ0QsSUFBSSxDQUFDLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQ1gseUJBQXlCLFFBQVEsR0FBRztZQUNwQyxvREFBb0QsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNoRTtJQUVELElBQUksUUFBUSxHQUFHLENBQUMsRUFBRTtRQUNoQixRQUFRLEdBQUcsQ0FBQyxDQUFDO0tBQ2Q7SUFDRCxJQUFJLFFBQVEsR0FBRyxDQUFDLEVBQUU7UUFDaEIsUUFBUSxHQUFHLENBQUMsQ0FBQztLQUNkO0lBRUQsTUFBTSxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDcEQsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2xDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFckIsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUNyQixTQUFTLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxFQUN6QyxZQUFZLENBQUMsRUFBRSxFQUFFLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFbEQsTUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVyQyxPQUFPLE9BQU8sQ0FDSCxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMzQixHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQ2hELEtBQUssQ0FBTSxDQUFDO0FBQ3pCLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxRQUFRLEdBQUcsRUFBRSxDQUFDLEVBQUMsU0FBUyxFQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtUZW5zb3J9IGZyb20gJy4uLy4uL3RlbnNvcic7XG5pbXBvcnQge2NvbnZlcnRUb1RlbnNvcn0gZnJvbSAnLi4vLi4vdGVuc29yX3V0aWxfZW52JztcbmltcG9ydCB7VGVuc29yTGlrZX0gZnJvbSAnLi4vLi4vdHlwZXMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJy4uLy4uL3V0aWwnO1xuXG5pbXBvcnQge2dyZWF0ZXJFcXVhbH0gZnJvbSAnLi4vZ3JlYXRlcl9lcXVhbCc7XG5pbXBvcnQge2xlc3NFcXVhbH0gZnJvbSAnLi4vbGVzc19lcXVhbCc7XG5pbXBvcnQge2xvZ2ljYWxBbmR9IGZyb20gJy4uL2xvZ2ljYWxfYW5kJztcbmltcG9ydCB7b3B9IGZyb20gJy4uL29wZXJhdGlvbic7XG5pbXBvcnQge3JhbmdlfSBmcm9tICcuLi9yYW5nZSc7XG5pbXBvcnQge3Jlc2hhcGV9IGZyb20gJy4uL3Jlc2hhcGUnO1xuaW1wb3J0IHtzY2FsYXJ9IGZyb20gJy4uL3NjYWxhcic7XG5pbXBvcnQge3N0YWNrfSBmcm9tICcuLi9zdGFjayc7XG5pbXBvcnQge3N1Yn0gZnJvbSAnLi4vc3ViJztcbmltcG9ydCB7dW5zdGFja30gZnJvbSAnLi4vdW5zdGFjayc7XG5pbXBvcnQge3doZXJlfSBmcm9tICcuLi93aGVyZSc7XG5pbXBvcnQge3plcm9zfSBmcm9tICcuLi96ZXJvcyc7XG5cbi8qKlxuICogQ29weSBhIHRlbnNvciBzZXR0aW5nIGV2ZXJ5dGhpbmcgb3V0c2lkZSBhIGNlbnRyYWwgYmFuZCBpbiBlYWNoIGlubmVybW9zdFxuICogbWF0cml4IHRvIHplcm8uXG4gKlxuICogVGhlIGJhbmQgcGFydCBpcyBjb21wdXRlZCBhcyBmb2xsb3dzOiBBc3N1bWUgaW5wdXQgaGFzIGBrYCBkaW1lbnNpb25zXG4gKiBgW0ksIEosIEssIC4uLiwgTSwgTl1gLCB0aGVuIHRoZSBvdXRwdXQgaXMgYSB0ZW5zb3Igd2l0aCB0aGUgc2FtZSBzaGFwZSB3aGVyZVxuICogYGJhbmRbaSwgaiwgaywgLi4uLCBtLCBuXSA9IGluX2JhbmQobSwgbikgKiBpbnB1dFtpLCBqLCBrLCAuLi4sIG0sIG5dYC5cbiAqIFRoZSBpbmRpY2F0b3IgZnVuY3Rpb25cbiAqIGBpbl9iYW5kKG0sIG4pID0gKG51bV9sb3dlciA8IDAgfHwgKG0tbikgPD0gbnVtX2xvd2VyKWBcbiAqIGAmJiAobnVtX3VwcGVyIDwgMCB8fCAobi1tKSA8PSBudW1fdXBwZXIpYFxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCB4ID0gdGYudGVuc29yMmQoW1sgMCwgIDEsICAyLCAzXSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgWy0xLCAgMCwgIDEsIDJdLFxuICogICAgICAgICAgICAgICAgICAgICAgICBbLTIsIC0xLCAgMCwgMV0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFstMywgLTIsIC0xLCAwXV0pO1xuICogbGV0IHkgPSB0Zi5saW5hbGcuYmFuZFBhcnQoeCwgMSwgLTEpO1xuICogeS5wcmludCgpOyAvLyBbWyAwLCAgMSwgIDIsIDNdLFxuICogICAgICAgICAgICAvLyAgWy0xLCAgMCwgIDEsIDJdLFxuICogICAgICAgICAgICAvLyAgWyAwLCAtMSwgIDAsIDFdLFxuICogICAgICAgICAgICAvLyAgWyAwLCAwICwgLTEsIDBdXVxuICogbGV0IHogPSB0Zi5saW5hbGcuYmFuZFBhcnQoeCwgMiwgMSk7XG4gKiB6LnByaW50KCk7IC8vIFtbIDAsICAxLCAgMCwgMF0sXG4gKiAgICAgICAgICAgIC8vICBbLTEsICAwLCAgMSwgMF0sXG4gKiAgICAgICAgICAgIC8vICBbLTIsIC0xLCAgMCwgMV0sXG4gKiAgICAgICAgICAgIC8vICBbIDAsIC0yLCAtMSwgMF1dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0geCBSYW5rIGBrYCB0ZW5zb3JcbiAqIEBwYXJhbSBudW1Mb3dlciBOdW1iZXIgb2Ygc3ViZGlhZ29uYWxzIHRvIGtlZXAuXG4gKiAgIElmIG5lZ2F0aXZlLCBrZWVwIGVudGlyZSBsb3dlciB0cmlhbmdsZS5cbiAqIEBwYXJhbSBudW1VcHBlciBOdW1iZXIgb2Ygc3ViZGlhZ29uYWxzIHRvIGtlZXAuXG4gKiAgIElmIG5lZ2F0aXZlLCBrZWVwIGVudGlyZSB1cHBlciB0cmlhbmdsZS5cbiAqIEByZXR1cm5zIFJhbmsgYGtgIHRlbnNvciBvZiB0aGUgc2FtZSBzaGFwZSBhcyBpbnB1dC5cbiAqICAgVGhlIGV4dHJhY3RlZCBiYW5kZWQgdGVuc29yLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6J09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOidMaW5lYXIgQWxnZWJyYScsIG5hbWVzcGFjZTonbGluYWxnJ31cbiAqL1xuZnVuY3Rpb24gYmFuZFBhcnRfPFQgZXh0ZW5kcyBUZW5zb3I+KFxuICAgIGE6IFR8VGVuc29yTGlrZSwgbnVtTG93ZXI6IG51bWJlciwgbnVtVXBwZXI6IG51bWJlcik6IFQge1xuICBhc3NlcnQoXG4gICAgICBudW1Mb3dlciAlIDEgPT09IDAsXG4gICAgICAoKSA9PiBgYmFuZFBhcnQoKTogbnVtTG93ZXIgbXVzdCBiZSBhbiBpbnRlZ2VyLCBnb3QgJHtudW1Mb3dlcn0uYCk7XG4gIGFzc2VydChcbiAgICAgIG51bVVwcGVyICUgMSA9PT0gMCxcbiAgICAgICgpID0+IGBiYW5kUGFydCgpOiBudW1VcHBlciBtdXN0IGJlIGFuIGludGVnZXIsIGdvdCAke251bVVwcGVyfS5gKTtcblxuICBjb25zdCAkYSA9IGNvbnZlcnRUb1RlbnNvcihhLCAnYScsICdiYW5kUGFydCcpO1xuXG4gIGFzc2VydChcbiAgICAgICRhLnJhbmsgPj0gMixcbiAgICAgICgpID0+IGBiYW5kUGFydCgpOiBSYW5rIG11c3QgYmUgYXQgbGVhc3QgMiwgZ290ICR7JGEucmFua30uYCk7XG5cbiAgY29uc3Qgc2hhcGUgPSAkYS5zaGFwZTtcbiAgY29uc3QgW00sIE5dID0gJGEuc2hhcGUuc2xpY2UoLTIpO1xuXG4gIGlmICghKG51bUxvd2VyIDw9IE0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgYmFuZFBhcnQoKTogbnVtTG93ZXIgKCR7bnVtTG93ZXJ9KWAgK1xuICAgICAgICBgIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIHJvd3MgKCR7TX0pLmApO1xuICB9XG4gIGlmICghKG51bVVwcGVyIDw9IE4pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgYmFuZFBhcnQoKTogbnVtVXBwZXIgKCR7bnVtVXBwZXJ9KWAgK1xuICAgICAgICBgIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgKCR7Tn0pLmApO1xuICB9XG5cbiAgaWYgKG51bUxvd2VyIDwgMCkge1xuICAgIG51bUxvd2VyID0gTTtcbiAgfVxuICBpZiAobnVtVXBwZXIgPCAwKSB7XG4gICAgbnVtVXBwZXIgPSBOO1xuICB9XG5cbiAgY29uc3QgaSA9IHJlc2hhcGUocmFuZ2UoMCwgTSwgMSwgJ2ludDMyJyksIFstMSwgMV0pO1xuICBjb25zdCBqID0gcmFuZ2UoMCwgTiwgMSwgJ2ludDMyJyk7XG4gIGNvbnN0IGlqID0gc3ViKGksIGopO1xuXG4gIGNvbnN0IGluQmFuZCA9IGxvZ2ljYWxBbmQoXG4gICAgICBsZXNzRXF1YWwoaWosIHNjYWxhcigrbnVtTG93ZXIsICdpbnQzMicpKSxcbiAgICAgIGdyZWF0ZXJFcXVhbChpaiwgc2NhbGFyKC1udW1VcHBlciwgJ2ludDMyJykpKTtcblxuICBjb25zdCB6ZXJvID0gemVyb3MoW00sIE5dLCAkYS5kdHlwZSk7XG5cbiAgcmV0dXJuIHJlc2hhcGUoXG4gICAgICAgICAgICAgc3RhY2sodW5zdGFjayhyZXNoYXBlKCRhLCBbLTEsIE0sIE5dKSlcbiAgICAgICAgICAgICAgICAgICAgICAgLm1hcChtYXQgPT4gd2hlcmUoaW5CYW5kLCBtYXQsIHplcm8pKSksXG4gICAgICAgICAgICAgc2hhcGUpIGFzIFQ7XG59XG5cbmV4cG9ydCBjb25zdCBiYW5kUGFydCA9IG9wKHtiYW5kUGFydF99KTtcbiJdfQ==