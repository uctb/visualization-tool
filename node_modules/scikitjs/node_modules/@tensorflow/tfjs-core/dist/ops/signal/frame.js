/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { concat } from '../concat';
import { fill } from '../fill';
import { op } from '../operation';
import { reshape } from '../reshape';
import { slice } from '../slice';
import { tensor2d } from '../tensor2d';
/**
 * Expands input into frames of frameLength.
 * Slides a window size with frameStep.
 *
 * ```js
 * tf.signal.frame([1, 2, 3], 2, 1).print();
 * ```
 * @param signal The input tensor to be expanded
 * @param frameLength Length of each frame
 * @param frameStep The frame hop size in samples.
 * @param padEnd Whether to pad the end of signal with padValue.
 * @param padValue A number to use where the input signal does
 *     not exist when padEnd is True.
 *
 * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}
 */
function frame_(signal, frameLength, frameStep, padEnd = false, padValue = 0) {
    let start = 0;
    const output = [];
    while (start + frameLength <= signal.size) {
        output.push(slice(signal, start, frameLength));
        start += frameStep;
    }
    if (padEnd) {
        while (start < signal.size) {
            const padLen = (start + frameLength) - signal.size;
            const pad = concat([
                slice(signal, start, frameLength - padLen), fill([padLen], padValue)
            ]);
            output.push(pad);
            start += frameStep;
        }
    }
    if (output.length === 0) {
        return tensor2d([], [0, frameLength]);
    }
    return reshape(concat(output), [output.length, frameLength]);
}
export const frame = op({ frame_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJhbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL29wcy9zaWduYWwvZnJhbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBR0gsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sU0FBUyxDQUFDO0FBQzdCLE9BQU8sRUFBQyxFQUFFLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDaEMsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNuQyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQy9CLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFFckM7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBQ0gsU0FBUyxNQUFNLENBQ1gsTUFBZ0IsRUFBRSxXQUFtQixFQUFFLFNBQWlCLEVBQUUsTUFBTSxHQUFHLEtBQUssRUFDeEUsUUFBUSxHQUFHLENBQUM7SUFDZCxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDZCxNQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7SUFDNUIsT0FBTyxLQUFLLEdBQUcsV0FBVyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEVBQUU7UUFDekMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBQy9DLEtBQUssSUFBSSxTQUFTLENBQUM7S0FDcEI7SUFFRCxJQUFJLE1BQU0sRUFBRTtRQUNWLE9BQU8sS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLEVBQUU7WUFDMUIsTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQztZQUNuRCxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUM7Z0JBQ2pCLEtBQUssQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLFdBQVcsR0FBRyxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxRQUFRLENBQUM7YUFDckUsQ0FBQyxDQUFDO1lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQixLQUFLLElBQUksU0FBUyxDQUFDO1NBQ3BCO0tBQ0Y7SUFFRCxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3ZCLE9BQU8sUUFBUSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0tBQ3ZDO0lBRUQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDO0FBQy9ELENBQUM7QUFDRCxNQUFNLENBQUMsTUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDLEVBQUMsTUFBTSxFQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtUZW5zb3IsIFRlbnNvcjFEfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtjb25jYXR9IGZyb20gJy4uL2NvbmNhdCc7XG5pbXBvcnQge2ZpbGx9IGZyb20gJy4uL2ZpbGwnO1xuaW1wb3J0IHtvcH0gZnJvbSAnLi4vb3BlcmF0aW9uJztcbmltcG9ydCB7cmVzaGFwZX0gZnJvbSAnLi4vcmVzaGFwZSc7XG5pbXBvcnQge3NsaWNlfSBmcm9tICcuLi9zbGljZSc7XG5pbXBvcnQge3RlbnNvcjJkfSBmcm9tICcuLi90ZW5zb3IyZCc7XG5cbi8qKlxuICogRXhwYW5kcyBpbnB1dCBpbnRvIGZyYW1lcyBvZiBmcmFtZUxlbmd0aC5cbiAqIFNsaWRlcyBhIHdpbmRvdyBzaXplIHdpdGggZnJhbWVTdGVwLlxuICpcbiAqIGBgYGpzXG4gKiB0Zi5zaWduYWwuZnJhbWUoWzEsIDIsIDNdLCAyLCAxKS5wcmludCgpO1xuICogYGBgXG4gKiBAcGFyYW0gc2lnbmFsIFRoZSBpbnB1dCB0ZW5zb3IgdG8gYmUgZXhwYW5kZWRcbiAqIEBwYXJhbSBmcmFtZUxlbmd0aCBMZW5ndGggb2YgZWFjaCBmcmFtZVxuICogQHBhcmFtIGZyYW1lU3RlcCBUaGUgZnJhbWUgaG9wIHNpemUgaW4gc2FtcGxlcy5cbiAqIEBwYXJhbSBwYWRFbmQgV2hldGhlciB0byBwYWQgdGhlIGVuZCBvZiBzaWduYWwgd2l0aCBwYWRWYWx1ZS5cbiAqIEBwYXJhbSBwYWRWYWx1ZSBBIG51bWJlciB0byB1c2Ugd2hlcmUgdGhlIGlucHV0IHNpZ25hbCBkb2VzXG4gKiAgICAgbm90IGV4aXN0IHdoZW4gcGFkRW5kIGlzIFRydWUuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnU2lnbmFsJywgbmFtZXNwYWNlOiAnc2lnbmFsJ31cbiAqL1xuZnVuY3Rpb24gZnJhbWVfKFxuICAgIHNpZ25hbDogVGVuc29yMUQsIGZyYW1lTGVuZ3RoOiBudW1iZXIsIGZyYW1lU3RlcDogbnVtYmVyLCBwYWRFbmQgPSBmYWxzZSxcbiAgICBwYWRWYWx1ZSA9IDApOiBUZW5zb3Ige1xuICBsZXQgc3RhcnQgPSAwO1xuICBjb25zdCBvdXRwdXQ6IFRlbnNvcltdID0gW107XG4gIHdoaWxlIChzdGFydCArIGZyYW1lTGVuZ3RoIDw9IHNpZ25hbC5zaXplKSB7XG4gICAgb3V0cHV0LnB1c2goc2xpY2Uoc2lnbmFsLCBzdGFydCwgZnJhbWVMZW5ndGgpKTtcbiAgICBzdGFydCArPSBmcmFtZVN0ZXA7XG4gIH1cblxuICBpZiAocGFkRW5kKSB7XG4gICAgd2hpbGUgKHN0YXJ0IDwgc2lnbmFsLnNpemUpIHtcbiAgICAgIGNvbnN0IHBhZExlbiA9IChzdGFydCArIGZyYW1lTGVuZ3RoKSAtIHNpZ25hbC5zaXplO1xuICAgICAgY29uc3QgcGFkID0gY29uY2F0KFtcbiAgICAgICAgc2xpY2Uoc2lnbmFsLCBzdGFydCwgZnJhbWVMZW5ndGggLSBwYWRMZW4pLCBmaWxsKFtwYWRMZW5dLCBwYWRWYWx1ZSlcbiAgICAgIF0pO1xuICAgICAgb3V0cHV0LnB1c2gocGFkKTtcbiAgICAgIHN0YXJ0ICs9IGZyYW1lU3RlcDtcbiAgICB9XG4gIH1cblxuICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0ZW5zb3IyZChbXSwgWzAsIGZyYW1lTGVuZ3RoXSk7XG4gIH1cblxuICByZXR1cm4gcmVzaGFwZShjb25jYXQob3V0cHV0KSwgW291dHB1dC5sZW5ndGgsIGZyYW1lTGVuZ3RoXSk7XG59XG5leHBvcnQgY29uc3QgZnJhbWUgPSBvcCh7ZnJhbWVffSk7XG4iXX0=