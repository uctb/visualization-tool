/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { ENGINE } from '../../engine';
import { Transform } from '../../kernel_names';
import { convertToTensor } from '../../tensor_util_env';
import * as util from '../../util';
import { op } from '../operation';
/**
 * Applies the given transform(s) to the image(s).
 *
 * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.
 * @param transforms Projective transform matrix/matrices. A tensor1d of length
 *     8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0,
 *     b1, b2, c0, c1], then it maps the output point (x, y) to a transformed
 *     input point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k),
 *     where k = c0 x + c1 y + 1. The transforms are inverted compared to the
 *     transform mapping input points to output points.
 * @param interpolation Interpolation mode.
 *     Supported values: 'nearest', 'bilinear'. Default to 'nearest'.
 * @param fillMode Points outside the boundaries of the input are filled
 *     according to the given mode, one of 'constant', 'reflect', 'wrap',
 *     'nearest'. Default to 'constant'.
 *     'reflect': (d c b a | a b c d | d c b a ) The input is extended by
 *     reflecting about the edge of the last pixel.
 *     'constant': (k k k k | a b c d | k k k k) The input is extended by
 *     filling all values beyond the edge with the same constant value k.
 *     'wrap': (a b c d | a b c d | a b c d) The input is extended by
 *     wrapping around to the opposite edge.
 *     'nearest': (a a a a | a b c d | d d d d) The input is extended by
 *     the nearest pixel.
 * @param fillValue A float represents the value to be filled outside the
 *     boundaries when fillMode is 'constant'.
 * @param Output dimension after the transform, [height, width]. If undefined,
 *     output is the same size as input image.
 *
 * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}
 */
function transform_(image, transforms, interpolation = 'nearest', fillMode = 'constant', fillValue = 0, outputShape) {
    const $image = convertToTensor(image, 'image', 'transform', 'float32');
    const $transforms = convertToTensor(transforms, 'transforms', 'transform', 'float32');
    util.assert($image.rank === 4, () => 'Error in transform: image must be rank 4,' +
        `but got rank ${$image.rank}.`);
    util.assert($transforms.rank === 2 &&
        ($transforms.shape[0] === $image.shape[0] ||
            $transforms.shape[0] === 1) &&
        $transforms.shape[1] === 8, () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);
    util.assert(outputShape == null || outputShape.length === 2, () => 'Error in transform: outputShape must be [height, width] or null, ' +
        `but got ${outputShape}.`);
    const inputs = { image: $image, transforms: $transforms };
    const attrs = { interpolation, fillMode, fillValue, outputShape };
    return ENGINE.runKernel(Transform, inputs, attrs);
}
export const transform = op({ transform_ });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNmb3JtLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1jb3JlL3NyYy9vcHMvaW1hZ2UvdHJhbnNmb3JtLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDcEMsT0FBTyxFQUFDLFNBQVMsRUFBa0MsTUFBTSxvQkFBb0IsQ0FBQztBQUk5RSxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxLQUFLLElBQUksTUFBTSxZQUFZLENBQUM7QUFFbkMsT0FBTyxFQUFDLEVBQUUsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUVoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2Qkc7QUFDSCxTQUFTLFVBQVUsQ0FDZixLQUEwQixFQUFFLFVBQStCLEVBQzNELGdCQUFzQyxTQUFTLEVBQy9DLFdBQWtELFVBQVUsRUFBRSxTQUFTLEdBQUcsQ0FBQyxFQUMzRSxXQUE4QjtJQUNoQyxNQUFNLE1BQU0sR0FBRyxlQUFlLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDdkUsTUFBTSxXQUFXLEdBQ2IsZUFBZSxDQUFDLFVBQVUsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBRXRFLElBQUksQ0FBQyxNQUFNLENBQ1AsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLEVBQ2pCLEdBQUcsRUFBRSxDQUFDLDJDQUEyQztRQUM3QyxnQkFBZ0IsTUFBTSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7SUFFeEMsSUFBSSxDQUFDLE1BQU0sQ0FDUCxXQUFXLENBQUMsSUFBSSxLQUFLLENBQUM7UUFDbEIsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzVCLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUM5QixHQUFHLEVBQUUsQ0FBQyxrRUFBa0UsQ0FBQyxDQUFDO0lBRTlFLElBQUksQ0FBQyxNQUFNLENBQ1AsV0FBVyxJQUFJLElBQUksSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFDL0MsR0FBRyxFQUFFLENBQ0QsbUVBQW1FO1FBQ25FLFdBQVcsV0FBVyxHQUFHLENBQUMsQ0FBQztJQUVuQyxNQUFNLE1BQU0sR0FBb0IsRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUMsQ0FBQztJQUN6RSxNQUFNLEtBQUssR0FDVSxFQUFDLGFBQWEsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBQyxDQUFDO0lBRXZFLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FDbkIsU0FBUyxFQUFFLE1BQThCLEVBQUUsS0FBMkIsQ0FBQyxDQUFDO0FBQzlFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxTQUFTLEdBQUcsRUFBRSxDQUFDLEVBQUMsVUFBVSxFQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbmltcG9ydCB7RU5HSU5FfSBmcm9tICcuLi8uLi9lbmdpbmUnO1xuaW1wb3J0IHtUcmFuc2Zvcm0sIFRyYW5zZm9ybUF0dHJzLCBUcmFuc2Zvcm1JbnB1dHN9IGZyb20gJy4uLy4uL2tlcm5lbF9uYW1lcyc7XG5pbXBvcnQge05hbWVkQXR0ck1hcH0gZnJvbSAnLi4vLi4va2VybmVsX3JlZ2lzdHJ5JztcbmltcG9ydCB7VGVuc29yMkQsIFRlbnNvcjREfSBmcm9tICcuLi8uLi90ZW5zb3InO1xuaW1wb3J0IHtOYW1lZFRlbnNvck1hcH0gZnJvbSAnLi4vLi4vdGVuc29yX3R5cGVzJztcbmltcG9ydCB7Y29udmVydFRvVGVuc29yfSBmcm9tICcuLi8uLi90ZW5zb3JfdXRpbF9lbnYnO1xuaW1wb3J0IHtUZW5zb3JMaWtlfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4uLy4uL3V0aWwnO1xuXG5pbXBvcnQge29wfSBmcm9tICcuLi9vcGVyYXRpb24nO1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGdpdmVuIHRyYW5zZm9ybShzKSB0byB0aGUgaW1hZ2UocykuXG4gKlxuICogQHBhcmFtIGltYWdlIDRkIHRlbnNvciBvZiBzaGFwZSBgW2JhdGNoLCBpbWFnZUhlaWdodCwgaW1hZ2VXaWR0aCwgZGVwdGhdYC5cbiAqIEBwYXJhbSB0cmFuc2Zvcm1zIFByb2plY3RpdmUgdHJhbnNmb3JtIG1hdHJpeC9tYXRyaWNlcy4gQSB0ZW5zb3IxZCBvZiBsZW5ndGhcbiAqICAgICA4IG9yIHRlbnNvciBvZiBzaXplIE4geCA4LiBJZiBvbmUgcm93IG9mIHRyYW5zZm9ybXMgaXMgW2EwLCBhMSwgYTIsIGIwLFxuICogICAgIGIxLCBiMiwgYzAsIGMxXSwgdGhlbiBpdCBtYXBzIHRoZSBvdXRwdXQgcG9pbnQgKHgsIHkpIHRvIGEgdHJhbnNmb3JtZWRcbiAqICAgICBpbnB1dCBwb2ludCAoeCcsIHknKSA9ICgoYTAgeCArIGExIHkgKyBhMikgLyBrLCAoYjAgeCArIGIxIHkgKyBiMikgLyBrKSxcbiAqICAgICB3aGVyZSBrID0gYzAgeCArIGMxIHkgKyAxLiBUaGUgdHJhbnNmb3JtcyBhcmUgaW52ZXJ0ZWQgY29tcGFyZWQgdG8gdGhlXG4gKiAgICAgdHJhbnNmb3JtIG1hcHBpbmcgaW5wdXQgcG9pbnRzIHRvIG91dHB1dCBwb2ludHMuXG4gKiBAcGFyYW0gaW50ZXJwb2xhdGlvbiBJbnRlcnBvbGF0aW9uIG1vZGUuXG4gKiAgICAgU3VwcG9ydGVkIHZhbHVlczogJ25lYXJlc3QnLCAnYmlsaW5lYXInLiBEZWZhdWx0IHRvICduZWFyZXN0Jy5cbiAqIEBwYXJhbSBmaWxsTW9kZSBQb2ludHMgb3V0c2lkZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgaW5wdXQgYXJlIGZpbGxlZFxuICogICAgIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gbW9kZSwgb25lIG9mICdjb25zdGFudCcsICdyZWZsZWN0JywgJ3dyYXAnLFxuICogICAgICduZWFyZXN0Jy4gRGVmYXVsdCB0byAnY29uc3RhbnQnLlxuICogICAgICdyZWZsZWN0JzogKGQgYyBiIGEgfCBhIGIgYyBkIHwgZCBjIGIgYSApIFRoZSBpbnB1dCBpcyBleHRlbmRlZCBieVxuICogICAgIHJlZmxlY3RpbmcgYWJvdXQgdGhlIGVkZ2Ugb2YgdGhlIGxhc3QgcGl4ZWwuXG4gKiAgICAgJ2NvbnN0YW50JzogKGsgayBrIGsgfCBhIGIgYyBkIHwgayBrIGsgaykgVGhlIGlucHV0IGlzIGV4dGVuZGVkIGJ5XG4gKiAgICAgZmlsbGluZyBhbGwgdmFsdWVzIGJleW9uZCB0aGUgZWRnZSB3aXRoIHRoZSBzYW1lIGNvbnN0YW50IHZhbHVlIGsuXG4gKiAgICAgJ3dyYXAnOiAoYSBiIGMgZCB8IGEgYiBjIGQgfCBhIGIgYyBkKSBUaGUgaW5wdXQgaXMgZXh0ZW5kZWQgYnlcbiAqICAgICB3cmFwcGluZyBhcm91bmQgdG8gdGhlIG9wcG9zaXRlIGVkZ2UuXG4gKiAgICAgJ25lYXJlc3QnOiAoYSBhIGEgYSB8IGEgYiBjIGQgfCBkIGQgZCBkKSBUaGUgaW5wdXQgaXMgZXh0ZW5kZWQgYnlcbiAqICAgICB0aGUgbmVhcmVzdCBwaXhlbC5cbiAqIEBwYXJhbSBmaWxsVmFsdWUgQSBmbG9hdCByZXByZXNlbnRzIHRoZSB2YWx1ZSB0byBiZSBmaWxsZWQgb3V0c2lkZSB0aGVcbiAqICAgICBib3VuZGFyaWVzIHdoZW4gZmlsbE1vZGUgaXMgJ2NvbnN0YW50Jy5cbiAqIEBwYXJhbSBPdXRwdXQgZGltZW5zaW9uIGFmdGVyIHRoZSB0cmFuc2Zvcm0sIFtoZWlnaHQsIHdpZHRoXS4gSWYgdW5kZWZpbmVkLFxuICogICAgIG91dHB1dCBpcyB0aGUgc2FtZSBzaXplIGFzIGlucHV0IGltYWdlLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0ltYWdlcycsIG5hbWVzcGFjZTogJ2ltYWdlJ31cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtXyhcbiAgICBpbWFnZTogVGVuc29yNER8VGVuc29yTGlrZSwgdHJhbnNmb3JtczogVGVuc29yMkR8VGVuc29yTGlrZSxcbiAgICBpbnRlcnBvbGF0aW9uOiAnbmVhcmVzdCd8J2JpbGluZWFyJyA9ICduZWFyZXN0JyxcbiAgICBmaWxsTW9kZTogJ2NvbnN0YW50J3wncmVmbGVjdCd8J3dyYXAnfCduZWFyZXN0JyA9ICdjb25zdGFudCcsIGZpbGxWYWx1ZSA9IDAsXG4gICAgb3V0cHV0U2hhcGU/OiBbbnVtYmVyLCBudW1iZXJdKTogVGVuc29yNEQge1xuICBjb25zdCAkaW1hZ2UgPSBjb252ZXJ0VG9UZW5zb3IoaW1hZ2UsICdpbWFnZScsICd0cmFuc2Zvcm0nLCAnZmxvYXQzMicpO1xuICBjb25zdCAkdHJhbnNmb3JtcyA9XG4gICAgICBjb252ZXJ0VG9UZW5zb3IodHJhbnNmb3JtcywgJ3RyYW5zZm9ybXMnLCAndHJhbnNmb3JtJywgJ2Zsb2F0MzInKTtcblxuICB1dGlsLmFzc2VydChcbiAgICAgICRpbWFnZS5yYW5rID09PSA0LFxuICAgICAgKCkgPT4gJ0Vycm9yIGluIHRyYW5zZm9ybTogaW1hZ2UgbXVzdCBiZSByYW5rIDQsJyArXG4gICAgICAgICAgYGJ1dCBnb3QgcmFuayAkeyRpbWFnZS5yYW5rfS5gKTtcblxuICB1dGlsLmFzc2VydChcbiAgICAgICR0cmFuc2Zvcm1zLnJhbmsgPT09IDIgJiZcbiAgICAgICAgICAoJHRyYW5zZm9ybXMuc2hhcGVbMF0gPT09ICRpbWFnZS5zaGFwZVswXSB8fFxuICAgICAgICAgICAkdHJhbnNmb3Jtcy5zaGFwZVswXSA9PT0gMSkgJiZcbiAgICAgICAgICAkdHJhbnNmb3Jtcy5zaGFwZVsxXSA9PT0gOCxcbiAgICAgICgpID0+IGBFcnJvciBpbiB0cmFuc2Zvcm06IElucHV0IHRyYW5zZm9ybSBzaG91bGQgYmUgYmF0Y2ggeCA4IG9yIDEgeCA4YCk7XG5cbiAgdXRpbC5hc3NlcnQoXG4gICAgICBvdXRwdXRTaGFwZSA9PSBudWxsIHx8IG91dHB1dFNoYXBlLmxlbmd0aCA9PT0gMixcbiAgICAgICgpID0+XG4gICAgICAgICAgJ0Vycm9yIGluIHRyYW5zZm9ybTogb3V0cHV0U2hhcGUgbXVzdCBiZSBbaGVpZ2h0LCB3aWR0aF0gb3IgbnVsbCwgJyArXG4gICAgICAgICAgYGJ1dCBnb3QgJHtvdXRwdXRTaGFwZX0uYCk7XG5cbiAgY29uc3QgaW5wdXRzOiBUcmFuc2Zvcm1JbnB1dHMgPSB7aW1hZ2U6ICRpbWFnZSwgdHJhbnNmb3JtczogJHRyYW5zZm9ybXN9O1xuICBjb25zdCBhdHRyczpcbiAgICAgIFRyYW5zZm9ybUF0dHJzID0ge2ludGVycG9sYXRpb24sIGZpbGxNb2RlLCBmaWxsVmFsdWUsIG91dHB1dFNoYXBlfTtcblxuICByZXR1cm4gRU5HSU5FLnJ1bktlcm5lbChcbiAgICAgIFRyYW5zZm9ybSwgaW5wdXRzIGFzIHt9IGFzIE5hbWVkVGVuc29yTWFwLCBhdHRycyBhcyB7fSBhcyBOYW1lZEF0dHJNYXApO1xufVxuXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtID0gb3Aoe3RyYW5zZm9ybV99KTtcbiJdfQ==