/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
import { complex } from '../ops/complex';
import { tensor } from '../ops/tensor';
import { sizeFromShape } from '../util';
import { DTYPE_VALUE_SIZE_MAP } from './types';
/** Number of bytes reserved for the length of the string. (32bit integer). */
const NUM_BYTES_STRING_LENGTH = 4;
/**
 * Encode a map from names to weight values as an ArrayBuffer, along with an
 * `Array` of `WeightsManifestEntry` as specification of the encoded weights.
 *
 * This function does not perform sharding.
 *
 * This function is the reverse of `decodeWeights`.
 *
 * @param tensors A map ("dict") from names to tensors.
 * @param group Group to which the weights belong (optional).
 * @returns A `Promise` of
 *   - A flat `ArrayBuffer` with all the binary values of the `Tensor`s
 *     concatenated.
 *   - An `Array` of `WeightManifestEntry`s, carrying information including
 *     tensor names, `dtype`s and shapes.
 * @throws Error: on unsupported tensor `dtype`.
 */
export async function encodeWeights(tensors, group) {
    // TODO(adarob, cais): Support quantization.
    const specs = [];
    const dataPromises = [];
    const names = Array.isArray(tensors) ?
        tensors.map(tensor => tensor.name) :
        Object.keys(tensors);
    for (let i = 0; i < names.length; ++i) {
        const name = names[i];
        const t = Array.isArray(tensors) ? tensors[i].tensor : tensors[name];
        if (t.dtype !== 'float32' && t.dtype !== 'int32' && t.dtype !== 'bool' &&
            t.dtype !== 'string' && t.dtype !== 'complex64') {
            throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);
        }
        const spec = { name, shape: t.shape, dtype: t.dtype };
        if (t.dtype === 'string') {
            const utf8bytes = new Promise(async (resolve) => {
                const vals = await t.bytes();
                const totalNumBytes = vals.reduce((p, c) => p + c.length, 0) +
                    NUM_BYTES_STRING_LENGTH * vals.length;
                const bytes = new Uint8Array(totalNumBytes);
                let offset = 0;
                for (let i = 0; i < vals.length; i++) {
                    const val = vals[i];
                    const bytesOfLength = new Uint8Array(new Uint32Array([val.length]).buffer);
                    bytes.set(bytesOfLength, offset);
                    offset += NUM_BYTES_STRING_LENGTH;
                    bytes.set(val, offset);
                    offset += val.length;
                }
                resolve(bytes);
            });
            dataPromises.push(utf8bytes);
        }
        else {
            dataPromises.push(t.data());
        }
        if (group != null) {
            spec.group = group;
        }
        specs.push(spec);
    }
    const tensorValues = await Promise.all(dataPromises);
    return { data: concatenateTypedArrays(tensorValues), specs };
}
/**
 * Decode flat ArrayBuffer as weights.
 *
 * This function does not handle sharding.
 *
 * This function is the reverse of `encodeWeights`.
 *
 * @param buffer A flat ArrayBuffer carrying the binary values of the tensors
 *   concatenated in the order specified in `specs`.
 * @param specs Specifications of the names, dtypes and shapes of the tensors
 *   whose value are encoded by `buffer`.
 * @return A map from tensor name to tensor value, with the names corresponding
 *   to names in `specs`.
 * @throws Error, if any of the tensors has unsupported dtype.
 */
export function decodeWeights(buffer, specs) {
    // TODO(adarob, cais): Support quantization.
    const out = {};
    let float16Decode;
    let offset = 0;
    for (const spec of specs) {
        const name = spec.name;
        const dtype = spec.dtype;
        const shape = spec.shape;
        const size = sizeFromShape(shape);
        let values;
        if ('quantization' in spec) {
            const quantization = spec.quantization;
            if (quantization.dtype === 'uint8' || quantization.dtype === 'uint16') {
                if (!('min' in quantization && 'scale' in quantization)) {
                    throw new Error(`Weight ${spec.name} with quantization ${quantization.dtype} ` +
                        `doesn't have corresponding metadata min and scale.`);
                }
            }
            else if (quantization.dtype === 'float16') {
                if (dtype !== 'float32') {
                    throw new Error(`Weight ${spec.name} is quantized with ${quantization.dtype} ` +
                        `which only supports weights of type float32 not ${dtype}.`);
                }
            }
            else {
                throw new Error(`Weight ${spec.name} has unknown ` +
                    `quantization dtype ${quantization.dtype}. ` +
                    `Supported quantization dtypes are: ` +
                    `'uint8', 'uint16', and 'float16'.`);
            }
            const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];
            const byteBuffer = buffer.slice(offset, offset + size * quantizationSizeFactor);
            const quantizedArray = (quantization.dtype === 'uint8') ?
                new Uint8Array(byteBuffer) :
                new Uint16Array(byteBuffer);
            if (dtype === 'float32') {
                if (quantization.dtype === 'uint8' || quantization.dtype === 'uint16') {
                    values = new Float32Array(quantizedArray.length);
                    for (let i = 0; i < quantizedArray.length; i++) {
                        const v = quantizedArray[i];
                        values[i] = v * quantization.scale + quantization.min;
                    }
                }
                else if (quantization.dtype === 'float16') {
                    if (float16Decode === undefined) {
                        float16Decode = getFloat16Decoder();
                    }
                    values = float16Decode(quantizedArray);
                }
                else {
                    throw new Error(`Unsupported quantization type ${quantization.dtype} ` +
                        `for weight type float32.`);
                }
            }
            else if (dtype === 'int32') {
                if (quantization.dtype !== 'uint8' && quantization.dtype !== 'uint16') {
                    throw new Error(`Unsupported quantization type ${quantization.dtype} ` +
                        `for weight type int32.`);
                }
                values = new Int32Array(quantizedArray.length);
                for (let i = 0; i < quantizedArray.length; i++) {
                    const v = quantizedArray[i];
                    values[i] = Math.round(v * quantization.scale + quantization.min);
                }
            }
            else {
                throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
            }
            offset += size * quantizationSizeFactor;
        }
        else if (dtype === 'string') {
            const size = sizeFromShape(spec.shape);
            values = [];
            for (let i = 0; i < size; i++) {
                const byteLength = new Uint32Array(buffer.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];
                offset += NUM_BYTES_STRING_LENGTH;
                const bytes = new Uint8Array(buffer.slice(offset, offset + byteLength));
                values.push(bytes);
                offset += byteLength;
            }
        }
        else {
            const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];
            const byteBuffer = buffer.slice(offset, offset + size * dtypeFactor);
            if (dtype === 'float32') {
                values = new Float32Array(byteBuffer);
            }
            else if (dtype === 'int32') {
                values = new Int32Array(byteBuffer);
            }
            else if (dtype === 'bool') {
                values = new Uint8Array(byteBuffer);
            }
            else if (dtype === 'complex64') {
                values = new Float32Array(byteBuffer);
                const real = new Float32Array(values.length / 2);
                const image = new Float32Array(values.length / 2);
                for (let i = 0; i < real.length; i++) {
                    real[i] = values[i * 2];
                    image[i] = values[i * 2 + 1];
                }
                const realTensor = tensor(real, shape, 'float32');
                const imageTensor = tensor(image, shape, 'float32');
                out[name] = complex(realTensor, imageTensor);
                realTensor.dispose();
                imageTensor.dispose();
            }
            else {
                throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);
            }
            offset += size * dtypeFactor;
        }
        if (dtype !== 'complex64') {
            out[name] = tensor(values, shape, dtype);
        }
    }
    return out;
}
/**
 * Concatenate TypedArrays into an ArrayBuffer.
 */
export function concatenateTypedArrays(xs) {
    // TODO(adarob, cais): Support quantization.
    if (xs === null) {
        throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);
    }
    let totalByteLength = 0;
    // `normalizedXs` is here for this reason: a `TypedArray`'s `buffer'
    // can have a different byte length from that of the `TypedArray` itself,
    // for example, when the `TypedArray` is created from an offset in an
    // `ArrayBuffer`. `normliazedXs` holds `TypedArray`s whose `buffer`s match
    // the `TypedArray` in byte length. If an element of `xs` does not show
    // this property, a new `TypedArray` that satisfy this property will be
    // constructed and pushed into `normalizedXs`.
    const normalizedXs = [];
    xs.forEach((x) => {
        totalByteLength += x.byteLength;
        // tslint:disable:no-any
        normalizedXs.push(x.byteLength === x.buffer.byteLength ? x :
            new x.constructor(x));
        if (!(x instanceof Float32Array || x instanceof Int32Array ||
            x instanceof Uint8Array)) {
            throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`);
        }
        // tslint:enable:no-any
    });
    const y = new Uint8Array(totalByteLength);
    let offset = 0;
    normalizedXs.forEach((x) => {
        y.set(new Uint8Array(x.buffer), offset);
        offset += x.byteLength;
    });
    return y.buffer;
}
// Use Buffer on Node.js instead of Blob/atob/btoa
const useNodeBuffer = typeof Buffer !== 'undefined' &&
    (typeof Blob === 'undefined' || typeof atob === 'undefined' ||
        typeof btoa === 'undefined');
/**
 * Calculate the byte length of a JavaScript string.
 *
 * Note that a JavaScript string can contain wide characters, therefore the
 * length of the string is not necessarily equal to the byte length.
 *
 * @param str Input string.
 * @returns Byte length.
 */
export function stringByteLength(str) {
    if (useNodeBuffer) {
        return Buffer.byteLength(str);
    }
    return new Blob([str]).size;
}
/**
 * Encode an ArrayBuffer as a base64 encoded string.
 *
 * @param buffer `ArrayBuffer` to be converted.
 * @returns A string that base64-encodes `buffer`.
 */
export function arrayBufferToBase64String(buffer) {
    if (useNodeBuffer) {
        return Buffer.from(buffer).toString('base64');
    }
    const buf = new Uint8Array(buffer);
    let s = '';
    for (let i = 0, l = buf.length; i < l; i++) {
        s += String.fromCharCode(buf[i]);
    }
    return btoa(s);
}
/**
 * Decode a base64 string as an ArrayBuffer.
 *
 * @param str Base64 string.
 * @returns Decoded `ArrayBuffer`.
 */
export function base64StringToArrayBuffer(str) {
    if (useNodeBuffer) {
        const buf = Buffer.from(str, 'base64');
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    const s = atob(str);
    const buffer = new Uint8Array(s.length);
    for (let i = 0; i < s.length; ++i) {
        buffer.set([s.charCodeAt(i)], i);
    }
    return buffer.buffer;
}
/**
 * Concatenate a number of ArrayBuffers into one.
 *
 * @param buffers A number of array buffers to concatenate.
 * @returns Result of concatenating `buffers` in order.
 */
export function concatenateArrayBuffers(buffers) {
    if (buffers.length === 1) {
        return buffers[0];
    }
    let totalByteLength = 0;
    buffers.forEach((buffer) => {
        totalByteLength += buffer.byteLength;
    });
    const temp = new Uint8Array(totalByteLength);
    let offset = 0;
    buffers.forEach((buffer) => {
        temp.set(new Uint8Array(buffer), offset);
        offset += buffer.byteLength;
    });
    return temp.buffer;
}
/**
 * Get the basename of a path.
 *
 * Behaves in a way analogous to Linux's basename command.
 *
 * @param path
 */
export function basename(path) {
    const SEPARATOR = '/';
    path = path.trim();
    while (path.endsWith(SEPARATOR)) {
        path = path.slice(0, path.length - 1);
    }
    const items = path.split(SEPARATOR);
    return items[items.length - 1];
}
/**
 * Create `ModelJSON` from `ModelArtifacts`.
 *
 * @param artifacts Model artifacts, describing the model and its weights.
 * @param manifest Weight manifest, describing where the weights of the
 *     `ModelArtifacts` are stored, and some metadata about them.
 * @returns Object representing the `model.json` file describing the model
 *     artifacts and weights
 */
export function getModelJSONForModelArtifacts(artifacts, manifest) {
    const result = {
        modelTopology: artifacts.modelTopology,
        format: artifacts.format,
        generatedBy: artifacts.generatedBy,
        convertedBy: artifacts.convertedBy,
        weightsManifest: manifest
    };
    if (artifacts.signature != null) {
        result.signature = artifacts.signature;
    }
    if (artifacts.userDefinedMetadata != null) {
        result.userDefinedMetadata = artifacts.userDefinedMetadata;
    }
    if (artifacts.modelInitializer != null) {
        result.modelInitializer = artifacts.modelInitializer;
    }
    if (artifacts.trainingConfig != null) {
        result.trainingConfig = artifacts.trainingConfig;
    }
    return result;
}
/**
 * Create `ModelArtifacts` from a JSON file and weights.
 *
 * @param modelJSON Object containing the parsed JSON of `model.json`
 * @param weightSpecs The list of WeightsManifestEntry for the model. Must be
 *     passed if the modelJSON has a weightsManifest.
 * @param weightData An ArrayBuffer of weight data for the model corresponding
 *     to the weights in weightSpecs. Must be passed if the modelJSON has a
 *     weightsManifest.
 * @returns A Promise of the `ModelArtifacts`, as described by the JSON file.
 */
export function getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData) {
    const modelArtifacts = {
        modelTopology: modelJSON.modelTopology,
        format: modelJSON.format,
        generatedBy: modelJSON.generatedBy,
        convertedBy: modelJSON.convertedBy
    };
    if (modelJSON.trainingConfig != null) {
        modelArtifacts.trainingConfig = modelJSON.trainingConfig;
    }
    if (modelJSON.weightsManifest != null) {
        if (!weightSpecs) {
            throw new Error('modelJSON has weightsManifest but weightSpecs is null');
        }
        if (!weightData) {
            throw new Error('modelJSON has weightsManifest but weightData is null');
        }
        modelArtifacts.weightSpecs = weightSpecs;
        modelArtifacts.weightData = weightData;
    }
    if (modelJSON.signature != null) {
        modelArtifacts.signature = modelJSON.signature;
    }
    if (modelJSON.userDefinedMetadata != null) {
        modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;
    }
    if (modelJSON.modelInitializer != null) {
        modelArtifacts.modelInitializer = modelJSON.modelInitializer;
    }
    return modelArtifacts;
}
/**
 * Create `ModelArtifacts` from a JSON file.
 *
 * @param modelJSON Object containing the parsed JSON of `model.json`
 * @param loadWeights Function that takes the JSON file's weights manifest,
 *     reads weights from the listed path(s), and returns a Promise of the
 *     weight manifest entries along with the weights data.
 * @returns A Promise of the `ModelArtifacts`, as described by the JSON file.
 */
export async function getModelArtifactsForJSON(modelJSON, loadWeights) {
    let weightSpecs;
    let weightData;
    if (modelJSON.weightsManifest != null) {
        [weightSpecs, weightData] = await loadWeights(modelJSON.weightsManifest);
    }
    return getModelArtifactsForJSONSync(modelJSON, weightSpecs, weightData);
}
/**
 * Populate ModelArtifactsInfo fields for a model with JSON topology.
 * @param modelArtifacts
 * @returns A ModelArtifactsInfo object.
 */
export function getModelArtifactsInfoForJSON(modelArtifacts) {
    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {
        throw new Error('Expected JSON model topology, received ArrayBuffer.');
    }
    return {
        dateSaved: new Date(),
        modelTopologyType: 'JSON',
        modelTopologyBytes: modelArtifacts.modelTopology == null ?
            0 :
            stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),
        weightSpecsBytes: modelArtifacts.weightSpecs == null ?
            0 :
            stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),
        weightDataBytes: modelArtifacts.weightData == null ?
            0 :
            modelArtifacts.weightData.byteLength,
    };
}
/**
 * Concatenate the weights stored in a WeightsManifestConfig into a list of
 * WeightsManifestEntry
 *
 * @param weightsManifest The WeightsManifestConfig to extract weights from.
 * @returns A list of WeightsManifestEntry of the weights in the weightsManifest
 */
export function getWeightSpecs(weightsManifest) {
    const weightSpecs = [];
    for (const entry of weightsManifest) {
        weightSpecs.push(...entry.weights);
    }
    return weightSpecs;
}
/**
 * Computes mantisa table for casting Float16 to Float32
 * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
 *
 * @returns Uint32Array, 2048 mantissa lookup values.
 */
function computeFloat16MantisaTable() {
    const convertMantissa = (i) => {
        let m = i << 13;
        let e = 0;
        while ((m & 0x00800000) === 0) {
            e -= 0x00800000;
            m <<= 1;
        }
        m &= ~0x00800000;
        e += 0x38800000;
        return m | e;
    };
    const mantisaTable = new Uint32Array(2048);
    mantisaTable[0] = 0;
    for (let i = 1; i < 1024; i++) {
        mantisaTable[i] = convertMantissa(i);
    }
    for (let i = 1024; i < 2048; i++) {
        mantisaTable[i] = 0x38000000 + ((i - 1024) << 13);
    }
    return mantisaTable;
}
/**
 * Computes exponent table for casting Float16 to Float32
 * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
 *
 * @returns Uint32Array, 64 exponent lookup values.
 */
function computeFloat16ExponentTable() {
    const exponentTable = new Uint32Array(64);
    exponentTable[0] = 0;
    exponentTable[31] = 0x47800000;
    exponentTable[32] = 0x80000000;
    exponentTable[63] = 0xc7800000;
    for (let i = 1; i < 31; i++) {
        exponentTable[i] = i << 23;
    }
    for (let i = 33; i < 63; i++) {
        exponentTable[i] = 0x80000000 + ((i - 32) << 23);
    }
    return exponentTable;
}
/**
 * Computes offset table for casting Float16 to Float32
 * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
 *
 * @returns Uint32Array, 6d offset values.
 */
function computeFloat16OffsetTable() {
    const offsetTable = new Uint32Array(64);
    for (let i = 0; i < 64; i++) {
        offsetTable[i] = 1024;
    }
    offsetTable[0] = offsetTable[32] = 0;
    return offsetTable;
}
/**
 * Retrieve a Float16 decoder which will decode a ByteArray of Float16 values
 * to a Float32Array.
 *
 * @returns Function (buffer: Uint16Array) => Float32Array which decodes
 *          the Uint16Array of Float16 bytes to a Float32Array.
 */
export function getFloat16Decoder() {
    // Algorithm is based off of
    // http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
    // Cache lookup tables
    const mantisaTable = computeFloat16MantisaTable();
    const exponentTable = computeFloat16ExponentTable();
    const offsetTable = computeFloat16OffsetTable();
    return (quantizedArray) => {
        const buffer = new ArrayBuffer(4 * quantizedArray.length);
        const bufferUint32View = new Uint32Array(buffer);
        for (let index = 0; index < quantizedArray.length; index++) {
            const float16Bits = quantizedArray[index];
            const float32Bits = mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 0x3ff)] +
                exponentTable[float16Bits >> 10];
            bufferUint32View[index] = float32Bits;
        }
        return new Float32Array(buffer);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW9fdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWNvcmUvc3JjL2lvL2lvX3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2QyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBR3JDLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFFdEMsT0FBTyxFQUFDLG9CQUFvQixFQUEwRyxNQUFNLFNBQVMsQ0FBQztBQUV0Siw4RUFBOEU7QUFDOUUsTUFBTSx1QkFBdUIsR0FBRyxDQUFDLENBQUM7QUFFbEM7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxNQUFNLENBQUMsS0FBSyxVQUFVLGFBQWEsQ0FDL0IsT0FBcUMsRUFBRSxLQUFtQjtJQUU1RCw0Q0FBNEM7SUFDNUMsTUFBTSxLQUFLLEdBQTJCLEVBQUUsQ0FBQztJQUN6QyxNQUFNLFlBQVksR0FBK0IsRUFBRSxDQUFDO0lBRXBELE1BQU0sS0FBSyxHQUFhLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUM1QyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDcEMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUV6QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNyQyxNQUFNLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEIsTUFBTSxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMs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QUMsR0FBRyxXQUFXLENBQUM7U0FDdkM7UUFDRCxPQUFPLElBQUksWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ2xDLENBQUMsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7Y29tcGxleH0gZnJvbSAnLi4vb3BzL2NvbXBsZXgnO1xuaW1wb3J0IHt0ZW5zb3J9IGZyb20gJy4uL29wcy90ZW5zb3InO1xuaW1wb3J0IHtOYW1lZFRlbnNvciwgTmFtZWRUZW5zb3JNYXB9IGZyb20gJy4uL3RlbnNvcl90eXBlcyc7XG5pbXBvcnQge1R5cGVkQXJyYXl9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7c2l6ZUZyb21TaGFwZX0gZnJvbSAnLi4vdXRpbCc7XG5cbmltcG9ydCB7RFRZUEVfVkFMVUVfU0laRV9NQVAsIE1vZGVsQXJ0aWZhY3RzLCBNb2RlbEFydGlmYWN0c0luZm8sIE1vZGVsSlNPTiwgV2VpZ2h0R3JvdXAsIFdlaWdodHNNYW5pZmVzdENvbmZpZywgV2VpZ2h0c01hbmlmZXN0RW50cnl9IGZyb20gJy4vdHlwZXMnO1xuXG4vKiogTnVtYmVyIG9mIGJ5dGVzIHJlc2VydmVkIGZvciB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcuICgzMmJpdCBpbnRlZ2VyKS4gKi9cbmNvbnN0IE5VTV9CWVRFU19TVFJJTkdfTEVOR1RIID0gNDtcblxuLyoqXG4gKiBFbmNvZGUgYSBtYXAgZnJvbSBuYW1lcyB0byB3ZWlnaHQgdmFsdWVzIGFzIGFuIEFycmF5QnVmZmVyLCBhbG9uZyB3aXRoIGFuXG4gKiBgQXJyYXlgIG9mIGBXZWlnaHRzTWFuaWZlc3RFbnRyeWAgYXMgc3BlY2lmaWNhdGlvbiBvZiB0aGUgZW5jb2RlZCB3ZWlnaHRzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBzaGFyZGluZy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHRoZSByZXZlcnNlIG9mIGBkZWNvZGVXZWlnaHRzYC5cbiAqXG4gKiBAcGFyYW0gdGVuc29ycyBBIG1hcCAoXCJkaWN0XCIpIGZyb20gbmFtZXMgdG8gdGVuc29ycy5cbiAqIEBwYXJhbSBncm91cCBHcm91cCB0byB3aGljaCB0aGUgd2VpZ2h0cyBiZWxvbmcgKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIG9mXG4gKiAgIC0gQSBmbGF0IGBBcnJheUJ1ZmZlcmAgd2l0aCBhbGwgdGhlIGJpbmFyeSB2YWx1ZXMgb2YgdGhlIGBUZW5zb3Jgc1xuICogICAgIGNvbmNhdGVuYXRlZC5cbiAqICAgLSBBbiBgQXJyYXlgIG9mIGBXZWlnaHRNYW5pZmVzdEVudHJ5YHMsIGNhcnJ5aW5nIGluZm9ybWF0aW9uIGluY2x1ZGluZ1xuICogICAgIHRlbnNvciBuYW1lcywgYGR0eXBlYHMgYW5kIHNoYXBlcy5cbiAqIEB0aHJvd3MgRXJyb3I6IG9uIHVuc3VwcG9ydGVkIHRlbnNvciBgZHR5cGVgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW5jb2RlV2VpZ2h0cyhcbiAgICB0ZW5zb3JzOiBOYW1lZFRlbnNvck1hcHxOYW1lZFRlbnNvcltdLCBncm91cD86IFdlaWdodEdyb3VwKTpcbiAgICBQcm9taXNlPHtkYXRhOiBBcnJheUJ1ZmZlciwgc3BlY3M6IFdlaWdodHNNYW5pZmVzdEVudHJ5W119PiB7XG4gIC8vIFRPRE8oYWRhcm9iLCBjYWlzKTogU3VwcG9ydCBxdWFudGl6YXRpb24uXG4gIGNvbnN0IHNwZWNzOiBXZWlnaHRzTWFuaWZlc3RFbnRyeVtdID0gW107XG4gIGNvbnN0IGRhdGFQcm9taXNlczogQXJyYXk8UHJvbWlzZTxUeXBlZEFycmF5Pj4gPSBbXTtcblxuICBjb25zdCBuYW1lczogc3RyaW5nW10gPSBBcnJheS5pc0FycmF5KHRlbnNvcnMpID9cbiAgICAgIHRlbnNvcnMubWFwKHRlbnNvciA9PiB0ZW5zb3IubmFtZSkgOlxuICAgICAgT2JqZWN0LmtleXModGVuc29ycyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICBjb25zdCB0ID0gQXJyYXkuaXNBcnJheSh0ZW5zb3JzKSA/IHRlbnNvcnNbaV0udGVuc29yIDogdGVuc29yc1tuYW1lXTtcbiAgICBpZiAodC5kdHlwZSAhPT0gJ2Zsb2F0MzInICYmIHQuZHR5cGUgIT09ICdpbnQzMicgJiYgdC5kdHlwZSAhPT0gJ2Jvb2wnICYmXG4gICAgICAgIHQuZHR5cGUgIT09ICdzdHJpbmcnICYmIHQuZHR5cGUgIT09ICdjb21wbGV4NjQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnJHtuYW1lfSc6ICR7dC5kdHlwZX1gKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlYzogV2VpZ2h0c01hbmlmZXN0RW50cnkgPSB7bmFtZSwgc2hhcGU6IHQuc2hhcGUsIGR0eXBlOiB0LmR0eXBlfTtcbiAgICBpZiAodC5kdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHV0ZjhieXRlcyA9IG5ldyBQcm9taXNlPFR5cGVkQXJyYXk+KGFzeW5jIHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCB2YWxzID0gYXdhaXQgdC5ieXRlcygpIGFzIFVpbnQ4QXJyYXlbXTtcbiAgICAgICAgY29uc3QgdG90YWxOdW1CeXRlcyA9IHZhbHMucmVkdWNlKChwLCBjKSA9PiBwICsgYy5sZW5ndGgsIDApICtcbiAgICAgICAgICAgIE5VTV9CWVRFU19TVFJJTkdfTEVOR1RIICogdmFscy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxOdW1CeXRlcyk7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCB2YWwgPSB2YWxzW2ldO1xuICAgICAgICAgIGNvbnN0IGJ5dGVzT2ZMZW5ndGggPVxuICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoW3ZhbC5sZW5ndGhdKS5idWZmZXIpO1xuICAgICAgICAgIGJ5dGVzLnNldChieXRlc09mTGVuZ3RoLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSBOVU1fQllURVNfU1RSSU5HX0xFTkdUSDtcbiAgICAgICAgICBieXRlcy5zZXQodmFsLCBvZmZzZXQpO1xuICAgICAgICAgIG9mZnNldCArPSB2YWwubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoYnl0ZXMpO1xuICAgICAgfSk7XG4gICAgICBkYXRhUHJvbWlzZXMucHVzaCh1dGY4Ynl0ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhUHJvbWlzZXMucHVzaCh0LmRhdGEoKSk7XG4gICAgfVxuICAgIGlmIChncm91cCAhPSBudWxsKSB7XG4gICAgICBzcGVjLmdyb3VwID0gZ3JvdXA7XG4gICAgfVxuICAgIHNwZWNzLnB1c2goc3BlYyk7XG4gIH1cblxuICBjb25zdCB0ZW5zb3JWYWx1ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChkYXRhUHJvbWlzZXMpO1xuICByZXR1cm4ge2RhdGE6IGNvbmNhdGVuYXRlVHlwZWRBcnJheXModGVuc29yVmFsdWVzKSwgc3BlY3N9O1xufVxuXG4vKipcbiAqIERlY29kZSBmbGF0IEFycmF5QnVmZmVyIGFzIHdlaWdodHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBoYW5kbGUgc2hhcmRpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgcmV2ZXJzZSBvZiBgZW5jb2RlV2VpZ2h0c2AuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciBBIGZsYXQgQXJyYXlCdWZmZXIgY2FycnlpbmcgdGhlIGJpbmFyeSB2YWx1ZXMgb2YgdGhlIHRlbnNvcnNcbiAqICAgY29uY2F0ZW5hdGVkIGluIHRoZSBvcmRlciBzcGVjaWZpZWQgaW4gYHNwZWNzYC5cbiAqIEBwYXJhbSBzcGVjcyBTcGVjaWZpY2F0aW9ucyBvZiB0aGUgbmFtZXMsIGR0eXBlcyBhbmQgc2hhcGVzIG9mIHRoZSB0ZW5zb3JzXG4gKiAgIHdob3NlIHZhbHVlIGFyZSBlbmNvZGVkIGJ5IGBidWZmZXJgLlxuICogQHJldHVybiBBIG1hcCBmcm9tIHRlbnNvciBuYW1lIHRvIHRlbnNvciB2YWx1ZSwgd2l0aCB0aGUgbmFtZXMgY29ycmVzcG9uZGluZ1xuICogICB0byBuYW1lcyBpbiBgc3BlY3NgLlxuICogQHRocm93cyBFcnJvciwgaWYgYW55IG9mIHRoZSB0ZW5zb3JzIGhhcyB1bnN1cHBvcnRlZCBkdHlwZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVdlaWdodHMoXG4gICAgYnVmZmVyOiBBcnJheUJ1ZmZlciwgc3BlY3M6IFdlaWdodHNNYW5pZmVzdEVudHJ5W10pOiBOYW1lZFRlbnNvck1hcCB7XG4gIC8vIFRPRE8oYWRhcm9iLCBjYWlzKTogU3VwcG9ydCBxdWFudGl6YXRpb24uXG4gIGNvbnN0IG91dDogTmFtZWRUZW5zb3JNYXAgPSB7fTtcbiAgbGV0IGZsb2F0MTZEZWNvZGU6IChidWZmZXI6IFVpbnQxNkFycmF5KSA9PiBGbG9hdDMyQXJyYXkgfCB1bmRlZmluZWQ7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IHNwZWMgb2Ygc3BlY3MpIHtcbiAgICBjb25zdCBuYW1lID0gc3BlYy5uYW1lO1xuICAgIGNvbnN0IGR0eXBlID0gc3BlYy5kdHlwZTtcbiAgICBjb25zdCBzaGFwZSA9IHNwZWMuc2hhcGU7XG4gICAgY29uc3Qgc2l6ZSA9IHNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgIGxldCB2YWx1ZXM6IFR5cGVkQXJyYXl8c3RyaW5nW118VWludDhBcnJheVtdO1xuXG4gICAgaWYgKCdxdWFudGl6YXRpb24nIGluIHNwZWMpIHtcbiAgICAgIGNvbnN0IHF1YW50aXphdGlvbiA9IHNwZWMucXVhbnRpemF0aW9uO1xuICAgICAgaWYgKHF1YW50aXphdGlvbi5kdHlwZSA9PT0gJ3VpbnQ4JyB8fCBxdWFudGl6YXRpb24uZHR5cGUgPT09ICd1aW50MTYnKSB7XG4gICAgICAgIGlmICghKCdtaW4nIGluIHF1YW50aXphdGlvbiAmJiAnc2NhbGUnIGluIHF1YW50aXphdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBXZWlnaHQgJHtzcGVjLm5hbWV9IHdpdGggcXVhbnRpemF0aW9uICR7cXVhbnRpemF0aW9uLmR0eXBlfSBgICtcbiAgICAgICAgICAgICAgYGRvZXNuJ3QgaGF2ZSBjb3JyZXNwb25kaW5nIG1ldGFkYXRhIG1pbiBhbmQgc2NhbGUuYCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocXVhbnRpemF0aW9uLmR0eXBlID09PSAnZmxvYXQxNicpIHtcbiAgICAgICAgaWYgKGR0eXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBXZWlnaHQgJHtzcGVjLm5hbWV9IGlzIHF1YW50aXplZCB3aXRoICR7cXVhbnRpemF0aW9uLmR0eXBlfSBgICtcbiAgICAgICAgICAgICAgYHdoaWNoIG9ubHkgc3VwcG9ydHMgd2VpZ2h0cyBvZiB0eXBlIGZsb2F0MzIgbm90ICR7ZHR5cGV9LmApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgV2VpZ2h0ICR7c3BlYy5uYW1lfSBoYXMgdW5rbm93biBgICtcbiAgICAgICAgICAgIGBxdWFudGl6YXRpb24gZHR5cGUgJHtxdWFudGl6YXRpb24uZHR5cGV9LiBgICtcbiAgICAgICAgICAgIGBTdXBwb3J0ZWQgcXVhbnRpemF0aW9uIGR0eXBlcyBhcmU6IGAgK1xuICAgICAgICAgICAgYCd1aW50OCcsICd1aW50MTYnLCBhbmQgJ2Zsb2F0MTYnLmApO1xuICAgICAgfVxuICAgICAgY29uc3QgcXVhbnRpemF0aW9uU2l6ZUZhY3RvciA9IERUWVBFX1ZBTFVFX1NJWkVfTUFQW3F1YW50aXphdGlvbi5kdHlwZV07XG4gICAgICBjb25zdCBieXRlQnVmZmVyID1cbiAgICAgICAgICBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzaXplICogcXVhbnRpemF0aW9uU2l6ZUZhY3Rvcik7XG4gICAgICBjb25zdCBxdWFudGl6ZWRBcnJheSA9IChxdWFudGl6YXRpb24uZHR5cGUgPT09ICd1aW50OCcpID9cbiAgICAgICAgICBuZXcgVWludDhBcnJheShieXRlQnVmZmVyKSA6XG4gICAgICAgICAgbmV3IFVpbnQxNkFycmF5KGJ5dGVCdWZmZXIpO1xuICAgICAgaWYgKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgaWYgKHF1YW50aXphdGlvbi5kdHlwZSA9PT0gJ3VpbnQ4JyB8fCBxdWFudGl6YXRpb24uZHR5cGUgPT09ICd1aW50MTYnKSB7XG4gICAgICAgICAgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShxdWFudGl6ZWRBcnJheS5sZW5ndGgpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhbnRpemVkQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBxdWFudGl6ZWRBcnJheVtpXTtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IHYgKiBxdWFudGl6YXRpb24uc2NhbGUgKyBxdWFudGl6YXRpb24ubWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChxdWFudGl6YXRpb24uZHR5cGUgPT09ICdmbG9hdDE2Jykge1xuICAgICAgICAgIGlmIChmbG9hdDE2RGVjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZsb2F0MTZEZWNvZGUgPSBnZXRGbG9hdDE2RGVjb2RlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZXMgPSBmbG9hdDE2RGVjb2RlKHF1YW50aXplZEFycmF5IGFzIFVpbnQxNkFycmF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBxdWFudGl6YXRpb24gdHlwZSAke3F1YW50aXphdGlvbi5kdHlwZX0gYCArXG4gICAgICAgICAgICAgIGBmb3Igd2VpZ2h0IHR5cGUgZmxvYXQzMi5gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICBpZiAocXVhbnRpemF0aW9uLmR0eXBlICE9PSAndWludDgnICYmIHF1YW50aXphdGlvbi5kdHlwZSAhPT0gJ3VpbnQxNicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbnN1cHBvcnRlZCBxdWFudGl6YXRpb24gdHlwZSAke3F1YW50aXphdGlvbi5kdHlwZX0gYCArXG4gICAgICAgICAgICAgIGBmb3Igd2VpZ2h0IHR5cGUgaW50MzIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzID0gbmV3IEludDMyQXJyYXkocXVhbnRpemVkQXJyYXkubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWFudGl6ZWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHYgPSBxdWFudGl6ZWRBcnJheVtpXTtcbiAgICAgICAgICB2YWx1ZXNbaV0gPSBNYXRoLnJvdW5kKHYgKiBxdWFudGl6YXRpb24uc2NhbGUgKyBxdWFudGl6YXRpb24ubWluKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkdHlwZSBpbiB3ZWlnaHQgJyR7bmFtZX0nOiAke2R0eXBlfWApO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ICs9IHNpemUgKiBxdWFudGl6YXRpb25TaXplRmFjdG9yO1xuICAgIH0gZWxzZSBpZiAoZHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBzaXplID0gc2l6ZUZyb21TaGFwZShzcGVjLnNoYXBlKTtcbiAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IG5ldyBVaW50MzJBcnJheShcbiAgICAgICAgICAgIGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIE5VTV9CWVRFU19TVFJJTkdfTEVOR1RIKSlbMF07XG4gICAgICAgIG9mZnNldCArPSBOVU1fQllURVNfU1RSSU5HX0xFTkdUSDtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBieXRlTGVuZ3RoKSk7XG4gICAgICAgICh2YWx1ZXMgYXMgVWludDhBcnJheVtdKS5wdXNoKGJ5dGVzKTtcbiAgICAgICAgb2Zmc2V0ICs9IGJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGR0eXBlRmFjdG9yID0gRFRZUEVfVkFMVUVfU0laRV9NQVBbZHR5cGVdO1xuICAgICAgY29uc3QgYnl0ZUJ1ZmZlciA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUgKiBkdHlwZUZhY3Rvcik7XG5cbiAgICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYnl0ZUJ1ZmZlcik7XG4gICAgICB9IGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KGJ5dGVCdWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBVaW50OEFycmF5KGJ5dGVCdWZmZXIpO1xuICAgICAgfSBlbHNlIGlmIChkdHlwZSA9PT0gJ2NvbXBsZXg2NCcpIHtcbiAgICAgICAgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheShieXRlQnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVhbCA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCAvIDIpO1xuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCAvIDIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICByZWFsW2ldID0gdmFsdWVzW2kgKiAyXTtcbiAgICAgICAgICBpbWFnZVtpXSA9IHZhbHVlc1tpICogMiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlYWxUZW5zb3IgPSB0ZW5zb3IocmVhbCwgc2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIGNvbnN0IGltYWdlVGVuc29yID0gdGVuc29yKGltYWdlLCBzaGFwZSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgb3V0W25hbWVdID0gY29tcGxleChyZWFsVGVuc29yLCBpbWFnZVRlbnNvcik7XG4gICAgICAgIHJlYWxUZW5zb3IuZGlzcG9zZSgpO1xuICAgICAgICBpbWFnZVRlbnNvci5kaXNwb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGR0eXBlIGluIHdlaWdodCAnJHtuYW1lfSc6ICR7ZHR5cGV9YCk7XG4gICAgICB9XG4gICAgICBvZmZzZXQgKz0gc2l6ZSAqIGR0eXBlRmFjdG9yO1xuICAgIH1cbiAgICBpZiAoZHR5cGUgIT09ICdjb21wbGV4NjQnKSB7XG4gICAgICBvdXRbbmFtZV0gPSB0ZW5zb3IodmFsdWVzLCBzaGFwZSwgZHR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlIFR5cGVkQXJyYXlzIGludG8gYW4gQXJyYXlCdWZmZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRlbmF0ZVR5cGVkQXJyYXlzKHhzOiBUeXBlZEFycmF5W10pOiBBcnJheUJ1ZmZlciB7XG4gIC8vIFRPRE8oYWRhcm9iLCBjYWlzKTogU3VwcG9ydCBxdWFudGl6YXRpb24uXG4gIGlmICh4cyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnB1dCB2YWx1ZTogJHtKU09OLnN0cmluZ2lmeSh4cyl9YCk7XG4gIH1cblxuICBsZXQgdG90YWxCeXRlTGVuZ3RoID0gMDtcblxuICAvLyBgbm9ybWFsaXplZFhzYCBpcyBoZXJlIGZvciB0aGlzIHJlYXNvbjogYSBgVHlwZWRBcnJheWAncyBgYnVmZmVyJ1xuICAvLyBjYW4gaGF2ZSBhIGRpZmZlcmVudCBieXRlIGxlbmd0aCBmcm9tIHRoYXQgb2YgdGhlIGBUeXBlZEFycmF5YCBpdHNlbGYsXG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHRoZSBgVHlwZWRBcnJheWAgaXMgY3JlYXRlZCBmcm9tIGFuIG9mZnNldCBpbiBhblxuICAvLyBgQXJyYXlCdWZmZXJgLiBgbm9ybWxpYXplZFhzYCBob2xkcyBgVHlwZWRBcnJheWBzIHdob3NlIGBidWZmZXJgcyBtYXRjaFxuICAvLyB0aGUgYFR5cGVkQXJyYXlgIGluIGJ5dGUgbGVuZ3RoLiBJZiBhbiBlbGVtZW50IG9mIGB4c2AgZG9lcyBub3Qgc2hvd1xuICAvLyB0aGlzIHByb3BlcnR5LCBhIG5ldyBgVHlwZWRBcnJheWAgdGhhdCBzYXRpc2Z5IHRoaXMgcHJvcGVydHkgd2lsbCBiZVxuICAvLyBjb25zdHJ1Y3RlZCBhbmQgcHVzaGVkIGludG8gYG5vcm1hbGl6ZWRYc2AuXG4gIGNvbnN0IG5vcm1hbGl6ZWRYczogVHlwZWRBcnJheVtdID0gW107XG4gIHhzLmZvckVhY2goKHg6IFR5cGVkQXJyYXkpID0+IHtcbiAgICB0b3RhbEJ5dGVMZW5ndGggKz0geC5ieXRlTGVuZ3RoO1xuICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWFueVxuICAgIG5vcm1hbGl6ZWRYcy5wdXNoKFxuICAgICAgICB4LmJ5dGVMZW5ndGggPT09IHguYnVmZmVyLmJ5dGVMZW5ndGggPyB4IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3ICh4LmNvbnN0cnVjdG9yIGFzIGFueSkoeCkpO1xuICAgIGlmICghKHggYXMgYW55IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHggYXMgYW55IGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxuICAgICAgICAgIHggYXMgYW55IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgVHlwZWRBcnJheSBzdWJ0eXBlOiAke3guY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICB9XG4gICAgLy8gdHNsaW50OmVuYWJsZTpuby1hbnlcbiAgfSk7XG5cbiAgY29uc3QgeSA9IG5ldyBVaW50OEFycmF5KHRvdGFsQnl0ZUxlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBub3JtYWxpemVkWHMuZm9yRWFjaCgoeDogVHlwZWRBcnJheSkgPT4ge1xuICAgIHkuc2V0KG5ldyBVaW50OEFycmF5KHguYnVmZmVyKSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0geC5ieXRlTGVuZ3RoO1xuICB9KTtcblxuICByZXR1cm4geS5idWZmZXI7XG59XG5cbi8vIFVzZSBCdWZmZXIgb24gTm9kZS5qcyBpbnN0ZWFkIG9mIEJsb2IvYXRvYi9idG9hXG5jb25zdCB1c2VOb2RlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAodHlwZW9mIEJsb2IgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBhdG9iID09PSAndW5kZWZpbmVkJyB8fFxuICAgICB0eXBlb2YgYnRvYSA9PT0gJ3VuZGVmaW5lZCcpO1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYnl0ZSBsZW5ndGggb2YgYSBKYXZhU2NyaXB0IHN0cmluZy5cbiAqXG4gKiBOb3RlIHRoYXQgYSBKYXZhU2NyaXB0IHN0cmluZyBjYW4gY29udGFpbiB3aWRlIGNoYXJhY3RlcnMsIHRoZXJlZm9yZSB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGlzIG5vdCBuZWNlc3NhcmlseSBlcXVhbCB0byB0aGUgYnl0ZSBsZW5ndGguXG4gKlxuICogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmcuXG4gKiBAcmV0dXJucyBCeXRlIGxlbmd0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0J5dGVMZW5ndGgoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICBpZiAodXNlTm9kZUJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIpO1xuICB9XG4gIHJldHVybiBuZXcgQmxvYihbc3RyXSkuc2l6ZTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgYW4gQXJyYXlCdWZmZXIgYXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciBgQXJyYXlCdWZmZXJgIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIHRoYXQgYmFzZTY0LWVuY29kZXMgYGJ1ZmZlcmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUJ1ZmZlclRvQmFzZTY0U3RyaW5nKGJ1ZmZlcjogQXJyYXlCdWZmZXIpOiBzdHJpbmcge1xuICBpZiAodXNlTm9kZUJ1ZmZlcikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShidWZmZXIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICBsZXQgcyA9ICcnO1xuICBmb3IgKGxldCBpID0gMCwgbCA9IGJ1Zi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gYnRvYShzKTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBiYXNlNjQgc3RyaW5nIGFzIGFuIEFycmF5QnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzdHIgQmFzZTY0IHN0cmluZy5cbiAqIEByZXR1cm5zIERlY29kZWQgYEFycmF5QnVmZmVyYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFN0cmluZ1RvQXJyYXlCdWZmZXIoc3RyOiBzdHJpbmcpOiBBcnJheUJ1ZmZlciB7XG4gIGlmICh1c2VOb2RlQnVmZmVyKSB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmZyb20oc3RyLCAnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmJ5dGVMZW5ndGgpO1xuICB9XG4gIGNvbnN0IHMgPSBhdG9iKHN0cik7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHMubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgKytpKSB7XG4gICAgYnVmZmVyLnNldChbcy5jaGFyQ29kZUF0KGkpXSwgaSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5idWZmZXI7XG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdGUgYSBudW1iZXIgb2YgQXJyYXlCdWZmZXJzIGludG8gb25lLlxuICpcbiAqIEBwYXJhbSBidWZmZXJzIEEgbnVtYmVyIG9mIGFycmF5IGJ1ZmZlcnMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBSZXN1bHQgb2YgY29uY2F0ZW5hdGluZyBgYnVmZmVyc2AgaW4gb3JkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRlbmF0ZUFycmF5QnVmZmVycyhidWZmZXJzOiBBcnJheUJ1ZmZlcltdKTogQXJyYXlCdWZmZXIge1xuICBpZiAoYnVmZmVycy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gYnVmZmVyc1swXTtcbiAgfVxuXG4gIGxldCB0b3RhbEJ5dGVMZW5ndGggPSAwO1xuICBidWZmZXJzLmZvckVhY2goKGJ1ZmZlcjogQXJyYXlCdWZmZXIpID0+IHtcbiAgICB0b3RhbEJ5dGVMZW5ndGggKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH0pO1xuXG4gIGNvbnN0IHRlbXAgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgYnVmZmVycy5mb3JFYWNoKChidWZmZXI6IEFycmF5QnVmZmVyKSA9PiB7XG4gICAgdGVtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmZmVyLmJ5dGVMZW5ndGg7XG4gIH0pO1xuICByZXR1cm4gdGVtcC5idWZmZXI7XG59XG5cbi8qKlxuICogR2V0IHRoZSBiYXNlbmFtZSBvZiBhIHBhdGguXG4gKlxuICogQmVoYXZlcyBpbiBhIHdheSBhbmFsb2dvdXMgdG8gTGludXgncyBiYXNlbmFtZSBjb21tYW5kLlxuICpcbiAqIEBwYXJhbSBwYXRoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlbmFtZShwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBTRVBBUkFUT1IgPSAnLyc7XG4gIHBhdGggPSBwYXRoLnRyaW0oKTtcbiAgd2hpbGUgKHBhdGguZW5kc1dpdGgoU0VQQVJBVE9SKSkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gIH1cbiAgY29uc3QgaXRlbXMgPSBwYXRoLnNwbGl0KFNFUEFSQVRPUik7XG4gIHJldHVybiBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYE1vZGVsSlNPTmAgZnJvbSBgTW9kZWxBcnRpZmFjdHNgLlxuICpcbiAqIEBwYXJhbSBhcnRpZmFjdHMgTW9kZWwgYXJ0aWZhY3RzLCBkZXNjcmliaW5nIHRoZSBtb2RlbCBhbmQgaXRzIHdlaWdodHMuXG4gKiBAcGFyYW0gbWFuaWZlc3QgV2VpZ2h0IG1hbmlmZXN0LCBkZXNjcmliaW5nIHdoZXJlIHRoZSB3ZWlnaHRzIG9mIHRoZVxuICogICAgIGBNb2RlbEFydGlmYWN0c2AgYXJlIHN0b3JlZCwgYW5kIHNvbWUgbWV0YWRhdGEgYWJvdXQgdGhlbS5cbiAqIEByZXR1cm5zIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIGBtb2RlbC5qc29uYCBmaWxlIGRlc2NyaWJpbmcgdGhlIG1vZGVsXG4gKiAgICAgYXJ0aWZhY3RzIGFuZCB3ZWlnaHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2RlbEpTT05Gb3JNb2RlbEFydGlmYWN0cyhcbiAgICBhcnRpZmFjdHM6IE1vZGVsQXJ0aWZhY3RzLCBtYW5pZmVzdDogV2VpZ2h0c01hbmlmZXN0Q29uZmlnKTogTW9kZWxKU09OIHtcbiAgY29uc3QgcmVzdWx0OiBNb2RlbEpTT04gPSB7XG4gICAgbW9kZWxUb3BvbG9neTogYXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3ksXG4gICAgZm9ybWF0OiBhcnRpZmFjdHMuZm9ybWF0LFxuICAgIGdlbmVyYXRlZEJ5OiBhcnRpZmFjdHMuZ2VuZXJhdGVkQnksXG4gICAgY29udmVydGVkQnk6IGFydGlmYWN0cy5jb252ZXJ0ZWRCeSxcbiAgICB3ZWlnaHRzTWFuaWZlc3Q6IG1hbmlmZXN0XG4gIH07XG4gIGlmIChhcnRpZmFjdHMuc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICByZXN1bHQuc2lnbmF0dXJlID0gYXJ0aWZhY3RzLnNpZ25hdHVyZTtcbiAgfVxuICBpZiAoYXJ0aWZhY3RzLnVzZXJEZWZpbmVkTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgIHJlc3VsdC51c2VyRGVmaW5lZE1ldGFkYXRhID0gYXJ0aWZhY3RzLnVzZXJEZWZpbmVkTWV0YWRhdGE7XG4gIH1cbiAgaWYgKGFydGlmYWN0cy5tb2RlbEluaXRpYWxpemVyICE9IG51bGwpIHtcbiAgICByZXN1bHQubW9kZWxJbml0aWFsaXplciA9IGFydGlmYWN0cy5tb2RlbEluaXRpYWxpemVyO1xuICB9XG4gIGlmIChhcnRpZmFjdHMudHJhaW5pbmdDb25maWcgIT0gbnVsbCkge1xuICAgIHJlc3VsdC50cmFpbmluZ0NvbmZpZyA9IGFydGlmYWN0cy50cmFpbmluZ0NvbmZpZztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBgTW9kZWxBcnRpZmFjdHNgIGZyb20gYSBKU09OIGZpbGUgYW5kIHdlaWdodHMuXG4gKlxuICogQHBhcmFtIG1vZGVsSlNPTiBPYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIEpTT04gb2YgYG1vZGVsLmpzb25gXG4gKiBAcGFyYW0gd2VpZ2h0U3BlY3MgVGhlIGxpc3Qgb2YgV2VpZ2h0c01hbmlmZXN0RW50cnkgZm9yIHRoZSBtb2RlbC4gTXVzdCBiZVxuICogICAgIHBhc3NlZCBpZiB0aGUgbW9kZWxKU09OIGhhcyBhIHdlaWdodHNNYW5pZmVzdC5cbiAqIEBwYXJhbSB3ZWlnaHREYXRhIEFuIEFycmF5QnVmZmVyIG9mIHdlaWdodCBkYXRhIGZvciB0aGUgbW9kZWwgY29ycmVzcG9uZGluZ1xuICogICAgIHRvIHRoZSB3ZWlnaHRzIGluIHdlaWdodFNwZWNzLiBNdXN0IGJlIHBhc3NlZCBpZiB0aGUgbW9kZWxKU09OIGhhcyBhXG4gKiAgICAgd2VpZ2h0c01hbmlmZXN0LlxuICogQHJldHVybnMgQSBQcm9taXNlIG9mIHRoZSBgTW9kZWxBcnRpZmFjdHNgLCBhcyBkZXNjcmliZWQgYnkgdGhlIEpTT04gZmlsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1vZGVsQXJ0aWZhY3RzRm9ySlNPTlN5bmMoXG4gICAgbW9kZWxKU09OOiBNb2RlbEpTT04sIHdlaWdodFNwZWNzPzogV2VpZ2h0c01hbmlmZXN0RW50cnlbXSxcbiAgICB3ZWlnaHREYXRhPzogQXJyYXlCdWZmZXIpOiBNb2RlbEFydGlmYWN0cyB7XG5cbiAgY29uc3QgbW9kZWxBcnRpZmFjdHM6IE1vZGVsQXJ0aWZhY3RzID0ge1xuICAgIG1vZGVsVG9wb2xvZ3k6IG1vZGVsSlNPTi5tb2RlbFRvcG9sb2d5LFxuICAgIGZvcm1hdDogbW9kZWxKU09OLmZvcm1hdCxcbiAgICBnZW5lcmF0ZWRCeTogbW9kZWxKU09OLmdlbmVyYXRlZEJ5LFxuICAgIGNvbnZlcnRlZEJ5OiBtb2RlbEpTT04uY29udmVydGVkQnlcbiAgfTtcblxuICBpZiAobW9kZWxKU09OLnRyYWluaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICBtb2RlbEFydGlmYWN0cy50cmFpbmluZ0NvbmZpZyA9IG1vZGVsSlNPTi50cmFpbmluZ0NvbmZpZztcbiAgfVxuICBpZiAobW9kZWxKU09OLndlaWdodHNNYW5pZmVzdCAhPSBudWxsKSB7XG4gICAgaWYgKCF3ZWlnaHRTcGVjcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtb2RlbEpTT04gaGFzIHdlaWdodHNNYW5pZmVzdCBidXQgd2VpZ2h0U3BlY3MgaXMgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAoIXdlaWdodERhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxKU09OIGhhcyB3ZWlnaHRzTWFuaWZlc3QgYnV0IHdlaWdodERhdGEgaXMgbnVsbCcpO1xuICAgIH1cbiAgICBtb2RlbEFydGlmYWN0cy53ZWlnaHRTcGVjcyA9IHdlaWdodFNwZWNzO1xuICAgIG1vZGVsQXJ0aWZhY3RzLndlaWdodERhdGEgPSB3ZWlnaHREYXRhO1xuICB9XG4gIGlmIChtb2RlbEpTT04uc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICBtb2RlbEFydGlmYWN0cy5zaWduYXR1cmUgPSBtb2RlbEpTT04uc2lnbmF0dXJlO1xuICB9XG4gIGlmIChtb2RlbEpTT04udXNlckRlZmluZWRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgbW9kZWxBcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YSA9IG1vZGVsSlNPTi51c2VyRGVmaW5lZE1ldGFkYXRhO1xuICB9XG4gIGlmIChtb2RlbEpTT04ubW9kZWxJbml0aWFsaXplciAhPSBudWxsKSB7XG4gICAgbW9kZWxBcnRpZmFjdHMubW9kZWxJbml0aWFsaXplciA9IG1vZGVsSlNPTi5tb2RlbEluaXRpYWxpemVyO1xuICB9XG5cbiAgcmV0dXJuIG1vZGVsQXJ0aWZhY3RzO1xufVxuXG4vKipcbiAqIENyZWF0ZSBgTW9kZWxBcnRpZmFjdHNgIGZyb20gYSBKU09OIGZpbGUuXG4gKlxuICogQHBhcmFtIG1vZGVsSlNPTiBPYmplY3QgY29udGFpbmluZyB0aGUgcGFyc2VkIEpTT04gb2YgYG1vZGVsLmpzb25gXG4gKiBAcGFyYW0gbG9hZFdlaWdodHMgRnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgSlNPTiBmaWxlJ3Mgd2VpZ2h0cyBtYW5pZmVzdCxcbiAqICAgICByZWFkcyB3ZWlnaHRzIGZyb20gdGhlIGxpc3RlZCBwYXRoKHMpLCBhbmQgcmV0dXJucyBhIFByb21pc2Ugb2YgdGhlXG4gKiAgICAgd2VpZ2h0IG1hbmlmZXN0IGVudHJpZXMgYWxvbmcgd2l0aCB0aGUgd2VpZ2h0cyBkYXRhLlxuICogQHJldHVybnMgQSBQcm9taXNlIG9mIHRoZSBgTW9kZWxBcnRpZmFjdHNgLCBhcyBkZXNjcmliZWQgYnkgdGhlIEpTT04gZmlsZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1vZGVsQXJ0aWZhY3RzRm9ySlNPTihcbiAgICBtb2RlbEpTT046IE1vZGVsSlNPTixcbiAgICBsb2FkV2VpZ2h0czogKHdlaWdodHNNYW5pZmVzdDogV2VpZ2h0c01hbmlmZXN0Q29uZmlnKSA9PiBQcm9taXNlPFtcbiAgICAgIC8qIHdlaWdodFNwZWNzICovIFdlaWdodHNNYW5pZmVzdEVudHJ5W10sIC8qIHdlaWdodERhdGEgKi8gQXJyYXlCdWZmZXJcbiAgICBdPik6IFByb21pc2U8TW9kZWxBcnRpZmFjdHM+IHtcbiAgbGV0IHdlaWdodFNwZWNzOiBXZWlnaHRzTWFuaWZlc3RFbnRyeVtdIHwgdW5kZWZpbmVkO1xuICBsZXQgd2VpZ2h0RGF0YTogQXJyYXlCdWZmZXIgfCB1bmRlZmluZWQ7XG5cbiAgaWYgKG1vZGVsSlNPTi53ZWlnaHRzTWFuaWZlc3QgIT0gbnVsbCkge1xuICAgIFt3ZWlnaHRTcGVjcywgd2VpZ2h0RGF0YV0gPSBhd2FpdCBsb2FkV2VpZ2h0cyhtb2RlbEpTT04ud2VpZ2h0c01hbmlmZXN0KTtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2RlbEFydGlmYWN0c0ZvckpTT05TeW5jKG1vZGVsSlNPTiwgd2VpZ2h0U3BlY3MsIHdlaWdodERhdGEpO1xufVxuXG4vKipcbiAqIFBvcHVsYXRlIE1vZGVsQXJ0aWZhY3RzSW5mbyBmaWVsZHMgZm9yIGEgbW9kZWwgd2l0aCBKU09OIHRvcG9sb2d5LlxuICogQHBhcmFtIG1vZGVsQXJ0aWZhY3RzXG4gKiBAcmV0dXJucyBBIE1vZGVsQXJ0aWZhY3RzSW5mbyBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNb2RlbEFydGlmYWN0c0luZm9Gb3JKU09OKG1vZGVsQXJ0aWZhY3RzOiBNb2RlbEFydGlmYWN0cyk6XG4gICAgTW9kZWxBcnRpZmFjdHNJbmZvIHtcbiAgaWYgKG1vZGVsQXJ0aWZhY3RzLm1vZGVsVG9wb2xvZ3kgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgSlNPTiBtb2RlbCB0b3BvbG9neSwgcmVjZWl2ZWQgQXJyYXlCdWZmZXIuJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRhdGVTYXZlZDogbmV3IERhdGUoKSxcbiAgICBtb2RlbFRvcG9sb2d5VHlwZTogJ0pTT04nLFxuICAgIG1vZGVsVG9wb2xvZ3lCeXRlczogbW9kZWxBcnRpZmFjdHMubW9kZWxUb3BvbG9neSA9PSBudWxsID9cbiAgICAgICAgMCA6XG4gICAgICAgIHN0cmluZ0J5dGVMZW5ndGgoSlNPTi5zdHJpbmdpZnkobW9kZWxBcnRpZmFjdHMubW9kZWxUb3BvbG9neSkpLFxuICAgIHdlaWdodFNwZWNzQnl0ZXM6IG1vZGVsQXJ0aWZhY3RzLndlaWdodFNwZWNzID09IG51bGwgP1xuICAgICAgICAwIDpcbiAgICAgICAgc3RyaW5nQnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShtb2RlbEFydGlmYWN0cy53ZWlnaHRTcGVjcykpLFxuICAgIHdlaWdodERhdGFCeXRlczogbW9kZWxBcnRpZmFjdHMud2VpZ2h0RGF0YSA9PSBudWxsID9cbiAgICAgICAgMCA6XG4gICAgICAgIG1vZGVsQXJ0aWZhY3RzLndlaWdodERhdGEuYnl0ZUxlbmd0aCxcbiAgfTtcbn1cblxuLyoqXG4gKiBDb25jYXRlbmF0ZSB0aGUgd2VpZ2h0cyBzdG9yZWQgaW4gYSBXZWlnaHRzTWFuaWZlc3RDb25maWcgaW50byBhIGxpc3Qgb2ZcbiAqIFdlaWdodHNNYW5pZmVzdEVudHJ5XG4gKlxuICogQHBhcmFtIHdlaWdodHNNYW5pZmVzdCBUaGUgV2VpZ2h0c01hbmlmZXN0Q29uZmlnIHRvIGV4dHJhY3Qgd2VpZ2h0cyBmcm9tLlxuICogQHJldHVybnMgQSBsaXN0IG9mIFdlaWdodHNNYW5pZmVzdEVudHJ5IG9mIHRoZSB3ZWlnaHRzIGluIHRoZSB3ZWlnaHRzTWFuaWZlc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdlaWdodFNwZWNzKHdlaWdodHNNYW5pZmVzdDogV2VpZ2h0c01hbmlmZXN0Q29uZmlnKTpcbiAgICBXZWlnaHRzTWFuaWZlc3RFbnRyeVtdIHtcbiAgY29uc3Qgd2VpZ2h0U3BlY3M6IFdlaWdodHNNYW5pZmVzdEVudHJ5W10gPSBbXTtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiB3ZWlnaHRzTWFuaWZlc3QpIHtcbiAgICB3ZWlnaHRTcGVjcy5wdXNoKC4uLmVudHJ5LndlaWdodHMpO1xuICB9XG4gIHJldHVybiB3ZWlnaHRTcGVjcztcbn1cblxuLyoqXG4gKiBDb21wdXRlcyBtYW50aXNhIHRhYmxlIGZvciBjYXN0aW5nIEZsb2F0MTYgdG8gRmxvYXQzMlxuICogU2VlIGh0dHA6Ly93d3cuZm94LXRvb2xraXQub3JnL2Z0cC9mYXN0aGFsZmZsb2F0Y29udmVyc2lvbi5wZGZcbiAqXG4gKiBAcmV0dXJucyBVaW50MzJBcnJheSwgMjA0OCBtYW50aXNzYSBsb29rdXAgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBjb21wdXRlRmxvYXQxNk1hbnRpc2FUYWJsZSgpOiBVaW50MzJBcnJheSB7XG4gIGNvbnN0IGNvbnZlcnRNYW50aXNzYSA9IChpOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgIGxldCBtID0gaSA8PCAxMztcbiAgICBsZXQgZSA9IDA7XG5cbiAgICB3aGlsZSAoKG0gJiAweDAwODAwMDAwKSA9PT0gMCkge1xuICAgICAgZSAtPSAweDAwODAwMDAwO1xuICAgICAgbSA8PD0gMTtcbiAgICB9XG4gICAgbSAmPSB+MHgwMDgwMDAwMDtcbiAgICBlICs9IDB4Mzg4MDAwMDA7XG5cbiAgICByZXR1cm4gbSB8IGU7XG4gIH07XG5cbiAgY29uc3QgbWFudGlzYVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KDIwNDgpO1xuXG4gIG1hbnRpc2FUYWJsZVswXSA9IDA7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgMTAyNDsgaSsrKSB7XG4gICAgbWFudGlzYVRhYmxlW2ldID0gY29udmVydE1hbnRpc3NhKGkpO1xuICB9XG4gIGZvciAobGV0IGkgPSAxMDI0OyBpIDwgMjA0ODsgaSsrKSB7XG4gICAgbWFudGlzYVRhYmxlW2ldID0gMHgzODAwMDAwMCArICgoaSAtIDEwMjQpIDw8IDEzKTtcbiAgfVxuXG4gIHJldHVybiBtYW50aXNhVGFibGU7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgZXhwb25lbnQgdGFibGUgZm9yIGNhc3RpbmcgRmxvYXQxNiB0byBGbG9hdDMyXG4gKiBTZWUgaHR0cDovL3d3dy5mb3gtdG9vbGtpdC5vcmcvZnRwL2Zhc3RoYWxmZmxvYXRjb252ZXJzaW9uLnBkZlxuICpcbiAqIEByZXR1cm5zIFVpbnQzMkFycmF5LCA2NCBleHBvbmVudCBsb29rdXAgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBjb21wdXRlRmxvYXQxNkV4cG9uZW50VGFibGUoKTogVWludDMyQXJyYXkge1xuICBjb25zdCBleHBvbmVudFRhYmxlID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcblxuICBleHBvbmVudFRhYmxlWzBdID0gMDtcbiAgZXhwb25lbnRUYWJsZVszMV0gPSAweDQ3ODAwMDAwO1xuICBleHBvbmVudFRhYmxlWzMyXSA9IDB4ODAwMDAwMDA7XG4gIGV4cG9uZW50VGFibGVbNjNdID0gMHhjNzgwMDAwMDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCAzMTsgaSsrKSB7XG4gICAgZXhwb25lbnRUYWJsZVtpXSA9IGkgPDwgMjM7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDMzOyBpIDwgNjM7IGkrKykge1xuICAgIGV4cG9uZW50VGFibGVbaV0gPSAweDgwMDAwMDAwICsgKChpIC0gMzIpIDw8IDIzKTtcbiAgfVxuXG4gIHJldHVybiBleHBvbmVudFRhYmxlO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIG9mZnNldCB0YWJsZSBmb3IgY2FzdGluZyBGbG9hdDE2IHRvIEZsb2F0MzJcbiAqIFNlZSBodHRwOi8vd3d3LmZveC10b29sa2l0Lm9yZy9mdHAvZmFzdGhhbGZmbG9hdGNvbnZlcnNpb24ucGRmXG4gKlxuICogQHJldHVybnMgVWludDMyQXJyYXksIDZkIG9mZnNldCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGbG9hdDE2T2Zmc2V0VGFibGUoKTogVWludDMyQXJyYXkge1xuICBjb25zdCBvZmZzZXRUYWJsZSA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgb2Zmc2V0VGFibGVbaV0gPSAxMDI0O1xuICB9XG4gIG9mZnNldFRhYmxlWzBdID0gb2Zmc2V0VGFibGVbMzJdID0gMDtcblxuICByZXR1cm4gb2Zmc2V0VGFibGU7XG59XG5cbi8qKlxuICogUmV0cmlldmUgYSBGbG9hdDE2IGRlY29kZXIgd2hpY2ggd2lsbCBkZWNvZGUgYSBCeXRlQXJyYXkgb2YgRmxvYXQxNiB2YWx1ZXNcbiAqIHRvIGEgRmxvYXQzMkFycmF5LlxuICpcbiAqIEByZXR1cm5zIEZ1bmN0aW9uIChidWZmZXI6IFVpbnQxNkFycmF5KSA9PiBGbG9hdDMyQXJyYXkgd2hpY2ggZGVjb2Rlc1xuICogICAgICAgICAgdGhlIFVpbnQxNkFycmF5IG9mIEZsb2F0MTYgYnl0ZXMgdG8gYSBGbG9hdDMyQXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGbG9hdDE2RGVjb2RlcigpOiAoYnVmZmVyOiBVaW50MTZBcnJheSkgPT4gRmxvYXQzMkFycmF5IHtcbiAgLy8gQWxnb3JpdGhtIGlzIGJhc2VkIG9mZiBvZlxuICAvLyBodHRwOi8vd3d3LmZveC10b29sa2l0Lm9yZy9mdHAvZmFzdGhhbGZmbG9hdGNvbnZlcnNpb24ucGRmXG5cbiAgLy8gQ2FjaGUgbG9va3VwIHRhYmxlc1xuICBjb25zdCBtYW50aXNhVGFibGUgPSBjb21wdXRlRmxvYXQxNk1hbnRpc2FUYWJsZSgpO1xuICBjb25zdCBleHBvbmVudFRhYmxlID0gY29tcHV0ZUZsb2F0MTZFeHBvbmVudFRhYmxlKCk7XG4gIGNvbnN0IG9mZnNldFRhYmxlID0gY29tcHV0ZUZsb2F0MTZPZmZzZXRUYWJsZSgpO1xuXG4gIHJldHVybiAocXVhbnRpemVkQXJyYXk6IFVpbnQxNkFycmF5KSA9PiB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQgKiBxdWFudGl6ZWRBcnJheS5sZW5ndGgpO1xuICAgIGNvbnN0IGJ1ZmZlclVpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcXVhbnRpemVkQXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBmbG9hdDE2Qml0cyA9IHF1YW50aXplZEFycmF5W2luZGV4XTtcbiAgICAgIGNvbnN0IGZsb2F0MzJCaXRzID1cbiAgICAgICAgICBtYW50aXNhVGFibGVbb2Zmc2V0VGFibGVbZmxvYXQxNkJpdHMgPj4gMTBdICsgKGZsb2F0MTZCaXRzICYgMHgzZmYpXSArXG4gICAgICAgICAgZXhwb25lbnRUYWJsZVtmbG9hdDE2Qml0cyA+PiAxMF07XG4gICAgICBidWZmZXJVaW50MzJWaWV3W2luZGV4XSA9IGZsb2F0MzJCaXRzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICB9O1xufVxuIl19