"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DocSidebarItems = void 0;
exports.default = DocSidebarItem;

var _react = _interopRequireWildcard(require("react"));

var _clsx = _interopRequireDefault(require("clsx"));

var _themeCommon = require("@docusaurus/theme-common");

var _Link = _interopRequireDefault(require("@docusaurus/Link"));

var _isInternalUrl = _interopRequireDefault(require("@docusaurus/isInternalUrl"));

var _Translate = require("@docusaurus/Translate");

var _IconExternalLink = _interopRequireDefault(require("@theme/IconExternalLink"));

var _stylesModule = _interopRequireDefault(require("./styles.module.css"));

var _useIsBrowser = _interopRequireDefault(require("@docusaurus/useIsBrowser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// Optimize sidebar at each "level"
// TODO this item should probably not receive the "activePath" props
// TODO this triggers whole sidebar re-renders on navigation
const DocSidebarItems = (0, _react.memo)(({
  items,
  ...props
}) => <>
      {items.map((item, index) => <DocSidebarItem key={index} // sidebar is static, the index does not change
  item={item} {...props} />)}
    </>);
exports.DocSidebarItems = DocSidebarItems;

function DocSidebarItem({
  item,
  ...props
}) {
  switch (item.type) {
    case 'category':
      if (item.items.length === 0) {
        return null;
      }

      return <DocSidebarItemCategory item={item} {...props} />;

    case 'link':
    default:
      return <DocSidebarItemLink item={item} {...props} />;
  }
} // If we navigate to a category and it becomes active, it should automatically expand itself


function useAutoExpandActiveCategory({
  isActive,
  collapsed,
  setCollapsed
}) {
  const wasActive = (0, _themeCommon.usePrevious)(isActive);
  (0, _react.useEffect)(() => {
    const justBecameActive = isActive && !wasActive;

    if (justBecameActive && collapsed) {
      setCollapsed(false);
    }
  }, [isActive, wasActive, collapsed, setCollapsed]);
} // When a collapsible category has no link, we still link it to its first child during SSR as a temporary fallback
// This allows to be able to navigate inside the category even when JS fails to load, is delayed or simply disabled
// React hydration becomes an optional progressive enhancement
// see https://github.com/facebookincubator/infima/issues/36#issuecomment-772543188
// see https://github.com/facebook/docusaurus/issues/3030


function useCategoryHrefWithSSRFallback(item) {
  const isBrowser = (0, _useIsBrowser.default)();
  return (0, _react.useMemo)(() => {
    if (item.href) {
      return item.href;
    } // In these cases, it's not necessary to render a fallback
    // We skip the "findFirstCategoryLink" computation


    if (isBrowser || !item.collapsible) {
      return undefined;
    }

    return (0, _themeCommon.findFirstCategoryLink)(item);
  }, [item, isBrowser]);
}

function DocSidebarItemCategory({
  item,
  onItemClick,
  activePath,
  level,
  ...props
}) {
  const {
    items,
    label,
    collapsible,
    className,
    href
  } = item;
  const hrefWithSSRFallback = useCategoryHrefWithSSRFallback(item);
  const isActive = (0, _themeCommon.isActiveSidebarItem)(item, activePath);
  const {
    collapsed,
    setCollapsed,
    toggleCollapsed
  } = (0, _themeCommon.useCollapsible)({
    // active categories are always initialized as expanded
    // the default (item.collapsed) is only used for non-active categories
    initialState: () => {
      if (!collapsible) {
        return false;
      }

      return isActive ? false : item.collapsed;
    }
  });
  useAutoExpandActiveCategory({
    isActive,
    collapsed,
    setCollapsed
  });
  return <li className={(0, _clsx.default)(_themeCommon.ThemeClassNames.docs.docSidebarItemCategory, _themeCommon.ThemeClassNames.docs.docSidebarItemCategoryLevel(level), 'menu__list-item', {
    'menu__list-item--collapsed': collapsed
  }, className)}>
      <div className="menu__list-item-collapsible">
        <_Link.default className={(0, _clsx.default)('menu__link', {
        'menu__link--sublist': collapsible && !href,
        'menu__link--active': isActive,
        [_stylesModule.default.menuLinkText]: !collapsible,
        [_stylesModule.default.hasHref]: !!hrefWithSSRFallback
      })} onClick={collapsible ? e => {
        onItemClick === null || onItemClick === void 0 ? void 0 : onItemClick(item);

        if (href) {
          setCollapsed(false);
        } else {
          e.preventDefault();
          toggleCollapsed();
        }
      } : () => {
        onItemClick === null || onItemClick === void 0 ? void 0 : onItemClick(item);
      }} href={collapsible ? hrefWithSSRFallback !== null && hrefWithSSRFallback !== void 0 ? hrefWithSSRFallback : '#' : hrefWithSSRFallback} {...props}>
          {label}
        </_Link.default>
        {href && collapsible && <button aria-label={(0, _Translate.translate)({
        id: 'theme.DocSidebarItem.toggleCollapsedCategoryAriaLabel',
        message: "Toggle the collapsible sidebar category '{label}'",
        description: 'The ARIA label to toggle the collapsible sidebar category'
      }, {
        label
      })} type="button" className="clean-btn menu__caret" onClick={e => {
        e.preventDefault();
        toggleCollapsed();
      }} />}
      </div>

      <_themeCommon.Collapsible lazy as="ul" className="menu__list" collapsed={collapsed}>
        <DocSidebarItems items={items} tabIndex={collapsed ? -1 : 0} onItemClick={onItemClick} activePath={activePath} level={level + 1} />
      </_themeCommon.Collapsible>
    </li>;
}

function DocSidebarItemLink({
  item,
  onItemClick,
  activePath,
  level,
  ...props
}) {
  const {
    href,
    label,
    className
  } = item;
  const isActive = (0, _themeCommon.isActiveSidebarItem)(item, activePath);
  return <li className={(0, _clsx.default)(_themeCommon.ThemeClassNames.docs.docSidebarItemLink, _themeCommon.ThemeClassNames.docs.docSidebarItemLinkLevel(level), 'menu__list-item', className)} key={label}>
      <_Link.default className={(0, _clsx.default)('menu__link', {
      'menu__link--active': isActive
    })} aria-current={isActive ? 'page' : undefined} to={href} {...(0, _isInternalUrl.default)(href) && {
      onClick: onItemClick ? () => onItemClick(item) : undefined
    }} {...props}>
        {(0, _isInternalUrl.default)(href) ? label : <span>
            {label}
            <_IconExternalLink.default />
          </span>}
      </_Link.default>
    </li>;
}