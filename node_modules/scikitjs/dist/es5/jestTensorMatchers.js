/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { getBackend } from './tf-singleton';
import { isTensor } from './typesUtils';
/**
 * Takes a flat index and turns it into an nd-index for
 * the given shape.
 *
 * @param flat Index into the flattened data array of a Tensor.
 * @param shape Shape of a Tensor.
 * @returns The nd-index into a Tensor of shape `shape`.
 */
function unravelIndex(flat, shape) {
    // see: https://numpy.org/doc/stable/reference/generated/numpy.unravel_index.html
    shape = shape.slice();
    for (var i = shape.length; i-- > 0;) {
        var si = shape[i];
        shape[i] = flat % si;
        flat = Math.trunc(flat / si);
    }
    return shape;
}
var isClose = function (_a) {
    var _b = _a.rtol, rtol = _b === void 0 ? 1e-3 : _b, _c = _a.atol, atol = _c === void 0 ? 1e-6 : _c;
    return function (x, y) {
        var xa = Math.abs(x);
        var ya = Math.abs(y);
        var tol = Math.max(xa, ya) * rtol + atol;
        return Math.abs(x - y) <= tol;
    };
};
var isLessOrClose = function (_a) {
    var _b = _a.rtol, rtol = _b === void 0 ? 1e-3 : _b, _c = _a.atol, atol = _c === void 0 ? 1e-6 : _c;
    return function (x, y) {
        var xa = Math.abs(x);
        var ya = Math.abs(y);
        var tol = Math.max(xa, ya) * rtol + atol;
        return x - y <= tol;
    };
};
var isLessNotClose = function (_a) {
    var _b = _a.rtol, rtol = _b === void 0 ? 1e-3 : _b, _c = _a.atol, atol = _c === void 0 ? 1e-6 : _c;
    return function (x, y) {
        var xa = Math.abs(x);
        var ya = Math.abs(y);
        var tol = Math.max(xa, ya) * rtol + atol;
        return x - y < -tol;
    };
};
export function toBeAll(result, expect, _a, description, match) {
    var _b = _a.broadcast, broadcast = _b === void 0 ? true : _b, _c = _a.allowEmpty, allowEmpty = _c === void 0 ? false : _c;
    var tf = getBackend();
    var isNot = this.isNot;
    var a = isTensor(result) ? result : tf.tensor(result);
    var b = isTensor(expect) ? expect : tf.tensor(expect);
    var msg = function (msg) { return function () {
        return "\nA: ".concat(a.toString(true)) +
            "\nB: ".concat(b.toString(true)) +
            "\nExpected A ".concat(isNot ? 'not ' : '', "to be all ").concat(description, " B but:\n").concat(msg);
    }; };
    var rankA = a.rank;
    var rankB = b.rank;
    var rank = Math.max(rankA, rankB);
    var shapeA = a.shape;
    var shapeB = b.shape;
    var shape = __spreadArray([], __read((rankB < rankA ? shapeA : shapeB)), false);
    // CHECK SHAPES
    // ------------
    {
        var i = rankA;
        var j = rankB;
        if (broadcast) {
            while (i-- > 0 && j-- > 0) {
                var sa = shapeA[i];
                var sb = shapeB[j];
                if (sa !== sb && sa !== 1 && sb !== 1) {
                    return {
                        message: msg('A.shape not broadcast-compatible to B.shape'),
                        pass: isNot
                    };
                }
                shape[Math.max(i, j)] = Math.max(sa, sb);
            }
        }
        else {
            if (i !== j) {
                return {
                    message: msg('A.shape does not match B.shape'),
                    pass: isNot
                };
            }
            while (i-- > 0 && j-- > 0) {
                if (shapeA[i] !== shapeB[j]) {
                    return {
                        message: msg('A.shape does not match B.shape'),
                        pass: isNot
                    };
                }
            }
        }
    }
    // CHECK DATA
    // ----------
    // flattened data
    var aFlat = a.dataSync();
    var bFlat = b.dataSync();
    if (aFlat.length === 0 || bFlat.length === 0) {
        return {
            pass: allowEmpty !== isNot,
            message: msg('Empty shape(s) encountered.')
        };
    }
    // indices into flattened data
    var ia = 0;
    var ib = 0;
    // inside of `visit(axis)`, stride counts amount of
    // element that had been visited by a call to
    // `visit(axis+1)`. Used to repeat elements along
    // axis in case of broadcasting
    var strideA;
    var strideB;
    /* Visits broadcasted pairs of entries. Needs
     * to be recursive to allow for arbitrary ranks.
     */
    function visit(axis) {
        var _a, _b;
        if (axis === rank) {
            if (!match(aFlat[ia], bFlat[ib])) {
                throw msg("A[".concat(unravelIndex(ia, shapeA), "] = ").concat(aFlat[ia], "\n") +
                    "B[".concat(unravelIndex(ib, shapeB), "] = ").concat(bFlat[ib]));
            }
            strideA = 1;
            strideB = 1;
            ia++;
            ib++;
        }
        else {
            for (var i = 0;;) {
                visit(axis + 1);
                if (++i >= shape[axis]) {
                    break;
                }
                // Broadcasting cases, repeat entries alond axis.
                // Utilizes fact that `shape[i < 0] === undefined`.
                if (!(shapeA[axis - rank + rankA] > 1))
                    ia -= strideA;
                if (!(shapeB[axis - rank + rankB] > 1))
                    ib -= strideB;
            }
            strideA *= (_a = shapeA[axis - rank + rankA]) !== null && _a !== void 0 ? _a : 1;
            strideB *= (_b = shapeB[axis - rank + rankB]) !== null && _b !== void 0 ? _b : 1;
        }
    }
    try {
        visit(0);
        return { pass: true, message: msg('It is.') };
    }
    catch (message) {
        return { pass: false, message: message };
    }
}
export function toBeAllCloseTo(result, expect, params) {
    if (params === void 0) { params = {}; }
    return toBeAll.call(this, result, expect, params, 'close to', isClose(params));
}
export function toBeAllLessOrClose(result, expect, params) {
    if (params === void 0) { params = {}; }
    return toBeAll.call(this, result, expect, params, 'close to or less than', isLessOrClose(params));
}
export function toBeAllGreaterOrClose(result, expect, params) {
    if (params === void 0) { params = {}; }
    var le = isLessOrClose(params);
    return toBeAll.call(this, result, expect, params, 'close to or greater than', function (x, y) { return le(y, x); });
}
export function toBeAllLessNotClose(result, expect, params) {
    if (params === void 0) { params = {}; }
    return toBeAll.call(this, result, expect, params, 'less than not close to', isLessNotClose(params));
}
export function toBeAllGreaterNotClose(result, expect, params) {
    if (params === void 0) { params = {}; }
    var le = isLessNotClose(params);
    return toBeAll.call(this, result, expect, params, 'greater than not close to', function (x, y) { return le(y, x); });
}
expect.extend({
    toBeAllCloseTo: toBeAllCloseTo,
    toBeAllLessOrClose: toBeAllLessOrClose,
    toBeAllLessNotClose: toBeAllLessNotClose,
    toBeAllGreaterOrClose: toBeAllGreaterOrClose,
    toBeAllGreaterNotClose: toBeAllGreaterNotClose
});
