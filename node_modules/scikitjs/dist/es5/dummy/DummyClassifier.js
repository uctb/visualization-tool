/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { convertToNumericTensor1D, convertToNumericTensor2D } from '../utils';
import { isScikit2D, assert, isScikit1D } from '../typesUtils';
import { modeFast } from 'simple-statistics';
import uniq from 'lodash/uniq';
import sample from 'lodash/sample';
import { ClassifierMixin } from '../mixins';
import { getBackend } from '../tf-singleton';
/**
 * Creates an classifier that guesses a class label based on simple rules.
 * By setting a strategy (ie 'mostFrequent', 'uniform', or 'constant'),
 * you can create a simple classifier which can be helpful in determining
 * if a more complicated classifier is actually more predictive.
 *
 * @example
 * ```js
 * import { DummyClassifier } from 'scikitjs'
 *
 * const clf = new DummyClassifier({ strategy: 'mostFrequent' })
    const X = [
      [-1, 5],
      [-0.5, 5],
      [0, 10]
    ]
    const y = [10, 20, 20] // 20 is the most frequent class label
    clf.fit(X, y) // always predicts 20

    clf.predict([
      [0, 0],
      [1000, 1000]
    ]) // [20, 20]


 * ```
 *
 */
var DummyClassifier = /** @class */ (function (_super) {
    __extends(DummyClassifier, _super);
    function DummyClassifier(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.strategy, strategy = _c === void 0 ? 'mostFrequent' : _c, _d = _b.constant, constant = _d === void 0 ? 0 : _d;
        var _this = _super.call(this) || this;
        /** Useful for pipelines and column transformers to have a default name for transforms */
        _this.name = 'DummyClassifier';
        _this.tf = getBackend();
        _this.constant = constant;
        _this.strategy = strategy;
        _this.classes = [];
        return _this;
    }
    /**
     * Fit a DummyClassifier to the data.
     */
    DummyClassifier.prototype.fit = function (X, y) {
        assert(isScikit1D(y), 'Data can not be converted to a 1D or 2D matrix.');
        assert(['mostFrequent', 'uniform', 'constant'].includes(this.strategy), "Strategy ".concat(this.strategy, " not supported. We support 'mostFrequent', 'uniform', and 'constant'"));
        var newY = convertToNumericTensor1D(y);
        this.classes = uniq(newY.arraySync());
        if (this.strategy === 'mostFrequent') {
            this.constant = modeFast(newY.arraySync());
            return this;
        }
        // Handles 'constant' and 'uniform' case
        return this;
    };
    DummyClassifier.prototype.predictProba = function (X) {
        assert(isScikit2D(X), 'Data can not be converted to a 1D or 2D matrix.');
        assert(['mostFrequent', 'uniform', 'constant'].includes(this.strategy), "Strategy ".concat(this.strategy, " not supported. We support 'mostFrequent', 'uniform', and 'constant'"));
        return this.tf.oneHot(this.predict(X).toInt(), this.classes.length);
    };
    DummyClassifier.prototype.predict = function (X) {
        assert(isScikit2D(X), 'Data can not be converted to a 1D or 2D matrix.');
        assert(['mostFrequent', 'uniform', 'constant'].includes(this.strategy), "Strategy ".concat(this.strategy, " not supported. We support 'mostFrequent', 'uniform', and 'constant'"));
        var newData = convertToNumericTensor2D(X);
        var length = newData.shape[0];
        if (this.strategy === 'mostFrequent' || this.strategy === 'constant') {
            return this.tf.tensor1d(Array(length).fill(this.constant));
        }
        // "Uniform case"
        var returnArr = [];
        for (var i = 0; i < length; i++) {
            returnArr.push(sample(this.classes));
        }
        return this.tf.tensor1d(returnArr);
    };
    return DummyClassifier;
}(ClassifierMixin));
export { DummyClassifier };
