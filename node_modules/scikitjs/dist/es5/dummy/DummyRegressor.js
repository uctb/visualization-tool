/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { convertToNumericTensor1D, convertToNumericTensor2D } from '../utils';
import { assert, isScikit1D, isScikit2D } from '../typesUtils';
import { median, quantileSeq } from 'mathjs';
import { RegressorMixin } from '../mixins';
import { getBackend } from '../tf-singleton';
/** Builds a regressor with simple rules.
 *
 * @example
 * ```js
 * import { DummyRegressor } from 'scikitjs'
 * const reg = new DummyRegressor({ strategy: 'mean' })

    const X = [
      [-1, 5],
      [-0.5, 5],
      [0, 10]
    ]
    const y = [10, 20, 30] // The mean is 20
    reg.fit(X, y) // This regressor will return 20 for any input
 * ```
 */
var DummyRegressor = /** @class */ (function (_super) {
    __extends(DummyRegressor, _super);
    function DummyRegressor(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.strategy, strategy = _c === void 0 ? 'mean' : _c, constant = _b.constant, quantile = _b.quantile;
        var _this = _super.call(this) || this;
        /** Useful for pipelines and column transformers to have a default name for transforms */
        _this.name = 'DummyRegressor';
        _this.tf = getBackend();
        _this.strategy = strategy;
        _this.constant = constant;
        _this.quantile = quantile;
        return _this;
    }
    DummyRegressor.prototype.fit = function (X, y) {
        assert(isScikit1D(y), 'y variable can not be converted to a 1D Tensor.');
        assert(['mean', 'median', 'constant', 'quantile'].includes(this.strategy), "Strategy ".concat(this.strategy, " not supported. We support 'mean', 'median', 'constant', and 'quantile'"));
        var newY = convertToNumericTensor1D(y);
        if (this.strategy === 'mean') {
            this.constant = newY.mean().dataSync()[0];
            return this;
        }
        if (this.strategy === 'median') {
            this.constant = median(newY.arraySync());
            return this;
        }
        if (this.strategy === 'quantile') {
            assert(typeof this.quantile === 'number' &&
                !isNaN(this.quantile) &&
                isFinite(this.quantile), 'quantile is not set to a number. Please set it to a value between 0 and 1 in the constructor');
            assert(this.quantile < 0 || this.quantile > 1, 'quantile must be set to a value between 0 and 1');
            this.constant = quantileSeq(newY.arraySync(), this.quantile);
            return this;
        }
        // Handles 'constant' case
        return this;
    };
    DummyRegressor.prototype.predict = function (X) {
        assert(isScikit2D(X), 'Data can not be converted to a 2D matrix.');
        var newData = convertToNumericTensor2D(X);
        var length = newData.shape[0];
        return this.tf.tensor1d(Array(length).fill(this.constant));
    };
    return DummyRegressor;
}(RegressorMixin));
export { DummyRegressor };
