/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
import { assert } from '../typesUtils';
import { getBackend } from '../tf-singleton';
var minkowskiTensorDistance = function (p) { return function (u, v) {
    var _a, _b;
    var tf = getBackend();
    // FIXME: tf.norm still underflows and overflows,
    // see: https://github.com/tensorflow/tfjs/issues/895
    var m = (_a = u.shape[u.rank - 1]) !== null && _a !== void 0 ? _a : NaN;
    var n = (_b = v.shape[v.rank - 1]) !== null && _b !== void 0 ? _b : NaN;
    assert(m === n, "minkowskiDistance(".concat(p, ").tensorDistance(u,v): u.shape[-1] must equal v.shape[-1]."));
    return tf.tidy(function () {
        return tf.norm(tf.sub(u, v), p, -1);
    });
}; };
/**
 * Returns the Minkowski distance metric with the given power `p`.
 * It is equivalent to the p-norm of the absolute difference
 * between two vectors.
 *
 * @param p The power/exponent of the Minkowski distance.
 * @returns `(X,y) => sum[i]( |X[:,i]-y[i]|**p ) ** (1/p)`
 */
export var minkowskiMetric = function (p) {
    switch (p) {
        case 1:
            return manhattanMetric;
        case 2:
            return euclideanMetric;
        case Infinity:
            return chebyshevMetric;
    }
    assert(1 <= p, 'minkowskiMetric(p): Invalid p.');
    var metric = {
        tensorDistance: minkowskiTensorDistance(p),
        distance: function (u, v) {
            var len = u.length;
            if (len !== v.length) {
                throw new Error("minkowskiMetric(".concat(p, ").treeMetric(u,v): u and v must have same length."));
            }
            // since we are aming at float32 precision, this
            // implementation is not underflow-/ overflow-safe
            // TODO: if tfjs ever adds float64, make this underflow-safe
            var norm = 0;
            for (var i = 0; i < len; i++) {
                norm += Math.pow(Math.abs(u[i] - v[i]), p);
            }
            return Math.pow(norm, (1 / p));
        },
        distToBBox: function (pt, bBox) {
            if (pt.length * 2 != bBox.length) {
                throw new Error("minkowskiMetric(".concat(p, ").treeMetric.minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length."));
            }
            var norm = 0;
            for (var j = 0, i = 0; i < pt.length; i++) {
                var x = Math.max(0, bBox[j++] - pt[i], pt[i] - bBox[j++]);
                norm += Math.pow(x, p);
            }
            return Math.pow(norm, (1 / p));
        },
        name: "minkowskiMetric(".concat(p, ")"),
        toString: function () {
            return this.name;
        }
    };
    return Object.freeze(metric);
};
var manhattanMetric = Object.freeze({
    tensorDistance: minkowskiTensorDistance(1),
    distance: function (u, v) {
        var len = u.length;
        if (len !== v.length) {
            throw new Error("minkowskiMetric(1).distance(u,v): u and v must have same length.");
        }
        var norm = 0;
        for (var i = 0; i < len; i++) {
            norm += Math.abs(u[i] - v[i]);
        }
        return norm;
    },
    minDistToBBox: function (pt, bBox) {
        var len = bBox.length;
        if (len !== pt.length << 1) {
            throw new Error("minkowskiMetric(1).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.");
        }
        var norm = 0;
        for (var i = 0; i < len;) {
            var pi = pt[i >>> 1];
            // const x = Math.max(0, bBox[i++] - pi, pi - bBox[i++])
            var u = bBox[i++] - pi;
            var v = pi - bBox[i++];
            var x = 0.5 * (Math.abs(u) + u + (Math.abs(v) + v));
            norm += x;
        }
        return norm;
    },
    name: 'manhattanMetric',
    toString: function () {
        return this.name;
    }
});
var euclideanMetric = Object.freeze({
    tensorDistance: minkowskiTensorDistance(2),
    distance: function (u, v) {
        var len = u.length;
        if (len !== v.length) {
            throw new Error("minkowskiMetric(2).distance(u,v): u and v must have same length.");
        }
        var norm = 0;
        for (var i = 0; i < len; i++) {
            var x = u[i] - v[i];
            norm += x * x;
        }
        return Math.sqrt(norm);
    },
    minDistToBBox: function (pt, bBox) {
        var len = bBox.length;
        if (len !== pt.length * 2) {
            throw new Error("minkowskiMetric(2).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.");
        }
        var norm = 0;
        for (var i = 0; i < len;) {
            var pi = pt[i >>> 1];
            // const x = Math.max(0, bBox[i++] - pi, pi - bBox[i++])
            var u = bBox[i++] - pi;
            var v = pi - bBox[i++];
            var x = 0.5 * (Math.abs(u) + u + (Math.abs(v) + v));
            norm += x * x;
        }
        return Math.sqrt(norm);
    },
    name: 'euclideanMetric',
    toString: function () {
        return this.name;
    }
});
var chebyshevMetric = Object.freeze({
    tensorDistance: minkowskiTensorDistance(Infinity),
    distance: function (u, v) {
        var len = u.length;
        if (len !== v.length) {
            throw new Error("minkowskiMetric(Infinity).distance(u,v): u and v must have same length.");
        }
        var norm = 0;
        for (var i = 0; i < len; i++) {
            var x = Math.abs(u[i] - v[i]);
            norm = Math.max(norm, x);
        }
        return norm;
    },
    minDistToBBox: function (pt, bBox) {
        var len = bBox.length;
        if (len !== pt.length * 2) {
            throw new Error("minkowskiMetric(Infinity).minDistToBBox(pt,bBox): pt.length*2 must equal bBox.length.");
        }
        var norm = -Infinity;
        for (var i = 0; i < len;) {
            var pi = pt[i >>> 1];
            // const x = Math.max(0, bBox[i++] - pi, pi - bBox[i++])
            var u = bBox[i++] - pi;
            var v = pi - bBox[i++];
            var x = 0.5 * (Math.abs(u) + u + (Math.abs(v) + v));
            norm = Math.max(norm, x);
        }
        return norm;
    },
    name: 'chebyshevMetric',
    toString: function () {
        return this.name;
    }
});
