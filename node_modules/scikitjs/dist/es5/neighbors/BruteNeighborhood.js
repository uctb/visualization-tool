/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
import { assert } from '../typesUtils';
import { getBackend } from '../tf-singleton';
/**
 * A {@link Neighborhood} implementation that uses a brute force approach
 * to nearest neighbor search. During a {@link BruteNeighborhood#kNearest}
 * query, the distance between every entry and the query point is computed.
 */
var BruteNeighborhood = /** @class */ (function () {
    function BruteNeighborhood(_a) {
        var metric = _a.metric, entries = _a.entries;
        this._metric = metric;
        this._entries = entries;
        this.tf = getBackend();
    }
    BruteNeighborhood.prototype.kNearest = function (k, queryPoints) {
        var _this = this;
        var _a = this, _metric = _a._metric, _entries = _a._entries;
        assert(_entries.shape[1] == queryPoints.shape[1], 'X_train.shape[1] must equal X_predict.shape[1]');
        // // batched version
        // const [m, n] = queryPoints.shape
        // return this.tf.tidy(() => {
        //   const negDist = _metric.tensorDistance(
        //     queryPoints.reshape([m, 1, n]),
        //     _entries
        //   ).neg() as Tensor2D
        //   const { values, indices } = this.tf.topk(negDist, k)
        //   return { distances: values.neg(), indices }
        // })
        // unbatched version
        return this.tf.tidy(function () {
            var result = _this.tf.unstack(queryPoints).map(function (queryPoint) {
                return _this.tf.tidy(function () {
                    var dist = _metric.tensorDistance(queryPoint, _entries).neg();
                    var _a = _this.tf.topk(dist, k), values = _a.values, indices = _a.indices;
                    return [values, indices];
                });
            });
            return {
                distances: _this.tf
                    .stack(result.map(function (x) { return x[0]; }))
                    .neg(),
                indices: _this.tf.stack(result.map(function (x) { return x[1]; }))
            };
        });
    };
    return BruteNeighborhood;
}());
export { BruteNeighborhood };
