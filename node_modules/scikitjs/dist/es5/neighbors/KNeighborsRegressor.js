/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { KNeighborsBase } from './KNeighborsBase';
import { convertToNumericTensor2D } from '../utils';
import { getBackend } from '../tf-singleton';
/**
 * K-Nearest neighbor regressor.
 *
 * @example
 * ```js
 * import {KNeighborsRegressor} from 'scikitjs'
 *
 * let X = [[0], [1], [2], [3]]
 * let y = [0, 0, 1, 1]
 *
 * let knn = new KNeighborsRegressor(nNeighbor)
 *
 * await knn.fit(X, y)
 *
 * knn.predict([[1.5]]).print()
 * ```
 */
var KNeighborsRegressor = /** @class */ (function (_super) {
    __extends(KNeighborsRegressor, _super);
    function KNeighborsRegressor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Applies this mdodel to predicts the target of each given sample.
         *
         * @param X The samples for which the targets are to be predicted,
         *          where `X[i,j]` is the (j+1)-th feature of the (i+1)-th
         *          sample.
         * @param y The predicted targets `y` where `y[i]` is the prediction
         *          for sample `X[i,:]`
         */
        _this.name = 'KNeighborsRegressor';
        return _this;
    }
    KNeighborsRegressor.prototype.predict = function (X) {
        var tf = getBackend();
        var _a = this._getFitParams(), neighborhood = _a.neighborhood, y = _a.y, nNeighbors = _a.nNeighbors, weightsFn = _a.weightsFn;
        return tf.tidy(function () {
            var _X = convertToNumericTensor2D(X);
            var _a = neighborhood.kNearest(nNeighbors, _X), distances = _a.distances, indices = _a.indices;
            var targets = y.gather(indices);
            var weights = weightsFn(distances);
            return tf
                .matMul(targets.reshape([-1, 1, nNeighbors]), weights.reshape([-1, nNeighbors, 1]))
                .as1D();
        });
    };
    return KNeighborsRegressor;
}(KNeighborsBase));
export { KNeighborsRegressor };
