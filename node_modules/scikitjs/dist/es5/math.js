import { assert } from './typesUtils';
import { getBackend } from './tf-singleton';
/*
In creating the preprocessors, I wanted functions that computed the min, max, mean,
etc... but that also ignored NaN values. The min / max functions that come from
Tensorflow don't support ignoring NaN's, so we perform some magic to get the result.

After running some tests, I've concluded that the fastest way to
get the min, mean, median, most_frequent, etc... is to not copy the input array.
So the "fastest" way to perform any action is to simply loop over the initial
array if the user passes in an array, or to use Tensor methods if the user
passes in a Tensor.

The "copying" of the array into a tf Tensor is way slower than simply writing the
for loop.

So below we have simple mean, max, min, functions that work with arrays, or tensors
that ignore NaNs
*/
//////////////////////////////////////////////////////////////////////////
// Min Functions
//////////////////////////////////////////////////////////////////////////
export function simpleMin(arr, ignoreNaN) {
    assert(arr.length > 0, "Array ".concat(arr, " must have length greater than 0 in order to find a minimum element"));
    var min = arr[0];
    for (var i = 0; i < arr.length; i++) {
        var current = arr[i];
        if (ignoreNaN && isNaN(current)) {
            continue;
        }
        if (current < min) {
            min = current;
        }
    }
    return min;
}
export function tensorMin(tensor, axis, ignoreNaN) {
    var tf = getBackend();
    if (ignoreNaN) {
        return tf.tidy(function () { return tf.where(tensor.isNaN(), Infinity, tensor).min(axis); });
    }
    return tensor.min(axis);
}
//////////////////////////////////////////////////////////////////////////
// Max Functions
//////////////////////////////////////////////////////////////////////////
export function simpleMax(arr, ignoreNaN) {
    assert(arr.length > 0, "Array ".concat(arr, " must have length greater than 0 in order to find a maximum element"));
    var max = arr[0];
    for (var i = 0; i < arr.length; i++) {
        var current = arr[i];
        if (ignoreNaN && isNaN(current)) {
            continue;
        }
        if (current > max) {
            max = current;
        }
    }
    return max;
}
export function tensorMax(tensor, axis, ignoreNaN) {
    var tf = getBackend();
    if (ignoreNaN) {
        return tf.tidy(function () { return tf.where(tensor.isNaN(), -Infinity, tensor).max(axis); });
    }
    return tensor.min(axis);
}
//////////////////////////////////////////////////////////////////////////
// Sum Functions
//////////////////////////////////////////////////////////////////////////
export function simpleSum(arr, ignoreNaN) {
    var total = 0;
    for (var i = 0; i < arr.length; i++) {
        var current = arr[i];
        if (ignoreNaN && isNaN(current)) {
            continue;
        }
        total += Number(current);
    }
    return total;
}
export function tensorSum(tensor, axis, ignoreNaN) {
    var tf = getBackend();
    if (ignoreNaN) {
        return tf.tidy(function () { return tf.where(tensor.isNaN(), 0, tensor).sum(axis); });
    }
    return tensor.sum(axis);
}
//////////////////////////////////////////////////////////////////////////
// Count Functions
//////////////////////////////////////////////////////////////////////////
export function simpleCount(arr, ignoreNaN) {
    if (!ignoreNaN) {
        return arr.length;
    }
    var count = 0;
    for (var i = 0; i < arr.length; i++) {
        var current = arr[i];
        if (isNaN(current)) {
            continue;
        }
        count += 1;
    }
    return count;
}
export function tensorCount(tensor, axis, ignoreNaN) {
    var tf = getBackend();
    if (ignoreNaN) {
        return tf.tidy(function () { return tf.logicalNot(tensor.isNaN()).sum(axis); });
    }
    // Could definitely do this faster
    return tf.onesLike(tensor).sum(axis);
}
//////////////////////////////////////////////////////////////////////////
// Mean Functions
//////////////////////////////////////////////////////////////////////////
export function simpleMean(arr) {
    var count = simpleCount(arr);
    if (count === 0) {
        return 0;
    }
    var sum = simpleSum(arr);
    return sum / count;
}
export function tensorMean(tensor, axis, ignoreNaN, safe) {
    var tf = getBackend();
    if (!ignoreNaN) {
        return tensor.mean(axis);
    }
    if (safe) {
        return tf.tidy(function () {
            return tensorSum(tensor, axis, ignoreNaN).div(turnZerosToOnes(tensorCount(tensor, axis, ignoreNaN)));
        });
    }
    return tf.tidy(function () {
        return tensorSum(tensor, axis, ignoreNaN).div(tensorCount(tensor, axis, ignoreNaN));
    });
}
//////////////////////////////////////////////////////////////////////////
// Std Functions
//////////////////////////////////////////////////////////////////////////
export function tensorStd(tensor, dim, ignoreNaN) {
    assert(Boolean(ignoreNaN), 'We only need to call this function when ignoreNaN is true');
    var tf = getBackend();
    return tf.tidy(function () {
        var mean = tensorMean(tensor, dim, ignoreNaN);
        var countNaN = tensorCount(tensor, dim, ignoreNaN);
        var numerator = tensorSum(tensor.sub(mean).square(), dim, ignoreNaN);
        // Choose biased variance over unbiased to match sklearn
        var denominator = turnZerosToOnes(countNaN);
        return numerator.div(denominator).sqrt();
    });
}
export function turnZerosToOnes(tensor) {
    var tf = getBackend();
    return tf.tidy(function () {
        var zeros = tf.zerosLike(tensor);
        var booleanAddition = tensor.equal(zeros);
        return tensor.add(booleanAddition);
    });
}
