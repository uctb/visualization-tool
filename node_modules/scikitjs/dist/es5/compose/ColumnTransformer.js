var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { isDataFrameInterface } from '../typesUtils';
import { getBackend } from '../tf-singleton';
import { Serialize } from '../simpleSerializer';
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isStringArray(arr) {
    return Array.isArray(arr) && typeof arr[0] === 'string';
}
/**
 * The ColumnTransformer transformers a 2D matrix of mixed types, with possibly missing values
 * into a 2DMatrix that is ready to be put into a machine learning model. Usually this class does
 * the heavy lifting associated with imputing missing data, one hot encoding categorical variables,
 * and any other preprocessing steps that are deemed necessary (standard scaling, etc).
 *
 * @example
 * ```typescript
    const X = [
      [2, 2],
      [2, 3],
      [0, NaN],
      [2, 0]
    ]

    const transformer = new ColumnTransformer({
      transformers: [
        ['minmax', new MinMaxScaler(), [0]],
        ['simpleImpute', new SimpleImputer({ strategy: 'median' }), [1]]
      ]
    })

    let result = transformer.fitTransform(X)
    const expected = [
      [1, 2],
      [1, 3],
      [0, 2],
      [1, 0]
    ]
 * ```
 */
var ColumnTransformer = /** @class */ (function (_super) {
    __extends(ColumnTransformer, _super);
    function ColumnTransformer(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.transformers, transformers = _c === void 0 ? [] : _c, _d = _b.remainder, remainder = _d === void 0 ? 'drop' : _d;
        var _this = _super.call(this) || this;
        /** Useful for pipelines and column transformers to have a default name for transforms */
        _this.name = 'ColumnTransformer';
        _this.tf = getBackend();
        _this.transformers = transformers;
        _this.remainder = remainder;
        return _this;
    }
    ColumnTransformer.prototype.fit = function (X, y) {
        for (var i = 0; i < this.transformers.length; i++) {
            var _a = __read(this.transformers[i], 3), curTransform = _a[1], selection = _a[2];
            var subsetX = this.getColumns(X, selection);
            curTransform.fit(subsetX, y);
        }
        return this;
    };
    ColumnTransformer.prototype.transform = function (X, y) {
        var output = [];
        for (var i = 0; i < this.transformers.length; i++) {
            var _a = __read(this.transformers[i], 3), curTransform = _a[1], selection = _a[2];
            var subsetX = this.getColumns(X, selection);
            output.push(curTransform.transform(subsetX, y));
        }
        return this.tf.concat(output, 1);
    };
    ColumnTransformer.prototype.fitTransform = function (X, y) {
        var output = [];
        for (var i = 0; i < this.transformers.length; i++) {
            var _a = __read(this.transformers[i], 3), curTransform = _a[1], selection = _a[2];
            var subsetX = this.getColumns(X, selection);
            output.push(curTransform.fitTransform(subsetX, y));
        }
        return this.tf.concat(output, 1);
    };
    ColumnTransformer.prototype.getColumns = function (X, selectedColumns) {
        if (isDataFrameInterface(X)) {
            if (isStringArray(selectedColumns)) {
                return X.loc({ columns: selectedColumns })
                    .tensor;
            }
            if (Array.isArray(selectedColumns)) {
                return X.iloc({ columns: selectedColumns })
                    .tensor;
            }
            if (typeof selectedColumns === 'string') {
                return X[selectedColumns].tensor;
            }
            return X.iloc({ columns: [selectedColumns] })
                .tensor;
        }
        else {
            if (isStringArray(selectedColumns) ||
                typeof selectedColumns === 'string') {
                throw new Error("Can't pass string selected columns when not a DataFrame");
            }
            if (typeof selectedColumns === 'number') {
                var columns = this.tf.tensor1d([selectedColumns]);
                return X.gather(columns, 1);
            }
            else {
                var columns = this.tf.tensor1d(selectedColumns);
                return X.gather(columns, 1);
            }
        }
    };
    return ColumnTransformer;
}(Serialize));
export { ColumnTransformer };
