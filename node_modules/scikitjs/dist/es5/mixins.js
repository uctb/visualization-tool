var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { r2Score, accuracyScore } from './metrics/metrics';
import { Serialize } from './simpleSerializer';
import { assert, isScikit2D } from './typesUtils';
import { convertToNumericTensor1D_2D } from './utils';
var TransformerMixin = /** @class */ (function (_super) {
    __extends(TransformerMixin, _super);
    function TransformerMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TransformerMixin.prototype.fitTransform = function (X) {
        return this.fit(X).transform(X);
    };
    return TransformerMixin;
}(Serialize));
export { TransformerMixin };
var PredictorMixin = /** @class */ (function () {
    function PredictorMixin() {
    }
    PredictorMixin.prototype.fitPredict = function (X, y) {
        return this.fit(X, y).predict(X);
    };
    return PredictorMixin;
}());
export { PredictorMixin };
var RegressorMixin = /** @class */ (function (_super) {
    __extends(RegressorMixin, _super);
    function RegressorMixin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.EstimatorType = 'regressor';
        return _this;
    }
    RegressorMixin.prototype.score = function (X, y) {
        var yPred = this.predict(X);
        return r2Score(y, yPred);
    };
    return RegressorMixin;
}(Serialize));
export { RegressorMixin };
var ClassifierMixin = /** @class */ (function (_super) {
    __extends(ClassifierMixin, _super);
    function ClassifierMixin() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.EstimatorType = 'classifier';
        return _this;
    }
    ClassifierMixin.prototype.score = function (X, y) {
        var yPred = this.predict(X);
        var yTrue = convertToNumericTensor1D_2D(y);
        assert(yPred.shape.length === yTrue.shape.length, "The shape of the model output doesn't match the shape of the actual y values");
        if (isScikit2D(y)) {
            return accuracyScore(yTrue.argMax(1), yPred.argMax(1));
        }
        return accuracyScore(y, yPred);
    };
    return ClassifierMixin;
}(Serialize));
export { ClassifierMixin };
export var mixins = function (baseClass) {
    var mixins = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        mixins[_i - 1] = arguments[_i];
    }
    var base = /** @class */ (function (_super) {
        __extends(base, _super);
        function base() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
            mixins.forEach(function (mixin) {
                copyProps(_this, new mixin());
            });
            return _this;
        }
        return base;
    }(baseClass));
    var copyProps = function (target, source) {
        // this function copies all properties and symbols, filtering out some special ones
        Object.getOwnPropertyNames(source)
            .concat(Object.getOwnPropertySymbols(source))
            .forEach(function (prop) {
            if (!prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/))
                Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
        });
    };
    mixins.forEach(function (mixin) {
        // outside contructor() to allow aggregation(A,B,C).staticFunction() to be called etc.
        copyProps(base.prototype, mixin.prototype);
        copyProps(base, mixin);
    });
    return base;
};
