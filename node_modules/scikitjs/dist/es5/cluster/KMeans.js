var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { convertToNumericTensor2D, sampleWithoutReplacement } from '../utils';
import { getBackend } from '../tf-singleton';
import { Serialize } from '../simpleSerializer';
/**
 * The KMeans algorithm clusters data by trying to separate samples into `k` groups
 * of equal variance, minimizing a criterion known as the inertia or within-cluster sum-of-squares.
 *
 * <!-- prettier-ignore-start -->
 * $$
 * \sum_{i=0}^{n}\min_{\mu_j \in C}(||x_i - \mu_j||^2)
 * $$
 *
 * @example
 * ```js
 * let X = [
 *  [1, 2],
    [1, 4],
    [4, 4],
    [4, 0]
   ]
   const kmean = new KMeans({ nClusters: 2 })
   kmean.fit(X)
   ```
 */
var KMeans = /** @class */ (function (_super) {
    __extends(KMeans, _super);
    function KMeans(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.nClusters, nClusters = _c === void 0 ? 8 : _c, _d = _b.init, init = _d === void 0 ? 'random' : _d, _e = _b.maxIter, maxIter = _e === void 0 ? 300 : _e, _f = _b.tol, tol = _f === void 0 ? 0.0001 : _f, _g = _b.nInit, nInit = _g === void 0 ? 10 : _g, randomState = _b.randomState;
        var _this = _super.call(this) || this;
        /** Useful for pipelines and column transformers to have a default name for transforms */
        _this.name = 'KMeans';
        _this.tf = getBackend();
        _this.nClusters = nClusters;
        _this.init = init;
        _this.maxIter = maxIter;
        _this.tol = tol;
        _this.randomState = randomState;
        _this.nInit = nInit;
        _this.clusterCenters = _this.tf.tensor2d([[]]);
        return _this;
    }
    KMeans.prototype.initCentroids = function (X) {
        if (this.init === 'random') {
            var indices = sampleWithoutReplacement(X.shape[0], this.nClusters, this.randomState);
            this.clusterCenters = this.tf.gather(X, indices);
            return;
        }
        throw new Error("init ".concat(this.init, " is not currently implemented"));
    };
    KMeans.prototype.closestCentroid = function (X) {
        var _this = this;
        return this.tf.tidy(function () {
            var expandedX = _this.tf.expandDims(X, 1);
            var expandedClusters = _this.tf.expandDims(_this.clusterCenters, 0);
            return _this.tf
                .squaredDifference(expandedX, expandedClusters)
                .sum(2)
                .argMin(1);
        });
    };
    KMeans.prototype.updateCentroids = function (X, nearestIndices) {
        var _this = this;
        return this.tf.tidy(function () {
            var newCentroids = [];
            for (var i = 0; i < _this.nClusters; i++) {
                var mask = _this.tf.equal(nearestIndices, _this.tf.scalar(i).toInt());
                var currentCentroid = _this.tf.div(
                // set all masked instances to 0 by multiplying the mask tensor,
                // then sum across all instances
                _this.tf.sum(_this.tf.mul(_this.tf.expandDims(mask.toFloat(), 1), X), 0), 
                // divided by number of instances
                _this.tf.sum(mask.toFloat()));
                newCentroids.push(currentCentroid);
            }
            return _this.tf.stack(newCentroids);
        });
    };
    /**
     * Runs the KMeans algo over your input.
     * @param X The 2D Matrix that you wish to cluster
     */
    KMeans.prototype.fit = function (X) {
        var XTensor2D = convertToNumericTensor2D(X);
        this.initCentroids(XTensor2D);
        for (var i = 0; i < this.maxIter; i++) {
            var centroidPicks = this.closestCentroid(XTensor2D);
            this.clusterCenters = this.updateCentroids(XTensor2D, centroidPicks);
        }
        return this;
    };
    /**
     * Converts 2D input into a 1D Tensor which holds the KMeans cluster Class label
     * @param X The 2D Matrix that you wish to cluster
     */
    KMeans.prototype.predict = function (X) {
        var XTensor2D = convertToNumericTensor2D(X);
        return this.closestCentroid(XTensor2D);
    };
    KMeans.prototype.transform = function (X) {
        var _this = this;
        return this.tf.tidy(function () {
            var XTensor2D = convertToNumericTensor2D(X);
            var expandedX = _this.tf.expandDims(XTensor2D, 1);
            var expandedClusters = _this.tf.expandDims(_this.clusterCenters, 0);
            return _this.tf
                .squaredDifference(expandedX, expandedClusters)
                .sum(2)
                .sqrt();
        });
    };
    KMeans.prototype.fitPredict = function (X) {
        return this.fit(X).predict(X);
    };
    KMeans.prototype.fitTransform = function (X) {
        return this.fit(X).transform(X);
    };
    KMeans.prototype.score = function (X) {
        var _this = this;
        return this.tf.tidy(function () {
            var XTensor2D = convertToNumericTensor2D(X);
            var expandedX = _this.tf.expandDims(XTensor2D, 1);
            var expandedClusters = _this.tf.expandDims(_this.clusterCenters, 0);
            return _this.tf
                .squaredDifference(expandedX, expandedClusters)
                .sum(2)
                .min(1)
                .sqrt()
                .sum();
        });
    };
    return KMeans;
}(Serialize));
export { KMeans };
