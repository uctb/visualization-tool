/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { convertToNumericTensor2D, convertToTensor2D } from '../utils';
import { tensorMean } from '../math';
import { median } from 'mathjs';
import { modeFast } from 'simple-statistics';
import { TransformerMixin } from '../mixins';
import { getBackend } from '../tf-singleton';
/*
Next steps:
1. Make SimpleImputer work with strings
*/
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isEmpty(value) {
    return (value === undefined ||
        value === null ||
        (isNaN(value) && typeof value !== 'string'));
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function removeMissingValuesFromArray(arr) {
    var values = arr.filter(function (val) {
        return !isEmpty(val);
    });
    return values;
}
var SimpleImputer = /** @class */ (function (_super) {
    __extends(SimpleImputer, _super);
    function SimpleImputer(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.strategy, strategy = _c === void 0 ? 'mean' : _c, _d = _b.fillValue, fillValue = _d === void 0 ? undefined : _d, _e = _b.missingValues, missingValues = _e === void 0 ? NaN : _e;
        var _this = _super.call(this) || this;
        /** Useful for pipelines and column transformers to have a default name for transforms */
        _this.name = 'SimpleImputer';
        _this.tf = getBackend();
        _this.missingValues = missingValues;
        _this.strategy = strategy;
        _this.fillValue = fillValue;
        _this.statistics = _this.tf.tensor1d([]);
        return _this;
    }
    SimpleImputer.prototype.fit = function (X) {
        // Fill with value passed into fillValue argument
        if (this.strategy === 'constant') {
            return this;
        }
        if (this.strategy === 'mean') {
            var newTensor = convertToNumericTensor2D(X);
            var mean = tensorMean(newTensor, 0, true);
            this.statistics = mean;
            return this;
        }
        if (this.strategy === 'mostFrequent') {
            var newTensor = convertToNumericTensor2D(X);
            var mostFrequents = newTensor
                .transpose()
                .arraySync()
                .map(function (arr) {
                return modeFast(removeMissingValuesFromArray(arr));
            });
            this.statistics = this.tf.tensor1d(mostFrequents);
            return this;
        }
        if (this.strategy === 'median') {
            var newTensor = convertToNumericTensor2D(X);
            var medians = newTensor
                .transpose()
                .arraySync()
                .map(function (arr) {
                return median(removeMissingValuesFromArray(arr));
            });
            this.statistics = this.tf.tensor1d(medians);
            return this;
        }
        throw new Error("Strategy ".concat(this.strategy, " is unsupported. Supported strategies are 'mean', 'median', 'mostFrequent', and 'constant'"));
    };
    SimpleImputer.prototype.transform = function (X) {
        if (this.strategy === 'constant') {
            var newTensor_1 = convertToTensor2D(X);
            if (this.fillValue === undefined) {
                if (newTensor_1.dtype !== 'string') {
                    return this.tf.where(newTensor_1.isNaN(), 0, newTensor_1);
                }
                else {
                    return this.tf.where(newTensor_1.isNaN(), 'missing_value', newTensor_1);
                }
            }
            return this.tf.where(newTensor_1.isNaN(), this.fillValue, newTensor_1);
        }
        // Not strategy constant
        var newTensor = convertToNumericTensor2D(X);
        return this.tf.where(newTensor.isNaN(), this.statistics.reshape([1, -1]), newTensor);
    };
    return SimpleImputer;
}(TransformerMixin));
export { SimpleImputer };
