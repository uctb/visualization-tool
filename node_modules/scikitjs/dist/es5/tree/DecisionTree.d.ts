import { ImpurityMeasure } from './Criterion';
import { Splitter } from './Splitter';
import { int } from '../randUtils';
import { Scikit1D, Scikit2D } from '../types';
import { LabelEncoder } from '../preprocessing/LabelEncoder';
import { Serialize } from '../simpleSerializer';
interface NodeRecord {
    start: int;
    end: int;
    nSamples: int;
    depth: int;
    parentId: int;
    isLeft: boolean;
    impurity: number;
}
interface Node {
    parentId: int;
    leftChildId: int;
    rightChildId: int;
    isLeft: boolean;
    isLeaf: boolean;
    impurity: number;
    splitFeature: int;
    threshold: number;
    nSamples: int;
    value: int[];
}
export declare class DecisionTree {
    nodes: Node[];
    isBuilt: boolean;
    name: string;
    getLeafNodes(X: number[][]): int[];
    populateChildIds(): void;
    predictProba(samples: number[][]): number[][];
    predictClassification(samples: number[][]): int[];
    predictRegression(samples: number[][]): int[];
}
interface DecisionTreeBaseParams {
    criterion?: 'gini' | 'entropy' | 'squared_error';
    maxDepth?: int;
    minSamplesSplit?: number;
    minSamplesLeaf?: number;
    maxFeatures?: number | 'auto' | 'sqrt' | 'log2';
    minImpurityDecrease?: number;
}
export declare class DecisionTreeBase extends Serialize {
    splitter: Splitter;
    stack: NodeRecord[];
    minSamplesLeaf: int;
    maxDepth: int;
    minSamplesSplit: int;
    minImpurityDecrease: number;
    tree: DecisionTree;
    criterion: ImpurityMeasure;
    maxFeatures?: number | 'log2' | 'sqrt' | 'auto';
    maxFeaturesNumb: int;
    X: number[][];
    y: number[];
    labelEncoder?: LabelEncoder;
    name: string;
    constructor({ criterion, maxDepth, minSamplesSplit, minSamplesLeaf, maxFeatures, minImpurityDecrease }?: DecisionTreeBaseParams);
    calcMaxFeatures(nFeatures: int, maxFeatures?: number | 'auto' | 'sqrt' | 'log2'): number;
    fit(X: number[][], y: int[], samplesSubset?: number[]): void;
}
export interface DecisionTreeClassifierParams {
    /** The function to measure the quality of the split. Default is **gini**. */
    criterion?: 'gini' | 'entropy';
    /** The maximum depth of the tree. Default is **undefined**. */
    maxDepth?: int;
    /** The minimum number of samples that you'd need before you can split on that node. Default is **2**. */
    minSamplesSplit?: number;
    /** The minimum number of samples that every leaf must contain. Default is **1**. */
    minSamplesLeaf?: number;
    /** The number of features that you would consider. Default is **undefined**. */
    maxFeatures?: number | 'auto' | 'sqrt' | 'log2';
    /** The amount of impurity that would need to exist before you could split. */
    minImpurityDecrease?: number;
}
/**
 * Build a Decision Tree for Classification problems.
 *
 * @example
 * ```js
 * import { DecisionTreeClassifier } from 'scikitjs'
 *
 * const X = [
     [0.1, 0.9],
     [0.3, 0.7],
     [0.9, 0.1],
     [0.8, 0.2],
     [0.81, 0.19]
   ]
   const y = [0, 0, 1, 1, 1]

   const clf = new DecisionTreeClassifier({ criterion: 'gini', maxDepth: 4 })
   await clf.fit(X, y)

   clf.predict([
     [0.1, 0.9],
     [0.01, 0.99]
   ]) // [0, 1]
 * ```
 *
 */
export declare class DecisionTreeClassifier extends DecisionTreeBase {
    labelEncoder: LabelEncoder;
    name: string;
    constructor({ criterion, maxDepth, minSamplesSplit, minSamplesLeaf, maxFeatures, minImpurityDecrease }?: DecisionTreeClassifierParams);
    fit(X: Scikit2D, y: Scikit1D): DecisionTreeClassifier;
    getNLeaves(): number;
    predict(X: Scikit2D): any[];
    predictProba(X: number[][]): number[][];
    score(X: number[][], y: number[]): number;
}
/**
 * Build a Decision Tree for Regression problems.
 * @example
 * ```js
 * import { DecisionTreeRegressor } from 'scikitjs'
 *
 * let X = [
 *  [1, 2],
 *  [1, 4],
 *  [2, 6],
 *  [3, 5],
 *  [10, 20]
 * ]
 * let y = [3, 5, 8, 8, 30]
 * const dt = new DecisionTreeRegressor({fitIntercept: false})
  await dt.fit(X, y)
 * ```
 */
export interface DecisionTreeRegressorParams {
    /** The function to measure the quality of the split. Default is **squared_error**. */
    criterion?: 'squared_error';
    /** The maximum depth of the tree. Default is **undefined**. */
    maxDepth?: int;
    /** The minimum number of samples that you'd need before you can split on that node. Default is **2**. */
    minSamplesSplit?: number;
    /** The minimum number of samples that every leaf must contain. Default is **1**. */
    minSamplesLeaf?: number;
    /** The number of features that you would consider. Default is **undefined**. */
    maxFeatures?: number | 'auto' | 'sqrt' | 'log2';
    /** The amount of impurity that would need to exist before you could split. */
    minImpurityDecrease?: number;
}
export declare class DecisionTreeRegressor extends DecisionTreeBase {
    name: string;
    constructor({ criterion, maxDepth, minSamplesSplit, minSamplesLeaf, maxFeatures, minImpurityDecrease }?: DecisionTreeRegressorParams);
    fit(X: Scikit2D, y: Scikit1D): DecisionTreeRegressor;
    getNLeaves(): number;
    predict(X: number[][]): number[];
    score(X: number[][], y: number[]): number;
}
export {};
