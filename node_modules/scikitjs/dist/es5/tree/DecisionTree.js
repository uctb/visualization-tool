var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Splitter } from './Splitter';
import { r2Score, accuracyScore } from '../metrics/metrics';
import { makeDefaultSplit } from './Splitter';
import { assert, isScikit1D, isScikit2D } from '../typesUtils';
import { validateX, validateY } from './utils';
import { convertScikit2DToArray, convertScikit1DToArray } from '../utils';
import { LabelEncoder } from '../preprocessing/LabelEncoder';
import { Serialize } from '../simpleSerializer';
function argMax(array) {
    return array.map(function (x, i) { return [x, i]; }).reduce(function (r, a) { return (a[0] > r[0] ? a : r); })[1];
}
var DecisionTree = /** @class */ (function () {
    function DecisionTree() {
        this.nodes = [];
        this.isBuilt = false;
        this.name = 'DecisionTree';
    }
    DecisionTree.prototype.getLeafNodes = function (X) {
        var leafNodeIds = [];
        for (var i = 0; i < X.length; i++) {
            var nodeId = 0;
            while (!this.nodes[nodeId].isLeaf) {
                if (X[i][this.nodes[nodeId].splitFeature] <= this.nodes[nodeId].threshold) {
                    nodeId = this.nodes[nodeId].leftChildId;
                }
                else {
                    nodeId = this.nodes[nodeId].rightChildId;
                }
            }
            leafNodeIds.push(nodeId);
        }
        return leafNodeIds;
    };
    DecisionTree.prototype.populateChildIds = function () {
        for (var i = 1; i < this.nodes.length; i++) {
            if (this.nodes[i].isLeft) {
                this.nodes[this.nodes[i].parentId].leftChildId = i;
            }
            else {
                this.nodes[this.nodes[i].parentId].rightChildId = i;
            }
        }
    };
    DecisionTree.prototype.predictProba = function (samples) {
        if (!this.isBuilt) {
            throw new Error('Decision tree must be built with BuildTree method before predictions can be made.');
        }
        var leafNodeIds = this.getLeafNodes(samples);
        var classProbabilities = [];
        for (var i = 0; i < leafNodeIds.length; i++) {
            var currentClassProbabilities = [];
            var curNodeId = leafNodeIds[i];
            for (var nClass = 0; nClass < this.nodes[0].value.length; nClass++) {
                currentClassProbabilities.push(this.nodes[curNodeId].value[nClass] / this.nodes[curNodeId].nSamples);
            }
            classProbabilities.push(currentClassProbabilities);
        }
        return classProbabilities;
    };
    DecisionTree.prototype.predictClassification = function (samples) {
        if (!this.isBuilt) {
            throw new Error('Decision tree must be built with BuildTree method before predictions can be made.');
        }
        var leafNodeIds = this.getLeafNodes(samples);
        var classPredictions = [];
        for (var nSample = 0; nSample < leafNodeIds.length; nSample++) {
            var curNodeId = leafNodeIds[nSample];
            classPredictions.push(argMax(this.nodes[curNodeId].value));
        }
        return classPredictions;
    };
    DecisionTree.prototype.predictRegression = function (samples) {
        if (!this.isBuilt) {
            throw new Error('Decision tree must be built with BuildTree method before predictions can be made.');
        }
        var leafNodeIds = this.getLeafNodes(samples);
        var classPredictions = [];
        for (var nSample = 0; nSample < leafNodeIds.length; nSample++) {
            var curNodeId = leafNodeIds[nSample];
            classPredictions.push(this.nodes[curNodeId].value[0]);
        }
        return classPredictions;
    };
    return DecisionTree;
}());
export { DecisionTree };
var DecisionTreeBase = /** @class */ (function (_super) {
    __extends(DecisionTreeBase, _super);
    function DecisionTreeBase(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.criterion, criterion = _c === void 0 ? 'gini' : _c, _d = _b.maxDepth, maxDepth = _d === void 0 ? Number.POSITIVE_INFINITY : _d, _e = _b.minSamplesSplit, minSamplesSplit = _e === void 0 ? 2 : _e, _f = _b.minSamplesLeaf, minSamplesLeaf = _f === void 0 ? 1 : _f, _g = _b.maxFeatures, maxFeatures = _g === void 0 ? undefined : _g, _h = _b.minImpurityDecrease, minImpurityDecrease = _h === void 0 ? 0.0 : _h;
        var _this = _super.call(this) || this;
        _this.stack = [];
        _this.X = [];
        _this.y = [];
        _this.criterion = criterion;
        _this.maxDepth =
            maxDepth === undefined ? Number.POSITIVE_INFINITY : Number(maxDepth);
        _this.minSamplesSplit = minSamplesSplit;
        _this.minSamplesLeaf = minSamplesLeaf;
        _this.maxFeatures = maxFeatures;
        _this.minImpurityDecrease = minImpurityDecrease;
        _this.maxFeaturesNumb = 0;
        _this.tree = new DecisionTree();
        _this.name = 'DecisionTreeBase';
        return _this;
    }
    DecisionTreeBase.prototype.calcMaxFeatures = function (nFeatures, maxFeatures) {
        if (maxFeatures === 'log2') {
            return Math.floor(Math.log2(nFeatures));
        }
        if (maxFeatures === 'sqrt') {
            return Math.floor(Math.sqrt(nFeatures));
        }
        if (maxFeatures === 'auto') {
            return Math.floor(Math.sqrt(nFeatures));
        }
        if (typeof maxFeatures === 'number') {
            assert(maxFeatures >= 1, 'maxFeatures must be greater than 1');
            return Math.min(Math.floor(maxFeatures), nFeatures);
        }
        return nFeatures;
    };
    DecisionTreeBase.prototype.fit = function (X, y, samplesSubset) {
        this.X = X;
        this.y = y;
        var newSamplesSubset = samplesSubset || [];
        // CheckNegativeLabels(yptr);
        this.maxFeaturesNumb = this.calcMaxFeatures(X[0].length, this.maxFeatures);
        this.splitter = new Splitter({
            X: X,
            y: y,
            minSamplesLeaf: this.minSamplesLeaf,
            impurityMeasure: this.criterion,
            maxFeatures: this.maxFeaturesNumb,
            samplesSubset: newSamplesSubset
        });
        // put root node on stack
        var rootNode = {
            start: 0,
            end: this.splitter.sampleMap.length,
            depth: 0,
            impurity: 0,
            nSamples: this.splitter.sampleMap.length,
            parentId: -1,
            isLeft: false
        };
        this.stack.push(rootNode);
        var isRootNode = true;
        while (this.stack.length !== 0) {
            // take next node from stack
            var currentRecord = this.stack.pop();
            this.splitter.resetSampleRange(currentRecord.start, currentRecord.end);
            var currentSplit = makeDefaultSplit();
            var isLeaf = !(currentRecord.depth < this.maxDepth) ||
                currentRecord.nSamples < this.minSamplesSplit ||
                currentRecord.nSamples < 2 * this.minSamplesLeaf;
            // evaluate abort criterion
            if (isRootNode) {
                currentRecord.impurity = this.splitter.criterion.nodeImpurity();
                isRootNode = false;
            }
            // or currentRecord.impurity <= 0.0;
            // split unless isLeaf
            if (!isLeaf) {
                currentSplit = this.splitter.splitNode();
                isLeaf =
                    isLeaf ||
                        !currentSplit.foundSplit ||
                        currentRecord.impurity <= this.minImpurityDecrease;
            }
            var currentNode = {
                parentId: currentRecord.parentId,
                impurity: currentRecord.impurity,
                isLeaf: isLeaf,
                isLeft: currentRecord.isLeft,
                nSamples: currentRecord.nSamples,
                splitFeature: currentSplit.feature,
                threshold: currentSplit.threshold,
                value: this.splitter.criterion.nodeValue().slice(),
                leftChildId: -1,
                rightChildId: -1
            };
            this.tree.nodes.push(currentNode);
            var nodeId = this.tree.nodes.length - 1;
            if (!isLeaf) {
                var rightRecord = {
                    start: currentSplit.pos,
                    end: currentRecord.end,
                    nSamples: currentRecord.end - currentSplit.pos,
                    depth: currentRecord.depth + 1,
                    parentId: nodeId,
                    isLeft: false,
                    impurity: currentSplit.impurityRight
                };
                this.stack.push(rightRecord);
                var leftRecord = {
                    start: currentRecord.start,
                    end: currentSplit.pos,
                    nSamples: currentSplit.pos - currentRecord.start,
                    depth: currentRecord.depth + 1,
                    parentId: nodeId,
                    isLeft: true,
                    impurity: currentSplit.impurityLeft
                };
                this.stack.push(leftRecord);
            }
        }
        this.tree.populateChildIds();
        this.tree.isBuilt = true;
    };
    return DecisionTreeBase;
}(Serialize));
export { DecisionTreeBase };
/**
 * Build a Decision Tree for Classification problems.
 *
 * @example
 * ```js
 * import { DecisionTreeClassifier } from 'scikitjs'
 *
 * const X = [
     [0.1, 0.9],
     [0.3, 0.7],
     [0.9, 0.1],
     [0.8, 0.2],
     [0.81, 0.19]
   ]
   const y = [0, 0, 1, 1, 1]

   const clf = new DecisionTreeClassifier({ criterion: 'gini', maxDepth: 4 })
   await clf.fit(X, y)

   clf.predict([
     [0.1, 0.9],
     [0.01, 0.99]
   ]) // [0, 1]
 * ```
 *
 */
var DecisionTreeClassifier = /** @class */ (function (_super) {
    __extends(DecisionTreeClassifier, _super);
    function DecisionTreeClassifier(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.criterion, criterion = _c === void 0 ? 'gini' : _c, _d = _b.maxDepth, maxDepth = _d === void 0 ? undefined : _d, _e = _b.minSamplesSplit, minSamplesSplit = _e === void 0 ? 2 : _e, _f = _b.minSamplesLeaf, minSamplesLeaf = _f === void 0 ? 1 : _f, _g = _b.maxFeatures, maxFeatures = _g === void 0 ? undefined : _g, _h = _b.minImpurityDecrease, minImpurityDecrease = _h === void 0 ? 0.0 : _h;
        var _this = this;
        assert(['gini', 'entropy'].includes(criterion), 'For classification must pass either the "gini" or "entropy" criterion');
        _this = _super.call(this, {
            criterion: criterion,
            maxDepth: maxDepth,
            minSamplesSplit: minSamplesSplit,
            minSamplesLeaf: minSamplesLeaf,
            maxFeatures: maxFeatures,
            minImpurityDecrease: minImpurityDecrease
        }) || this;
        _this.labelEncoder = new LabelEncoder();
        _this.name = 'DecisionTreeClassifier';
        return _this;
    }
    DecisionTreeClassifier.prototype.fit = function (X, y) {
        assert(isScikit1D(y), 'y value is not a 1D container');
        assert(isScikit2D(X), 'X value is not a 2D container');
        var XArray = convertScikit2DToArray(X);
        var yArray = convertScikit1DToArray(y);
        assert(XArray.length === yArray.length, 'X and y must be the same size');
        validateX(XArray); // checks to make sure there are no NaN's etc
        validateY(yArray); // checks to make sure there are no NaN's etc
        var yArrayFixed = this.labelEncoder.fitTransform(yArray);
        _super.prototype.fit.call(this, XArray, convertScikit1DToArray(yArrayFixed));
        return this;
    };
    DecisionTreeClassifier.prototype.getNLeaves = function () {
        return this.tree.nodes.filter(function (el) { return el.isLeaf; }).length;
    };
    DecisionTreeClassifier.prototype.predict = function (X) {
        assert(isScikit2D(X), 'X value is not a 2D container');
        var XArray = convertScikit2DToArray(X);
        validateX(XArray);
        var yValues = this.tree.predictClassification(XArray);
        return this.labelEncoder.inverseTransform(yValues);
    };
    DecisionTreeClassifier.prototype.predictProba = function (X) {
        return this.tree.predictProba(X);
    };
    DecisionTreeClassifier.prototype.score = function (X, y) {
        var yPred = this.predict(X);
        return accuracyScore(y, yPred);
    };
    return DecisionTreeClassifier;
}(DecisionTreeBase));
export { DecisionTreeClassifier };
var DecisionTreeRegressor = /** @class */ (function (_super) {
    __extends(DecisionTreeRegressor, _super);
    function DecisionTreeRegressor(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.criterion, criterion = _c === void 0 ? 'squared_error' : _c, _d = _b.maxDepth, maxDepth = _d === void 0 ? undefined : _d, _e = _b.minSamplesSplit, minSamplesSplit = _e === void 0 ? 2 : _e, _f = _b.minSamplesLeaf, minSamplesLeaf = _f === void 0 ? 1 : _f, _g = _b.maxFeatures, maxFeatures = _g === void 0 ? undefined : _g, _h = _b.minImpurityDecrease, minImpurityDecrease = _h === void 0 ? 0.0 : _h;
        var _this = this;
        assert(['squared_error'].includes(criterion), 'Must pass the regression criterion of "squared_error"');
        _this = _super.call(this, {
            criterion: criterion,
            maxDepth: maxDepth,
            minSamplesSplit: minSamplesSplit,
            minSamplesLeaf: minSamplesLeaf,
            maxFeatures: maxFeatures,
            minImpurityDecrease: minImpurityDecrease
        }) || this;
        _this.name = 'DecisionTreeRegressor';
        return _this;
    }
    DecisionTreeRegressor.prototype.fit = function (X, y) {
        assert(isScikit1D(y), 'y value is not a 1D container');
        assert(isScikit2D(X), 'X value is not a 2D container');
        var XArray = convertScikit2DToArray(X);
        var yArray = convertScikit1DToArray(y);
        assert(XArray.length === yArray.length, 'X and y must be the same size');
        validateX(XArray);
        // TODO yValidation for regression (check that there are no NaN's etc)
        _super.prototype.fit.call(this, XArray, yArray);
        return this;
    };
    DecisionTreeRegressor.prototype.getNLeaves = function () {
        return this.tree.nodes.filter(function (el) { return el.isLeaf; }).length;
    };
    DecisionTreeRegressor.prototype.predict = function (X) {
        return this.tree.predictRegression(X);
    };
    DecisionTreeRegressor.prototype.score = function (X, y) {
        var yPred = this.predict(X);
        return r2Score(y, yPred);
    };
    return DecisionTreeRegressor;
}(DecisionTreeBase));
export { DecisionTreeRegressor };
