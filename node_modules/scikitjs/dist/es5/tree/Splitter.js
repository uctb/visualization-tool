var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { ClassificationCriterion, RegressionCriterion } from './Criterion';
import shuffle from 'lodash/shuffle';
import { Serialize } from '../simpleSerializer';
export function makeDefaultSplit() {
    return {
        feature: 0,
        threshold: 0,
        pos: -1,
        impurityLeft: Number.POSITIVE_INFINITY,
        impurityRight: Number.POSITIVE_INFINITY,
        foundSplit: false
    };
}
var Splitter = /** @class */ (function (_super) {
    __extends(Splitter, _super);
    function Splitter(_a) {
        var X = _a.X, y = _a.y, minSamplesLeaf = _a.minSamplesLeaf, impurityMeasure = _a.impurityMeasure, maxFeatures = _a.maxFeatures, _b = _a.samplesSubset, samplesSubset = _b === void 0 ? [] : _b;
        var _this = _super.call(this) || this;
        _this.name = 'Splitter';
        _this.X = X;
        _this.y = y;
        _this.nFeatures = X[0].length;
        _this.minSamplesLeaf = minSamplesLeaf;
        _this.maxFeatures = Math.min(maxFeatures, _this.nFeatures);
        _this.shuffleFeatures = maxFeatures < _this.nFeatures;
        _this.sampleMap = new Int32Array(X.length);
        _this.start = 0;
        _this.end = 0;
        _this.kMinSplitDiff = 1e-8;
        if (samplesSubset.length === 0) {
            _this.nSamplesTotal = X.length;
            for (var i = 0; i < _this.nSamplesTotal; i++) {
                _this.sampleMap[i] = i;
            }
        }
        else {
            _this.nSamplesTotal = samplesSubset.length;
            for (var i = 0; i < _this.nSamplesTotal; i++) {
                _this.sampleMap[i] = samplesSubset[i];
            }
        }
        if (impurityMeasure === 'squared_error') {
            _this.criterion = new RegressionCriterion({ impurityMeasure: impurityMeasure, y: y });
        }
        else {
            _this.criterion = new ClassificationCriterion({ impurityMeasure: impurityMeasure, y: y });
        }
        _this.featureOrder = [];
        for (var i = 0; i < _this.nFeatures; i++) {
            _this.featureOrder.push(i);
        }
        _this.resetSampleRange(0, _this.nSamplesTotal);
        return _this;
    }
    Splitter.prototype.resetSampleRange = function (start, end) {
        this.start = start;
        this.end = end;
        this.criterion.init(start, end, this.sampleMap);
    };
    Splitter.prototype.splitNode = function () {
        var _this = this;
        var currentSplit = makeDefaultSplit();
        var bestSplit = makeDefaultSplit();
        var currentImpurityImprovement = Number.NEGATIVE_INFINITY;
        var bestImpurityImprovement = Number.NEGATIVE_INFINITY;
        var currentFeatureNum = 0;
        var currentFeature = 0;
        currentSplit.foundSplit = false;
        if (this.shuffleFeatures) {
            this.featureOrder = shuffle(this.featureOrder);
        }
        while (currentFeatureNum < this.maxFeatures) {
            currentFeature = this.featureOrder[currentFeatureNum];
            var currentFeatureValues = new Float32Array(this.end - this.start);
            for (var i = this.start; i < this.end; i++) {
                var row = this.X[this.sampleMap[i]];
                var val = row[currentFeature];
                currentFeatureValues[i - this.start] = val;
            }
            currentFeatureValues.sort();
            this.criterion.reset();
            this.sampleMap
                .subarray(this.start, this.end)
                .sort(function (a, b) { return _this.X[a][currentFeature] - _this.X[b][currentFeature]; });
            // If this feature value is constant, then skip it.
            if (currentFeatureValues[0] ===
                currentFeatureValues[currentFeatureValues.length - 1]) {
                currentFeatureNum += 1;
                continue;
            }
            var pos = this.start + 1;
            // Loop over all split points
            while (pos < this.end) {
                // Skip split points where the features are equal because
                // you can't "slice" there
                while (pos < this.end &&
                    currentFeatureValues[pos - this.start] <=
                        currentFeatureValues[pos - this.start - 1] + this.kMinSplitDiff) {
                    pos++;
                }
                if (pos === this.end) {
                    pos++;
                    continue;
                }
                // Check if split would lead to less than minSamplesLeaf samples
                if (!(pos - this.start < this.minSamplesLeaf ||
                    this.end - pos < this.minSamplesLeaf)) {
                    currentSplit.pos = pos;
                    this.criterion.update(currentSplit.pos, this.sampleMap);
                    currentImpurityImprovement = this.criterion.impurityImprovement();
                    if (currentImpurityImprovement > bestImpurityImprovement) {
                        bestImpurityImprovement = currentImpurityImprovement;
                        currentSplit.foundSplit = true;
                        currentSplit.feature = currentFeature;
                        currentSplit.threshold =
                            (currentFeatureValues[pos - this.start - 1] +
                                currentFeatureValues[pos - this.start]) /
                                2.0;
                        bestSplit = Object.assign({}, currentSplit);
                    }
                }
                // increment the position
                pos += 1;
            }
            // increment the feature that we are looking at
            currentFeatureNum += 1;
        }
        if (currentSplit.foundSplit) {
            if (bestSplit.pos < this.end) {
                if (currentFeature !== bestSplit.feature) {
                    var leftPos = this.start;
                    var rightPos = this.end;
                    var tmp = 0;
                    while (leftPos < rightPos) {
                        if (this.X[this.sampleMap[leftPos]][bestSplit.feature] <=
                            bestSplit.threshold) {
                            leftPos += 1;
                        }
                        else {
                            rightPos -= 1;
                            tmp = this.sampleMap[leftPos];
                            this.sampleMap[leftPos] = this.sampleMap[rightPos];
                            this.sampleMap[rightPos] = tmp;
                        }
                    }
                }
            }
            this.criterion.reset();
            this.criterion.update(bestSplit.pos, this.sampleMap);
            var _a = this.criterion.childrenImpurities(), impurityLeft = _a.impurityLeft, impurityRight = _a.impurityRight;
            bestSplit.impurityLeft = impurityLeft;
            bestSplit.impurityRight = impurityRight;
            return bestSplit;
        }
        else {
            // passing back split.foundSplit = false
            return currentSplit;
        }
    };
    return Splitter;
}(Serialize));
export { Splitter };
