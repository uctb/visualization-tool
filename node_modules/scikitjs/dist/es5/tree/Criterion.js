var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Serialize } from '../simpleSerializer';
export function giniCoefficient(labelFreqs, nSamples) {
    var freqSquares = 0;
    for (var i = 0; i < labelFreqs.length; i++) {
        freqSquares += labelFreqs[i] * labelFreqs[i];
    }
    return 1 - freqSquares / (nSamples * nSamples);
}
export function entropy(labelFreqs, nSamples) {
    var totalEntropy = 0;
    for (var i = 0; i < labelFreqs.length; i++) {
        var labelFrequency = labelFreqs[i];
        if (labelFrequency > 0) {
            labelFrequency /= nSamples;
            totalEntropy -= labelFrequency * Math.log2(labelFrequency);
        }
    }
    return totalEntropy;
}
export function mse(ySquaredSum, ySum, nSamples) {
    var yBar = ySum / nSamples;
    var val = ySquaredSum / nSamples - yBar * yBar;
    return val;
}
function arrayMax(labels) {
    var max = Number.NEGATIVE_INFINITY;
    for (var i = 0; i < labels.length; i++) {
        if (labels[i] > max) {
            max = labels[i];
        }
    }
    return max;
}
var ClassificationCriterion = /** @class */ (function (_super) {
    __extends(ClassificationCriterion, _super);
    function ClassificationCriterion(_a) {
        var impurityMeasure = _a.impurityMeasure, y = _a.y;
        var _this = _super.call(this) || this;
        // impurityFunc: (labelFreqs: int[], nSamples: int) => number
        _this.start = 0;
        _this.end = 0;
        _this.pos = 0;
        _this.labelFreqsTotal = [];
        _this.labelFreqsLeft = [];
        _this.labelFreqsRight = [];
        _this.nSamples = 0;
        _this.nSamplesLeft = 0;
        _this.nSamplesRight = 0;
        _this.name = 'ClassificationCriterion';
        _this.impurityMeasure = impurityMeasure;
        // This assumes that the labels are 0,1,2,...,(n-1)
        _this.nLabels = arrayMax(y) + 1;
        _this.y = y;
        _this.labelFreqsTotal = new Array(_this.nLabels).fill(0);
        _this.labelFreqsLeft = new Array(_this.nLabels).fill(0);
        _this.labelFreqsRight = new Array(_this.nLabels).fill(0);
        return _this;
    }
    ClassificationCriterion.prototype.init = function (start, end, sampleMap) {
        this.start = start;
        this.end = end;
        this.nSamples = end - start;
        this.labelFreqsTotal = this.labelFreqsTotal.fill(0);
        this.labelFreqsLeft = this.labelFreqsLeft.fill(0);
        this.labelFreqsRight = this.labelFreqsRight.fill(0);
        for (var i = start; i < end; i++) {
            var sampleNumber = sampleMap[i];
            this.labelFreqsTotal[this.y[sampleNumber]] += 1;
        }
    };
    ClassificationCriterion.prototype.reset = function () {
        this.pos = this.start;
        this.labelFreqsLeft = this.labelFreqsLeft.fill(0);
        this.labelFreqsRight = this.labelFreqsRight.fill(0);
    };
    ClassificationCriterion.prototype.update = function (newPos, sampleMap) {
        for (var i = this.pos; i < newPos; i++) {
            // This assumes that the labels take values 0,..., nLabels - 1
            var sampleNumber = sampleMap[i];
            this.labelFreqsLeft[this.y[sampleNumber]] += 1;
        }
        // calculate labelFreqsRight
        for (var i = 0; i < this.labelFreqsTotal.length; i++) {
            this.labelFreqsRight[i] =
                this.labelFreqsTotal[i] - this.labelFreqsLeft[i];
        }
        this.pos = newPos;
        this.nSamplesLeft = this.pos - this.start;
        this.nSamplesRight = this.end - this.pos;
    };
    ClassificationCriterion.prototype.childrenImpurities = function () {
        var impurityFunc = this.impurityMeasure === 'gini' ? giniCoefficient : entropy;
        return {
            impurityLeft: impurityFunc(this.labelFreqsLeft, this.nSamplesLeft),
            impurityRight: impurityFunc(this.labelFreqsRight, this.nSamplesRight)
        };
    };
    ClassificationCriterion.prototype.impurityImprovement = function () {
        var _a = this.childrenImpurities(), impurityLeft = _a.impurityLeft, impurityRight = _a.impurityRight;
        return (-this.nSamplesLeft * impurityLeft - this.nSamplesRight * impurityRight);
    };
    ClassificationCriterion.prototype.nodeImpurity = function () {
        var impurityFunc = this.impurityMeasure === 'gini' ? giniCoefficient : entropy;
        return impurityFunc(this.labelFreqsTotal, this.nSamples);
    };
    ClassificationCriterion.prototype.nodeValue = function () {
        return this.labelFreqsTotal;
    };
    ClassificationCriterion.fromJson = function (model) {
        var jsonClass = JSON.parse(model);
        var newModel = new ClassificationCriterion({
            impurityMeasure: jsonClass.impurityMeasure,
            y: jsonClass.y
        });
        return Object.assign(newModel, jsonClass);
    };
    return ClassificationCriterion;
}(Serialize));
export { ClassificationCriterion };
var RegressionCriterion = /** @class */ (function (_super) {
    __extends(RegressionCriterion, _super);
    function RegressionCriterion(_a) {
        var impurityMeasure = _a.impurityMeasure, y = _a.y;
        var _this = _super.call(this) || this;
        // impurityFunc: (ySquaredSum: number, ySum: number, nSamples: int) => number
        _this.start = 0;
        _this.end = 0;
        _this.pos = 0;
        _this.squaredSum = 0;
        _this.squaredSumLeft = 0;
        _this.squaredSumRight = 0;
        _this.sumTotal = 0;
        _this.sumTotalLeft = 0;
        _this.sumTotalRight = 0;
        _this.nSamples = 0;
        _this.nSamplesLeft = 0;
        _this.nSamplesRight = 0;
        _this.name = 'RegressionCriterion';
        // We don't assert in the constructor, we assert in fit in accordance with the sklearn docs
        // Support MAE one day
        _this.impurityMeasure = impurityMeasure;
        // We don't set the impurityFunc here because we need it to be serializable as an object
        // this.impurityFunc = mse
        _this.y = y;
        return _this;
    }
    RegressionCriterion.prototype.init = function (start, end, sampleMap) {
        this.sumTotal = 0;
        this.squaredSum = 0;
        this.start = start;
        this.end = end;
        this.nSamples = end - start;
        for (var i = start; i < end; i++) {
            var sampleNumber = sampleMap[i];
            var yValue = this.y[sampleNumber];
            this.sumTotal += yValue;
            this.squaredSum += yValue * yValue;
        }
    };
    RegressionCriterion.prototype.reset = function () {
        this.pos = this.start;
        this.squaredSumLeft = 0;
        this.sumTotalLeft = 0;
        this.squaredSumRight = 0;
        this.sumTotalRight = 0;
    };
    RegressionCriterion.prototype.update = function (newPos, sampleMap) {
        for (var i = this.pos; i < newPos; i++) {
            // This assumes that the labels take values 0,..., nLabels - 1
            var sampleNumber = sampleMap[i];
            var yValue = this.y[sampleNumber];
            this.sumTotalLeft += yValue;
            this.squaredSumLeft += yValue * yValue;
        }
        // calculate labelFreqsRight
        this.sumTotalRight = this.sumTotal - this.sumTotalLeft;
        this.squaredSumRight = this.squaredSum - this.squaredSumLeft;
        this.pos = newPos;
        this.nSamplesLeft = this.pos - this.start;
        this.nSamplesRight = this.end - this.pos;
    };
    RegressionCriterion.prototype.childrenImpurities = function () {
        // once we get another impurity function we can do a ternary here
        var impurityFunc = mse;
        return {
            impurityLeft: impurityFunc(this.squaredSumLeft, this.sumTotalLeft, this.nSamplesLeft),
            impurityRight: impurityFunc(this.squaredSumRight, this.sumTotalRight, this.nSamplesRight)
        };
    };
    RegressionCriterion.prototype.impurityImprovement = function () {
        var _a = this.childrenImpurities(), impurityLeft = _a.impurityLeft, impurityRight = _a.impurityRight;
        return (-this.nSamplesLeft * impurityLeft - this.nSamplesRight * impurityRight);
    };
    RegressionCriterion.prototype.nodeImpurity = function () {
        // once we get another impurity function we can do a ternary here
        var impurityFunc = mse;
        return impurityFunc(this.squaredSum, this.sumTotal, this.nSamples);
    };
    RegressionCriterion.prototype.nodeValue = function () {
        return [this.sumTotal / this.nSamples];
    };
    RegressionCriterion.fromJson = function (model) {
        var jsonClass = JSON.parse(model);
        var newModel = new RegressionCriterion({
            impurityMeasure: jsonClass.impurityMeasure,
            y: jsonClass.y
        });
        return Object.assign(newModel, jsonClass);
    };
    return RegressionCriterion;
}(Serialize));
export { RegressionCriterion };
