/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { isSeriesInterface, isTensor } from '../typesUtils';
import { getBackend } from '../tf-singleton';
import { Serialize } from '../simpleSerializer';
/*
Next steps:
1. Pass the next 5 tests
*/
/**
 * Encode target labels with value between 0 and n_classes-1.
 * @example
 * ```js
 *  import { LabelEncoder } from 'scikitjs'
 *
 *  const sf = [1, 2, 2, 'boy', 'git', 'git']
    const scaler = new LabelEncoder()
    scaler.fit(sf)
    console.log(scaler.classes) // [1, 2, "boy", "git"]
    scaler.transform([2, 2, "boy"]) // [1, 1, 2]
 * ```
 */
var LabelEncoder = /** @class */ (function (_super) {
    __extends(LabelEncoder, _super);
    function LabelEncoder() {
        var _this = _super.call(this) || this;
        /** Useful for pipelines and column transformers to have a default name for transforms */
        _this.name = 'LabelEncoder';
        _this.tf = getBackend();
        _this.classes = [];
        return _this;
    }
    LabelEncoder.prototype.convertTo1DArray = function (X) {
        if (isSeriesInterface(X)) {
            return X.values;
        }
        if (isTensor(X)) {
            return X.arraySync();
        }
        return X;
    };
    LabelEncoder.prototype.classesToMapping = function (classes) {
        var labels = new Map();
        classes.forEach(function (value, index) {
            labels.set(value, index);
        });
        return labels;
    };
    /**
     * Maps values to unique integer labels between 0 and n_classes-1.
     * @example
     * ```js
     * const encoder = new LabelEncoder()
     * encoder.fit(["a", "b", "c", "d"])
     * ```
     */
    LabelEncoder.prototype.fit = function (X) {
        var arr = this.convertTo1DArray(X);
        var dataSet = Array.from(new Set(arr));
        this.classes = dataSet;
        return this;
    };
    /**
     * Encode labels with value between 0 and n_classes-1.
     * @example
     * ```js
     * const encoder = new LabelEncoder()
     * encoder.fit(["a", "b", "c", "d"])
     * console.log(encoder.transform(["a", "b", "c", "d"]))
     * // [0, 1, 2, 3]
     * ```
     */
    LabelEncoder.prototype.transform = function (X) {
        var arr = this.convertTo1DArray(X);
        var labels = this.classesToMapping(this.classes);
        var encodedData = arr.map(function (value) {
            var val = labels.get(value);
            return val === undefined ? -1 : val;
        });
        return this.tf.tensor1d(encodedData);
    };
    LabelEncoder.prototype.fitTransform = function (X) {
        return this.fit(X).transform(X);
    };
    /**
     * Inverse transform values back to original values.
     * @example
     * ```js
     * const encoder = new LabelEncoder()
     * encoder.fit(["a", "b", "c", "d"])
     * console.log(encoder.inverseTransform([0, 1, 2, 3]))
     * // ["a", "b", "c", "d"]
     * ```
     */
    LabelEncoder.prototype.inverseTransform = function (X) {
        var arr = this.convertTo1DArray(X);
        var labels = this.classesToMapping(this.classes);
        var invMap = new Map(Array.from(labels, function (a) { return a.reverse(); }));
        var tempData = arr.map(function (value) {
            return invMap.get(value) === undefined ? null : invMap.get(value);
        });
        return tempData;
    };
    return LabelEncoder;
}(Serialize));
export { LabelEncoder };
