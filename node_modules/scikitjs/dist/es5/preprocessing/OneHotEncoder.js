/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { convertScikit2DToArray } from '../utils';
import { TransformerMixin } from '../mixins';
import { getBackend } from '../tf-singleton';
import { isDataFrameInterface } from '../typesUtils';
/**
 * Fits a OneHotEncoder to the data.
 *
 * @example
 * ```js
 * import { OneHotEncoder } from 'scikitjs'
 *
 *
 * const X = [
    ['Male', 1],
    ['Female', 2],
    ['Male', 4]
   ]
   const encode = new OneHotEncoder()
   encode.fitTransform(X) // returns the object below
   const expected = [
    [1, 0, 1, 0, 0],
    [0, 1, 0, 1, 0],
    [1, 0, 0, 0, 1]
   ]
 * ```
 */
var OneHotEncoder = /** @class */ (function (_super) {
    __extends(OneHotEncoder, _super);
    function OneHotEncoder(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.categories, categories = _c === void 0 ? 'auto' : _c, _d = _b.handleUnknown, handleUnknown = _d === void 0 ? 'error' : _d, drop = _b.drop;
        var _this = _super.call(this) || this;
        /** Useful for pipelines and column transformers to have a default name for transforms */
        _this.name = 'OneHotEncoder';
        _this.tf = getBackend();
        _this.categoriesParam = categories;
        _this.categories = [];
        _this.handleUnknown = handleUnknown;
        _this.nFeaturesIn = 0;
        _this.featureNamesIn = [];
        _this.drop = drop;
        return _this;
    }
    OneHotEncoder.prototype.classesToMapping = function (classes) {
        var labels = new Map();
        classes.forEach(function (value, index) {
            labels.set(value, index);
        });
        return labels;
    };
    OneHotEncoder.prototype.loopOver2DArrayToSetLabels = function (array2D) {
        for (var j = 0; j < array2D[0].length; j++) {
            var curSet = new Set();
            for (var i = 0; i < array2D.length; i++) {
                curSet.add(array2D[i][j]);
            }
            var results = Array.from(curSet);
            this.categories.push(results);
        }
    };
    /**
     * Fits a OneHotEncoder to the data.
     * @param data 1d array of labels, Tensor, or  Series to be encoded.
     * @returns OneHotEncoder
     * @example
     * ```js
     * const encoder = new OneHotEncoder()
     * encoder.fit(["a", "b", "c"])
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    OneHotEncoder.prototype.fit = function (X, y) {
        var array2D = convertScikit2DToArray(X);
        if (this.categoriesParam === 'auto') {
            this.loopOver2DArrayToSetLabels(array2D);
            return this;
        }
        this.categories = this.categoriesParam;
        this.nFeaturesIn = array2D.length === 0 ? 0 : array2D[0].length || 0;
        if (isDataFrameInterface(X)) {
            this.featureNamesIn = __spreadArray([], __read(X.columns), false);
        }
        return this;
    };
    OneHotEncoder.prototype.loopOver2DArrayToUseLabels = function (array2D) {
        var _this = this;
        var labels = this.categories.map(function (el) { return _this.classesToMapping(el); });
        var finalArray = [];
        for (var i = 0; i < array2D.length; i++) {
            var curArray = [];
            for (var j = 0; j < array2D[0].length; j++) {
                var curElem = array2D[i][j];
                var val = labels[j].get(curElem);
                if (val === undefined) {
                    if (this.handleUnknown === 'error') {
                        throw new Error("Unknown value ".concat(curElem, " encountered while transforming. Not encountered in training data"));
                    }
                    else {
                        val = -1; // When we one hot encode this it will come back as all zeros
                    }
                }
                if (this.drop === 'first') {
                    val -= 1;
                }
                curArray.push(val);
            }
            finalArray.push(curArray);
        }
        return finalArray;
    };
    /** Generalization of the tf.oneHot that can handle "one-hotting" with a single column
     * output.
     */
    OneHotEncoder.prototype.convertToOneHot = function (tensor, numberOfOneHotColumns) {
        if (numberOfOneHotColumns >= 2) {
            return this.tf.oneHot(tensor, numberOfOneHotColumns);
        }
        if (numberOfOneHotColumns === 1) {
            // Every integer that isn't 0 becomes 0
            tensor = this.tf.where(tensor.equal(0), this.tf.ones(tensor.shape, 'int32'), this.tf.zeros(tensor.shape, 'int32'));
            return tensor.reshape([-1, 1]);
        }
        // Case where numberOfOneHotColumns = 0
        return this.tf.tensor2d([]);
    };
    /**
     * Encodes the data using the fitted OneHotEncoder.
     * @param data 1d array of labels, Tensor, or  Series to be encoded.
     * @example
     * ```js
     * const encoder = new OneHotEncoder()
     * encoder.fit(["a", "b", "c"])
     * encoder.transform(["a", "b", "c"])
     * ```
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    OneHotEncoder.prototype.transform = function (X, y) {
        var _this = this;
        var array2D = convertScikit2DToArray(X);
        var result2D = this.loopOver2DArrayToUseLabels(array2D);
        var newTensor = this.tf.tensor2d(result2D, undefined, 'int32');
        return this.tf.concat(newTensor.unstack(1).map(function (el, i) {
            var categoryNumber = _this.categories[i].length;
            var numberOfOneHotColumns = _this.drop === 'first' ? categoryNumber - 1 : categoryNumber;
            var val = _this.convertToOneHot(el, numberOfOneHotColumns);
            return val;
        }), 1);
    };
    /** Only works for single column OneHotEncoding */
    OneHotEncoder.prototype.inverseTransform = function (X) {
        var labels = this.classesToMapping(this.categories[0]);
        var tensorLabels = X.argMax(1);
        var invMap = new Map(Array.from(labels, function (a) { return a.reverse(); }));
        var tempData = tensorLabels.arraySync().map(function (value) {
            return invMap.get(value) === undefined ? null : invMap.get(value);
        });
        return tempData;
    };
    return OneHotEncoder;
}(TransformerMixin));
export { OneHotEncoder };
