"use strict";
/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.KNeighborsBase = void 0;
const BruteNeighborhood_1 = require("./BruteNeighborhood");
const Metric_1 = require("./Metric");
const utils_1 = require("../utils");
const typesUtils_1 = require("../typesUtils");
const KdTree_1 = require("./KdTree");
const tf_singleton_1 = require("../tf-singleton");
const simpleSerializer_1 = require("../simpleSerializer");
const WEIGHTS_FUNCTIONS = {
    uniform(distances) {
        let tf = (0, tf_singleton_1.getBackend)();
        const { shape } = distances;
        return tf.fill(shape, 1 / shape[1]);
    },
    distance(distances) {
        let tf = (0, tf_singleton_1.getBackend)();
        return tf.tidy(() => {
            // scale inverse distances by min. to avoid `1/tinyVal == Infinity`
            const min = distances.min(1, /*keepDims=*/ true);
            const invDist = tf.divNoNan(min.toFloat(), distances);
            const is0 = distances.lessEqual(0).toFloat();
            // avoid div by 0 by using `1/0 == 1` and `1/(x!=0) == 0` instead
            const weights = tf.where(min.lessEqual(0), is0, invDist);
            const wsum = weights.sum(1, /*keepDims=*/ true);
            return weights.div(wsum);
        });
    }
};
const METRICS = {
    minkowski: (p) => (0, Metric_1.minkowskiMetric)(p),
    manhattan: () => (0, Metric_1.minkowskiMetric)(1),
    euclidean: () => (0, Metric_1.minkowskiMetric)(2),
    chebyshev: () => (0, Metric_1.minkowskiMetric)(Infinity)
};
const ALGORITHMS = {
    kdTree: KdTree_1.KdTree.build,
    brute: async (params) => new BruteNeighborhood_1.BruteNeighborhood(params),
    auto: (params) => {
        return 'function' === typeof params.metric.minDistToBBox
            ? ALGORITHMS.kdTree(params)
            : ALGORITHMS.brute(params);
    }
};
/**
 * Common superclass for {@link KNeighborsRegressor} and {@link KNeighborsClassifier}.
 * Handles common constructor parameters and fitting.
 */
class KNeighborsBase extends simpleSerializer_1.Serialize {
    static SUPPORTED_ALGORITHMS = Object.freeze(Object.keys(ALGORITHMS));
    _neighborhood;
    _y;
    weights;
    algorithm;
    leafSize;
    p;
    metric;
    nNeighbors;
    constructor(params = {}) {
        super();
        Object.assign(this, params);
    }
    _getFitParams() {
        const { _neighborhood, _y, nNeighbors = 5, weights = 'uniform' } = this;
        (0, typesUtils_1.assert)(0 <= nNeighbors && nNeighbors % 1 === 0, 'KNeighbors({nNeighbors})::predict(X): nNeighbors must be a positive int.');
        (0, typesUtils_1.assert)(Object.keys(WEIGHTS_FUNCTIONS).includes(weights), 'KNeighbors({weights})::predict(X): invalid weights.');
        (0, typesUtils_1.assert)(undefined != _neighborhood && undefined != _y, 'KNeighbors::predict(X): model not trained yet. Call `await fit(x, y)` first.');
        const weightsFn = WEIGHTS_FUNCTIONS[weights];
        // make sure TypeScript knows that neighborhood and y are not undefined
        return {
            nNeighbors,
            weightsFn,
            neighborhood: _neighborhood,
            y: _y
        };
    }
    /**
     * Async function. Trains this model using the given features and targets.
     *
     * @param X The features of each training sample, where `X[i,j]` is the
     *          (j+1)-th feature of (i+1)-th sample.
     * @param y The target of each training sample, where `y[i]` the the
     *          target of the (i+1)-th sample.
     */
    async fit(X, y) {
        const { algorithm = 'auto', metric = 'minkowski', p = 2, leafSize } = this;
        (0, typesUtils_1.assert)(Object.keys(METRICS).includes(metric), 'KNeighbors({metric}).fit(X,y): invalid metric.');
        (0, typesUtils_1.assert)(Object.keys(ALGORITHMS).includes(algorithm), 'KNeighbors({algorithm}).fit(X,y): invalid algorithm.');
        const metricFn = METRICS[metric](p);
        const entries = (0, utils_1.convertToNumericTensor2D)(X);
        this._neighborhood = await ALGORITHMS[algorithm]({
            entries,
            metric: metricFn,
            leafSize
        });
        this._y = (0, utils_1.convertToNumericTensor1D)(y);
        return this;
    }
}
exports.KNeighborsBase = KNeighborsBase;
