/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
import { Neighborhood, NeighborhoodParams } from './Neighborhood';
import { BruteNeighborhood } from './BruteNeighborhood';
import { Scikit1D, Scikit2D, Tensor2D, Tensor1D } from '../types';
import { KdTree } from './KdTree';
import { Serialize } from '../simpleSerializer';
declare const WEIGHTS_FUNCTIONS: {
    uniform(distances: Tensor2D): Tensor2D;
    distance(distances: Tensor2D): any;
};
declare const METRICS: {
    minkowski: (p: number) => import("./Metric").Metric;
    manhattan: () => import("./Metric").Metric;
    euclidean: () => import("./Metric").Metric;
    chebyshev: () => import("./Metric").Metric;
};
declare const ALGORITHMS: {
    kdTree: typeof KdTree.build;
    brute: (params: NeighborhoodParams) => Promise<BruteNeighborhood>;
    auto: (params: NeighborhoodParams) => Promise<KdTree> | Promise<BruteNeighborhood>;
};
/**
 * Common super-interface for {@link KNeighborsRegressorParams}
 * and {@link KNeighborsClassifierParams}.
 */
export interface KNeighborsParams {
    /**
     * Weighting strategy for the neighboring target values during
     * prediction. `'uniform'` gives all targets the same weight
     * independent of distance. `'distance'` uses inverse distance
     * based weighting.
     */
    weights?: keyof typeof WEIGHTS_FUNCTIONS;
    /**
     * The algorithms used to compute nearest neighbors.
     */
    algorithm?: keyof typeof ALGORITHMS;
    /**
     * For tree-based algorithms, this is a hint as to how many
     * points are to be stored in a single leaf. The optimal
     * depends on the nature of the problem and the metric used.
     */
    leafSize?: number;
    /**
     * Power parameter for the Minkowski metric.
     * `p=1` corresponds to the `manhattan` distance.
     * `p=2` corresponds to the `euclidean` distance.
     * `p=Infinity` corresponds to the `chebyshev` distance.
     * </ul>
     */
    p?: number;
    /**
     * The metric to be used to compute nearest neighbor distances.
     */
    metric?: keyof typeof METRICS;
    /**
     * The number of neighbors used during prediction.
     */
    nNeighbors?: number;
}
/**
 * Common superclass for {@link KNeighborsRegressor} and {@link KNeighborsClassifier}.
 * Handles common constructor parameters and fitting.
 */
export declare class KNeighborsBase extends Serialize implements KNeighborsParams {
    static readonly SUPPORTED_ALGORITHMS: ("auto" | "kdTree" | "brute")[];
    _neighborhood: Neighborhood | undefined;
    _y: Tensor1D | undefined;
    weights: KNeighborsParams['weights'];
    algorithm: KNeighborsParams['algorithm'];
    leafSize: KNeighborsParams['leafSize'];
    p: KNeighborsParams['p'];
    metric: KNeighborsParams['metric'];
    nNeighbors: KNeighborsParams['nNeighbors'];
    constructor(params?: KNeighborsParams);
    protected _getFitParams(): {
        nNeighbors: number;
        weightsFn: ((distances: Tensor2D) => Tensor2D) | ((distances: Tensor2D) => any);
        neighborhood: Neighborhood;
        y: Tensor1D;
    };
    /**
     * Async function. Trains this model using the given features and targets.
     *
     * @param X The features of each training sample, where `X[i,j]` is the
     *          (j+1)-th feature of (i+1)-th sample.
     * @param y The target of each training sample, where `y[i]` the the
     *          target of the (i+1)-th sample.
     */
    fit(X: Scikit2D, y: Scikit1D): Promise<this>;
}
export {};
