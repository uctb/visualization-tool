"use strict";
/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.crossValScore = void 0;
const typesUtils_1 = require("../typesUtils");
const KFold_1 = require("./KFold");
const typesUtils_2 = require("../typesUtils");
const utils_1 = require("../utils");
const tf_singleton_1 = require("../tf-singleton");
async function crossValScore(estimator, X, y, params) {
    let tf = (0, tf_singleton_1.getBackend)();
    let unsupervised = y == null || (params == null && !(0, typesUtils_2.isScikit1D)(y));
    if (unsupervised) {
        params = params ?? y;
    }
    let { cv = new KFold_1.KFold(), groups, scoring } = params ?? {};
    if (scoring == null) {
        (0, typesUtils_1.assert)('function' === typeof estimator.score, 'crossValScore(estimator,[X,y],params): Either params.scoring or estimator.score(X,y) must be defined.');
        scoring = estimator.score;
    }
    const scores = [];
    scoring = scoring.bind(estimator);
    let result = undefined;
    tf.engine().startScope();
    try {
        X = (0, utils_1.convertToTensor2D)(X);
        if (!unsupervised) {
            y = (0, utils_1.convertToTensor1D)(y);
        }
        for (const { trainIndex, testIndex } of cv.split(X, y, groups)) {
            let score;
            const X_train = X.gather(trainIndex);
            const X_test = X.gather(testIndex);
            if (unsupervised) {
                await estimator.fit(X_train);
                score = scoring(X_test);
            }
            else {
                const y_train = y.gather(trainIndex);
                const y_test = y.gather(testIndex);
                await estimator.fit(X_train, y_train);
                score = scoring(X_test, y_test);
                y_train.dispose();
                y_test.dispose();
            }
            scores.push(score);
            trainIndex.dispose();
            testIndex.dispose();
            X_train.dispose();
            X_test.dispose();
        }
        return (result = tf.stack(scores));
    }
    finally {
        tf.engine().endScope(result);
    }
}
exports.crossValScore = crossValScore;
