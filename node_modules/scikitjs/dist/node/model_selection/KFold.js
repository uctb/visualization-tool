"use strict";
/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KFold = void 0;
const typesUtils_1 = require("../typesUtils");
const randUtils = __importStar(require("../randUtils"));
const utils_1 = require("../utils");
const tf_singleton_1 = require("../tf-singleton");
/**
 * K-Fold cross-validator
 *
 * Generates train and test indices to split data in train/test subsets.
 * To generate these subsets, the dataset is split into k (about) evenly
 * sized chunks of consecutive elements. Each split takes another chunk
 * as test data and the remaining chunks are combined to be the training
 * data.
 *
 * Optionally, the indices can be shuffled before splitting it into chunks
 * (disabled by default).
 *
 * @example
 * ```js
 * import { KFold } from 'scikitjs'
 *
 * const kf = new KFold({ nSplits: 3 })
 *
 * const X = tf.range(0, 7).reshape([7, 1]) as Tensor2D
 *
 * console.log( 'nSplits:', kf.getNumSplits(X) )
 *
 * for (const { trainIndex, testIndex } of kf.split(X) )
 * {
 *   try {
 *     console.log( 'train:', trainIndex.toString() )
 *     console.log( 'test:',   testIndex.toString() )
 *   }
 *   finally {
 *     trainIndex.dispose()
 *      testIndex.dispose()
 *   }
 * }
 * ```
 */
class KFold {
    nSplits;
    shuffle;
    randomState;
    name;
    tf;
    constructor({ nSplits = 5, shuffle = false, randomState } = {}) {
        nSplits = Number(nSplits);
        (0, typesUtils_1.assert)(Number.isInteger(nSplits) && nSplits > 1, 'new KFold({nSplits}): nSplits must be an int greater than 1.');
        this.tf = (0, tf_singleton_1.getBackend)();
        this.nSplits = nSplits;
        this.shuffle = Boolean(shuffle);
        this.randomState = randomState;
        this.name = 'KFold';
    }
    getNumSplits() {
        return this.nSplits;
    }
    *split(X, y, groups) {
        const { nSplits, shuffle, randomState } = this;
        const nSamples = (0, utils_1.getLength)(X);
        (0, typesUtils_1.assert)(nSplits <= nSamples, 'KFold({nSplits})::split(X): nSplits must not be greater than X.shape[0].');
        if (y != null) {
            (0, typesUtils_1.assert)(nSamples === (0, utils_1.getLength)(y), 'KFold::split(X,y): X.shape[0] must equal y.shape[0].');
        }
        if (groups != null) {
            (0, typesUtils_1.assert)(nSamples === (0, utils_1.getLength)(groups), 'KFold::split(X,y,groups): X.shape[0] must equal groups.shape[0].');
        }
        const range = new Int32Array(nSamples);
        for (let i = 0; i < range.length; i++) {
            range[i] = i;
        }
        if (shuffle) {
            const rng = randUtils.createRng(randomState);
            randUtils.shuffle(rng)(range);
        }
        const chunkBase = Math.floor(nSamples / nSplits);
        let remainder = nSamples % nSplits;
        let offset = 0;
        while (offset < nSamples) {
            const chunk = remainder-- > 0 ? chunkBase + 1 : chunkBase;
            const train = new Int32Array(nSamples - chunk);
            train.set(range.subarray(0, offset), 0);
            train.set(range.subarray(offset + chunk), offset);
            const test = range.slice(offset, offset + chunk);
            yield {
                trainIndex: this.tf.tensor1d(train, 'int32'),
                testIndex: this.tf.tensor1d(test, 'int32')
            };
            offset += chunk;
        }
    }
}
exports.KFold = KFold;
