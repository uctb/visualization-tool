"use strict";
/**
*  @license
* Copyright 2022, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.accuracy = exports.negMeanSquaredError = exports.negMeanAbsoluteError = void 0;
const tf_singleton_1 = require("../tf-singleton");
const utils_1 = require("../utils");
function negMeanAbsoluteError(X, y) {
    let tf = (0, tf_singleton_1.getBackend)();
    return tf.tidy(() => {
        y = (0, utils_1.convertToTensor1D)(y);
        const yPred = this.predict(X);
        return tf.metrics.meanAbsoluteError(y, yPred).neg();
    });
}
exports.negMeanAbsoluteError = negMeanAbsoluteError;
function negMeanSquaredError(X, y) {
    let tf = (0, tf_singleton_1.getBackend)();
    return tf.tidy(() => {
        y = (0, utils_1.convertToTensor1D)(y);
        const yPred = this.predict(X);
        return tf.metrics.meanSquaredError(y, yPred).neg();
    });
}
exports.negMeanSquaredError = negMeanSquaredError;
function accuracy(X, y) {
    let tf = (0, tf_singleton_1.getBackend)();
    return tf.tidy(() => {
        y = (0, utils_1.convertToTensor1D)(y);
        const yPred = this.predict(X);
        return tf.equal(y, yPred).sum().div(y.shape[0]);
    });
}
exports.accuracy = accuracy;
