import { Scikit1D, Scikit2D, Tensor1D, Tensor2D } from '../types';
import { Serialize } from '../simpleSerializer';
export interface NaiveBayesParams {
    /**
     * Prior probabilities of the classes. If specified the priors are not adjusted according to the data.
     */
    priors?: Scikit1D;
    /**
     * Portion of the largest variance of all features that is added to variances for calculation stability.
     * Default value is 1e-9
     */
    varSmoothing?: number;
}
export declare abstract class BaseNaiveBayes extends Serialize {
    priors?: Tensor1D;
    varSmoothing: number;
    classes: Tensor1D;
    means: Tensor1D[];
    variances: Tensor1D[];
    tf: any;
    constructor(params?: NaiveBayesParams);
    /**
     * Train the model by calculating the mean and variance of sample distribution.
     * @param X
     * @param y
     * @returns
     */
    fit(X: Scikit2D, y: Scikit1D): Promise<this>;
    /**
     * Predict the probability of samples assigned to each observed label.
     * @param X
     * @returns {this.tf.Tensor} Probabilities
     */
    predictProba(X: Scikit2D): any;
    /**
     * Predict the labels assigned to each sample
     * @param X
     * @returns {this.tf.Tensor} Labels
     */
    predict(X: Scikit2D): any;
    /**
     * Kernel function to calculate posterior probability, which should be implemented in the subclass.
     * @param features
     * @param mean
     * @param variance
     */
    protected abstract kernel(features: Tensor2D, mean: Tensor1D, variance: Tensor1D): Tensor1D;
}
