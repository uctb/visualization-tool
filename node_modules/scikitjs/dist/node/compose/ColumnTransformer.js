"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColumnTransformer = void 0;
const typesUtils_1 = require("../typesUtils");
const tf_singleton_1 = require("../tf-singleton");
const simpleSerializer_1 = require("../simpleSerializer");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isStringArray(arr) {
    return Array.isArray(arr) && typeof arr[0] === 'string';
}
/**
 * The ColumnTransformer transformers a 2D matrix of mixed types, with possibly missing values
 * into a 2DMatrix that is ready to be put into a machine learning model. Usually this class does
 * the heavy lifting associated with imputing missing data, one hot encoding categorical variables,
 * and any other preprocessing steps that are deemed necessary (standard scaling, etc).
 *
 * @example
 * ```typescript
    const X = [
      [2, 2],
      [2, 3],
      [0, NaN],
      [2, 0]
    ]

    const transformer = new ColumnTransformer({
      transformers: [
        ['minmax', new MinMaxScaler(), [0]],
        ['simpleImpute', new SimpleImputer({ strategy: 'median' }), [1]]
      ]
    })

    let result = transformer.fitTransform(X)
    const expected = [
      [1, 2],
      [1, 3],
      [0, 2],
      [1, 0]
    ]
 * ```
 */
class ColumnTransformer extends simpleSerializer_1.Serialize {
    transformers;
    remainder;
    /** Useful for pipelines and column transformers to have a default name for transforms */
    name = 'ColumnTransformer';
    tf;
    constructor({ transformers = [], remainder = 'drop' } = {}) {
        super();
        this.tf = (0, tf_singleton_1.getBackend)();
        this.transformers = transformers;
        this.remainder = remainder;
    }
    fit(X, y) {
        for (let i = 0; i < this.transformers.length; i++) {
            let [, curTransform, selection] = this.transformers[i];
            let subsetX = this.getColumns(X, selection);
            curTransform.fit(subsetX, y);
        }
        return this;
    }
    transform(X, y) {
        let output = [];
        for (let i = 0; i < this.transformers.length; i++) {
            let [, curTransform, selection] = this.transformers[i];
            let subsetX = this.getColumns(X, selection);
            output.push(curTransform.transform(subsetX, y));
        }
        return this.tf.concat(output, 1);
    }
    fitTransform(X, y) {
        let output = [];
        for (let i = 0; i < this.transformers.length; i++) {
            let [, curTransform, selection] = this.transformers[i];
            let subsetX = this.getColumns(X, selection);
            output.push(curTransform.fitTransform(subsetX, y));
        }
        return this.tf.concat(output, 1);
    }
    getColumns(X, selectedColumns) {
        if ((0, typesUtils_1.isDataFrameInterface)(X)) {
            if (isStringArray(selectedColumns)) {
                return X.loc({ columns: selectedColumns })
                    .tensor;
            }
            if (Array.isArray(selectedColumns)) {
                return X.iloc({ columns: selectedColumns })
                    .tensor;
            }
            if (typeof selectedColumns === 'string') {
                return X[selectedColumns].tensor;
            }
            return X.iloc({ columns: [selectedColumns] })
                .tensor;
        }
        else {
            if (isStringArray(selectedColumns) ||
                typeof selectedColumns === 'string') {
                throw new Error("Can't pass string selected columns when not a DataFrame");
            }
            if (typeof selectedColumns === 'number') {
                let columns = this.tf.tensor1d([selectedColumns]);
                return X.gather(columns, 1);
            }
            else {
                let columns = this.tf.tensor1d(selectedColumns);
                return X.gather(columns, 1);
            }
        }
    }
}
exports.ColumnTransformer = ColumnTransformer;
