"use strict";
/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DummyClassifier = void 0;
const utils_1 = require("../utils");
const typesUtils_1 = require("../typesUtils");
const simple_statistics_1 = require("simple-statistics");
const uniq_1 = __importDefault(require("lodash/uniq"));
const sample_1 = __importDefault(require("lodash/sample"));
const mixins_1 = require("../mixins");
const tf_singleton_1 = require("../tf-singleton");
/**
 * Creates an classifier that guesses a class label based on simple rules.
 * By setting a strategy (ie 'mostFrequent', 'uniform', or 'constant'),
 * you can create a simple classifier which can be helpful in determining
 * if a more complicated classifier is actually more predictive.
 *
 * @example
 * ```js
 * import { DummyClassifier } from 'scikitjs'
 *
 * const clf = new DummyClassifier({ strategy: 'mostFrequent' })
    const X = [
      [-1, 5],
      [-0.5, 5],
      [0, 10]
    ]
    const y = [10, 20, 20] // 20 is the most frequent class label
    clf.fit(X, y) // always predicts 20

    clf.predict([
      [0, 0],
      [1000, 1000]
    ]) // [20, 20]


 * ```
 *
 */
class DummyClassifier extends mixins_1.ClassifierMixin {
    constant;
    strategy;
    /**These are the unique class labels that are seen during fit. */
    classes;
    /** Useful for pipelines and column transformers to have a default name for transforms */
    name = 'DummyClassifier';
    tf;
    constructor({ strategy = 'mostFrequent', constant = 0 } = {}) {
        super();
        this.tf = (0, tf_singleton_1.getBackend)();
        this.constant = constant;
        this.strategy = strategy;
        this.classes = [];
    }
    /**
     * Fit a DummyClassifier to the data.
     */
    fit(X, y) {
        (0, typesUtils_1.assert)((0, typesUtils_1.isScikit1D)(y), 'Data can not be converted to a 1D or 2D matrix.');
        (0, typesUtils_1.assert)(['mostFrequent', 'uniform', 'constant'].includes(this.strategy), `Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);
        const newY = (0, utils_1.convertToNumericTensor1D)(y);
        this.classes = (0, uniq_1.default)(newY.arraySync());
        if (this.strategy === 'mostFrequent') {
            this.constant = (0, simple_statistics_1.modeFast)(newY.arraySync());
            return this;
        }
        // Handles 'constant' and 'uniform' case
        return this;
    }
    predictProba(X) {
        (0, typesUtils_1.assert)((0, typesUtils_1.isScikit2D)(X), 'Data can not be converted to a 1D or 2D matrix.');
        (0, typesUtils_1.assert)(['mostFrequent', 'uniform', 'constant'].includes(this.strategy), `Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);
        return this.tf.oneHot(this.predict(X).toInt(), this.classes.length);
    }
    predict(X) {
        (0, typesUtils_1.assert)((0, typesUtils_1.isScikit2D)(X), 'Data can not be converted to a 1D or 2D matrix.');
        (0, typesUtils_1.assert)(['mostFrequent', 'uniform', 'constant'].includes(this.strategy), `Strategy ${this.strategy} not supported. We support 'mostFrequent', 'uniform', and 'constant'`);
        let newData = (0, utils_1.convertToNumericTensor2D)(X);
        let length = newData.shape[0];
        if (this.strategy === 'mostFrequent' || this.strategy === 'constant') {
            return this.tf.tensor1d(Array(length).fill(this.constant));
        }
        // "Uniform case"
        let returnArr = [];
        for (let i = 0; i < length; i++) {
            returnArr.push((0, sample_1.default)(this.classes));
        }
        return this.tf.tensor1d(returnArr);
    }
}
exports.DummyClassifier = DummyClassifier;
