import { Scikit2D, Tensor1D, Tensor2D } from '../types';
import { Serialize } from '../simpleSerializer';
export interface KMeansParams {
    /** The number of clusters for the kmeans algorithm. **default = 8** */
    nClusters?: number;
    /** Initialization strategy for KMeans. Currently it only supports 'random' which selects
     * random points from the input to to be the initial centers. We will soon support 'kmeans++'
     * which is an alternative initialization strategy that speeds up convergences. **default = "random"**
     */
    init?: 'random';
    /** The number of times to run KMeans. We choose the solution which has the smallest inertia. **default = 10** */
    nInit?: number;
    /** Max number of iterations for the KMeans fit. **default = 300** */
    maxIter?: number;
    /** Tolerance is the number where if the KMeans doesn't generate a better solution
     * than it ceases execution. **default = 1e-4** */
    tol?: number;
    /** Because there is a random element to KMeans, if you need a deterministic repeatable KMeans
     * solution (for testing or other deterministic situations), you can set the random seed here.
     * **default = undefined**
     */
    randomState?: number;
}
/**
 * The KMeans algorithm clusters data by trying to separate samples into `k` groups
 * of equal variance, minimizing a criterion known as the inertia or within-cluster sum-of-squares.
 *
 * <!-- prettier-ignore-start -->
 * $$
 * \sum_{i=0}^{n}\min_{\mu_j \in C}(||x_i - \mu_j||^2)
 * $$
 *
 * @example
 * ```js
 * let X = [
 *  [1, 2],
    [1, 4],
    [4, 4],
    [4, 0]
   ]
   const kmean = new KMeans({ nClusters: 2 })
   kmean.fit(X)
   ```
 */
export declare class KMeans extends Serialize {
    nClusters: number;
    init: string;
    nInit?: number;
    maxIter: number;
    tol: number;
    randomState?: number;
    /** The actual cluster centers found by KMeans */
    clusterCenters: Tensor2D;
    /** Useful for pipelines and column transformers to have a default name for transforms */
    name: string;
    tf: any;
    constructor({ nClusters, init, maxIter, tol, nInit, randomState }?: KMeansParams);
    initCentroids(X: Tensor2D): void;
    closestCentroid(X: Tensor2D): Tensor1D;
    updateCentroids(X: Tensor2D, nearestIndices: Tensor1D): Tensor2D;
    /**
     * Runs the KMeans algo over your input.
     * @param X The 2D Matrix that you wish to cluster
     */
    fit(X: Scikit2D): KMeans;
    /**
     * Converts 2D input into a 1D Tensor which holds the KMeans cluster Class label
     * @param X The 2D Matrix that you wish to cluster
     */
    predict(X: Scikit2D): Tensor1D;
    transform(X: Scikit2D): Tensor2D;
    fitPredict(X: Scikit2D): Tensor1D;
    fitTransform(X: Scikit2D): Tensor2D;
    score(X: Scikit2D): Tensor1D;
}
