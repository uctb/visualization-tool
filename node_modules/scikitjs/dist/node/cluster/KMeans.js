"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KMeans = void 0;
const utils_1 = require("../utils");
const tf_singleton_1 = require("../tf-singleton");
const simpleSerializer_1 = require("../simpleSerializer");
/**
 * The KMeans algorithm clusters data by trying to separate samples into `k` groups
 * of equal variance, minimizing a criterion known as the inertia or within-cluster sum-of-squares.
 *
 * <!-- prettier-ignore-start -->
 * $$
 * \sum_{i=0}^{n}\min_{\mu_j \in C}(||x_i - \mu_j||^2)
 * $$
 *
 * @example
 * ```js
 * let X = [
 *  [1, 2],
    [1, 4],
    [4, 4],
    [4, 0]
   ]
   const kmean = new KMeans({ nClusters: 2 })
   kmean.fit(X)
   ```
 */
class KMeans extends simpleSerializer_1.Serialize {
    nClusters;
    init;
    nInit;
    maxIter;
    tol;
    randomState;
    // Attributes
    /** The actual cluster centers found by KMeans */
    clusterCenters;
    /** Useful for pipelines and column transformers to have a default name for transforms */
    name = 'KMeans';
    tf;
    constructor({ nClusters = 8, init = 'random', maxIter = 300, tol = 0.0001, nInit = 10, randomState } = {}) {
        super();
        this.tf = (0, tf_singleton_1.getBackend)();
        this.nClusters = nClusters;
        this.init = init;
        this.maxIter = maxIter;
        this.tol = tol;
        this.randomState = randomState;
        this.nInit = nInit;
        this.clusterCenters = this.tf.tensor2d([[]]);
    }
    initCentroids(X) {
        if (this.init === 'random') {
            let indices = (0, utils_1.sampleWithoutReplacement)(X.shape[0], this.nClusters, this.randomState);
            this.clusterCenters = this.tf.gather(X, indices);
            return;
        }
        throw new Error(`init ${this.init} is not currently implemented`);
    }
    closestCentroid(X) {
        return this.tf.tidy(() => {
            const expandedX = this.tf.expandDims(X, 1);
            const expandedClusters = this.tf.expandDims(this.clusterCenters, 0);
            return this.tf
                .squaredDifference(expandedX, expandedClusters)
                .sum(2)
                .argMin(1);
        });
    }
    updateCentroids(X, nearestIndices) {
        return this.tf.tidy(() => {
            const newCentroids = [];
            for (let i = 0; i < this.nClusters; i++) {
                const mask = this.tf.equal(nearestIndices, this.tf.scalar(i).toInt());
                const currentCentroid = this.tf.div(
                // set all masked instances to 0 by multiplying the mask tensor,
                // then sum across all instances
                this.tf.sum(this.tf.mul(this.tf.expandDims(mask.toFloat(), 1), X), 0), 
                // divided by number of instances
                this.tf.sum(mask.toFloat()));
                newCentroids.push(currentCentroid);
            }
            return this.tf.stack(newCentroids);
        });
    }
    /**
     * Runs the KMeans algo over your input.
     * @param X The 2D Matrix that you wish to cluster
     */
    fit(X) {
        let XTensor2D = (0, utils_1.convertToNumericTensor2D)(X);
        this.initCentroids(XTensor2D);
        for (let i = 0; i < this.maxIter; i++) {
            const centroidPicks = this.closestCentroid(XTensor2D);
            this.clusterCenters = this.updateCentroids(XTensor2D, centroidPicks);
        }
        return this;
    }
    /**
     * Converts 2D input into a 1D Tensor which holds the KMeans cluster Class label
     * @param X The 2D Matrix that you wish to cluster
     */
    predict(X) {
        let XTensor2D = (0, utils_1.convertToNumericTensor2D)(X);
        return this.closestCentroid(XTensor2D);
    }
    transform(X) {
        return this.tf.tidy(() => {
            const XTensor2D = (0, utils_1.convertToNumericTensor2D)(X);
            const expandedX = this.tf.expandDims(XTensor2D, 1);
            const expandedClusters = this.tf.expandDims(this.clusterCenters, 0);
            return this.tf
                .squaredDifference(expandedX, expandedClusters)
                .sum(2)
                .sqrt();
        });
    }
    fitPredict(X) {
        return this.fit(X).predict(X);
    }
    fitTransform(X) {
        return this.fit(X).transform(X);
    }
    score(X) {
        return this.tf.tidy(() => {
            const XTensor2D = (0, utils_1.convertToNumericTensor2D)(X);
            const expandedX = this.tf.expandDims(XTensor2D, 1);
            const expandedClusters = this.tf.expandDims(this.clusterCenters, 0);
            return this.tf
                .squaredDifference(expandedX, expandedClusters)
                .sum(2)
                .min(1)
                .sqrt()
                .sum();
        });
    }
}
exports.KMeans = KMeans;
