"use strict";
/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rocAucScore = exports.confusionMatrix = exports.zeroOneLoss = exports.logLoss = exports.huberLoss = exports.hingeLoss = exports.meanSquaredLogError = exports.meanSquaredError = exports.meanAbsoluteError = exports.r2Score = exports.recallScore = exports.precisionScore = exports.accuracyScore = void 0;
const utils_1 = require("../utils");
const typesUtils_1 = require("../typesUtils");
const uniq_1 = __importDefault(require("lodash/uniq"));
const tf_singleton_1 = require("../tf-singleton");
function assertInputIsWellFormed(labels, predictions) {
    (0, typesUtils_1.assert)((0, typesUtils_1.isScikit1D)(labels), "Labels can't be converted to a 1D Tensor");
    (0, typesUtils_1.assert)((0, typesUtils_1.isScikit1D)(predictions), "Predictions can't be converted to a 1D Tensor");
    let labelsT = (0, utils_1.convertToNumericTensor1D)(labels);
    let predictionsT = (0, utils_1.convertToNumericTensor1D)(predictions);
    (0, typesUtils_1.assert)(labelsT.size > 0, 'Must have 1 label or more');
    (0, typesUtils_1.assert)(predictionsT.size > 0, 'Must have 1 prediction or more');
    (0, typesUtils_1.assert)(labelsT.size === predictionsT.size, 'Not the same size arrays');
    return { labelsT, predictionsT };
}
//////////////////////////////////////
// Scoring functions
//////////////////////////////////////
/**
 *
 * ```js
 *const labels = [1, 2, 3, 1]
  const predictions = [1, 2, 4, 4]
  let result = metrics.accuracyScore(labels, predictions)
  console.log(result) // 0.5
 *```
 * @param labels 1D Array-like that are the true values
 * @param predictions 1D Array-like that are your model predictions
 * @returns number
 */
function accuracyScore(labels, predictions) {
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = labelsT.equal(predictionsT).sum().div(labelsT.size);
    return result.dataSync()[0];
}
exports.accuracyScore = accuracyScore;
function precisionScore(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = tf.metrics.precision(labelsT, predictionsT);
    return result.dataSync()[0];
}
exports.precisionScore = precisionScore;
function recallScore(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = tf.metrics.recall(labelsT, predictionsT);
    return result.dataSync()[0];
}
exports.recallScore = recallScore;
function r2Score(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const numerator = tf.metrics.meanSquaredError(labelsT, predictionsT);
    const denominator = tf.metrics.meanSquaredError(labelsT, labelsT.mean());
    const result = tf.sub(1, numerator.div(denominator));
    return result.dataSync()[0];
}
exports.r2Score = r2Score;
//////////////////////////////////////
// Error or Loss functions
//////////////////////////////////////
function meanAbsoluteError(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = tf.metrics.meanAbsoluteError(labelsT, predictionsT);
    return result.dataSync()[0];
}
exports.meanAbsoluteError = meanAbsoluteError;
function meanSquaredError(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = tf.metrics.meanSquaredError(labelsT, predictionsT);
    return result.dataSync()[0];
}
exports.meanSquaredError = meanSquaredError;
function meanSquaredLogError(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = tf
        .square(labelsT.log1p().sub(predictionsT.log1p()))
        .sum()
        .div(labelsT.size);
    return result.dataSync()[0];
}
exports.meanSquaredLogError = meanSquaredLogError;
function hingeLoss(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = tf.losses.hingeLoss(labelsT, predictionsT);
    return result.dataSync()[0];
}
exports.hingeLoss = hingeLoss;
function huberLoss(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = tf.losses.huberLoss(labelsT, predictionsT);
    return result.dataSync()[0];
}
exports.huberLoss = huberLoss;
function logLoss(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = tf.losses.logLoss(labelsT, predictionsT);
    return result.dataSync()[0];
}
exports.logLoss = logLoss;
function zeroOneLoss(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const result = tf.sub(1, accuracyScore(labelsT, predictionsT));
    return result.dataSync()[0];
}
exports.zeroOneLoss = zeroOneLoss;
//////////////////////////////////////
// Odds and Ends
//////////////////////////////////////
function confusionMatrix(labels, predictions) {
    let tf = (0, tf_singleton_1.getBackend)();
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    const uniqueNumber = (0, uniq_1.default)(labelsT.dataSync());
    return tf.math
        .confusionMatrix(labelsT, predictionsT, uniqueNumber.length)
        .arraySync();
}
exports.confusionMatrix = confusionMatrix;
function rocAucScore(labels, predictions) {
    const { labelsT, predictionsT } = assertInputIsWellFormed(labels, predictions);
    // Next steps: This can prob be done faster with tensor magic
    let x = labelsT.arraySync();
    let y = predictionsT.arraySync();
    x.push(1);
    y.push(1);
    let area = 0;
    for (let i = 0; i < x.length - 1; i++) {
        area += x[i] * y[i + 1] - x[i + 1] * y[i];
    }
    area -= 1;
    return Math.abs(area) / 2;
}
exports.rocAucScore = rocAucScore;
