"use strict";
/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleImputer = void 0;
const utils_1 = require("../utils");
const math_1 = require("../math");
const mathjs_1 = require("mathjs");
const simple_statistics_1 = require("simple-statistics");
const mixins_1 = require("../mixins");
const tf_singleton_1 = require("../tf-singleton");
/*
Next steps:
1. Make SimpleImputer work with strings
*/
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isEmpty(value) {
    return (value === undefined ||
        value === null ||
        (isNaN(value) && typeof value !== 'string'));
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function removeMissingValuesFromArray(arr) {
    const values = arr.filter((val) => {
        return !isEmpty(val);
    });
    return values;
}
class SimpleImputer extends mixins_1.TransformerMixin {
    missingValues;
    fillValue;
    strategy;
    statistics;
    /** Useful for pipelines and column transformers to have a default name for transforms */
    name = 'SimpleImputer';
    tf;
    constructor({ strategy = 'mean', fillValue = undefined, missingValues = NaN } = {}) {
        super();
        this.tf = (0, tf_singleton_1.getBackend)();
        this.missingValues = missingValues;
        this.strategy = strategy;
        this.fillValue = fillValue;
        this.statistics = this.tf.tensor1d([]);
    }
    fit(X) {
        // Fill with value passed into fillValue argument
        if (this.strategy === 'constant') {
            return this;
        }
        if (this.strategy === 'mean') {
            const newTensor = (0, utils_1.convertToNumericTensor2D)(X);
            const mean = (0, math_1.tensorMean)(newTensor, 0, true);
            this.statistics = mean;
            return this;
        }
        if (this.strategy === 'mostFrequent') {
            const newTensor = (0, utils_1.convertToNumericTensor2D)(X);
            const mostFrequents = newTensor
                .transpose()
                .arraySync()
                .map((arr) => (0, simple_statistics_1.modeFast)(removeMissingValuesFromArray(arr)));
            this.statistics = this.tf.tensor1d(mostFrequents);
            return this;
        }
        if (this.strategy === 'median') {
            const newTensor = (0, utils_1.convertToNumericTensor2D)(X);
            const medians = newTensor
                .transpose()
                .arraySync()
                .map((arr) => (0, mathjs_1.median)(removeMissingValuesFromArray(arr)));
            this.statistics = this.tf.tensor1d(medians);
            return this;
        }
        throw new Error(`Strategy ${this.strategy} is unsupported. Supported strategies are 'mean', 'median', 'mostFrequent', and 'constant'`);
    }
    transform(X) {
        if (this.strategy === 'constant') {
            const newTensor = (0, utils_1.convertToTensor2D)(X);
            if (this.fillValue === undefined) {
                if (newTensor.dtype !== 'string') {
                    return this.tf.where(newTensor.isNaN(), 0, newTensor);
                }
                else {
                    return this.tf.where(newTensor.isNaN(), 'missing_value', newTensor);
                }
            }
            return this.tf.where(newTensor.isNaN(), this.fillValue, newTensor);
        }
        // Not strategy constant
        const newTensor = (0, utils_1.convertToNumericTensor2D)(X);
        return this.tf.where(newTensor.isNaN(), this.statistics.reshape([1, -1]), newTensor);
    }
}
exports.SimpleImputer = SimpleImputer;
