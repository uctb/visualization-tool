"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeVotingClassifier = exports.VotingClassifier = void 0;
const tf_singleton_1 = require("../tf-singleton");
const mixins_1 = require("../mixins");
const LabelEncoder_1 = require("../preprocessing/LabelEncoder");
/**
 * A voting regressor is an ensemble meta-estimator that fits several base
 * regressors, each on the whole dataset. Then it averages the individual
 * predictions to form a final prediction.
 *
 * @example
 * ```js
 * import { VotingClassifier, DummyClassifier, LogisticRegression } from 'scikitjs'
 *
 * const X = [
      [1, 2],
      [2, 1],
      [2, 2],
      [3, 1],
      [4, 4]
    ]
    const y = [0, 0, 1, 1, 1]
    const voter = new VotingClassifier({
      estimators: [
        ['dt', new DummyClassifier()],
        ['dt', new DummyClassifier()],
        ['lr', new LogisticRegression({ penalty: 'none' })]
      ]
    })

    await voter.fit(X, y)
    assert.deepEqual(voter.predict(X).arraySync(), [1, 1, 1, 1, 1])
 * ```
 */
class VotingClassifier extends mixins_1.ClassifierMixin {
    estimators;
    weights;
    le;
    name = 'VotingClassifier';
    tf;
    constructor({ estimators = [], weights = undefined, voting = 'hard' } = {}) {
        super();
        this.tf = (0, tf_singleton_1.getBackend)();
        this.estimators = estimators;
        this.weights = weights;
        this.voting = voting;
        this.le = new LabelEncoder_1.LabelEncoder();
    }
    async fit(X, y) {
        let newY = this.le.fitTransform(y);
        for (let i = 0; i < this.estimators?.length; i++) {
            let [_, curEstimator] = this.estimators[i];
            await curEstimator.fit(X, newY);
        }
        return this;
    }
    predictProba(X) {
        let responses = [];
        let numEstimators = this.estimators.length;
        const weights = this.weights || Array(numEstimators).fill(1 / numEstimators);
        for (let i = 0; i < numEstimators; i++) {
            let [_, curEstimator] = this.estimators[i];
            let curWeight = weights[i];
            responses.push(curEstimator.predictProba(X).mul(curWeight));
        }
        return this.tf.addN(responses);
    }
    // only hard case
    predict(X) {
        let responses = [];
        let numEstimators = this.estimators.length;
        const weights = this.weights || Array(numEstimators).fill(1 / numEstimators);
        if (this.voting === 'hard') {
            for (let i = 0; i < numEstimators; i++) {
                let [_, curEstimator] = this.estimators[i];
                let curWeight = weights[i];
                let predictions = curEstimator.predict(X).toInt();
                let oneHot = this.tf.oneHot(predictions, this.le.classes.length);
                responses.push(oneHot.mul(curWeight));
            }
            return this.tf.tensor1d(this.le.inverseTransform(this.tf.addN(responses).argMax(1)));
        }
        else {
            for (let i = 0; i < numEstimators; i++) {
                let [_, curEstimator] = this.estimators[i];
                let curWeight = weights[i];
                let predictions = curEstimator.predictProba(X);
                responses.push(predictions.mul(curWeight));
            }
            return this.tf.tensor1d(this.le.inverseTransform(this.tf.addN(responses).argMax(1)));
        }
    }
    transform(X) {
        let responses = [];
        let numEstimators = this.estimators.length;
        if (this.voting === 'hard') {
            for (let i = 0; i < numEstimators; i++) {
                let [_, curEstimator] = this.estimators[i];
                responses.push(curEstimator.predict(X));
            }
            return responses;
        }
        else {
            for (let i = 0; i < numEstimators; i++) {
                let [_, curEstimator] = this.estimators[i];
                responses.push(curEstimator.predictProba(X));
            }
            return responses;
        }
    }
    async fitTransform(X, y) {
        return (await this.fit(X, y)).transform(X);
    }
}
exports.VotingClassifier = VotingClassifier;
function makeVotingClassifier(...args) {
    let estimators = [];
    for (let i = 0; i < args.length; i++) {
        // eslint-disable-next-line prefer-rest-params
        let cur = args[i];
        estimators.push([cur.name, cur]);
    }
    return new VotingClassifier({ estimators });
}
exports.makeVotingClassifier = makeVotingClassifier;
