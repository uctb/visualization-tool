"use strict";
/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardScaler = void 0;
const utils_1 = require("../utils");
const typesUtils_1 = require("../typesUtils");
const math_1 = require("../math");
const mixins_1 = require("../mixins");
const tf_singleton_1 = require("../tf-singleton");
/**
 * Standardize features by removing the mean and scaling to unit variance.
 * The standard score of a sample x is calculated as: $z = (x - u) / s$,
 * where $u$ is the mean of the training samples, and $s$ is the standard deviation of the training samples.
 *
 * @example
 * ```js
 * import { StandardScaler } from 'scikitjs'
 *
 * const data = [
      [0, 0],
      [0, 0],
      [1, 1],
      [1, 1]
    ]

    const scaler = new StandardScaler()
    const expected = scaler.fitTransform(data)
    // const expected = [
    //  [-1, -1],
    //  [-1, -1],
    //  [1, 1],
    //  [1, 1]
    // ]
 * ```
 */
class StandardScaler extends mixins_1.TransformerMixin {
    /** The per-feature scale that we see in the dataset. We divide by this number. */
    scale;
    /** The per-feature mean that we see in the dataset. We subtract by this number. */
    mean;
    /** Whether or not we should subtract the mean */
    withMean;
    /** Whether or not we should divide by the standard deviation */
    withStd;
    /** The number of features seen during fit */
    nFeaturesIn;
    /** The number of samples processed by the Estimator. Will be reset on new calls to fit */
    nSamplesSeen;
    /** Names of features seen during fit. Only stores feature names if input is a DataFrame */
    featureNamesIn;
    /** Useful for pipelines and column transformers to have a default name for transforms */
    name = 'StandardScaler';
    constructor({ withMean = true, withStd = true } = {}) {
        super();
        this.tf = (0, tf_singleton_1.getBackend)();
        this.withMean = withMean;
        this.withStd = withStd;
        this.scale = this.tf.tensor1d([]);
        this.mean = this.tf.tensor1d([]);
        this.nFeaturesIn = 0;
        this.nSamplesSeen = 0;
        this.featureNamesIn = [];
    }
    /**
     * Fit a StandardScaler to the data.
     */
    fit(X) {
        (0, typesUtils_1.assert)((0, typesUtils_1.isScikit2D)(X), 'Data can not be converted to a 2D matrix.');
        const tensorArray = (0, utils_1.convertToNumericTensor2D)(X);
        if (this.withMean) {
            this.mean = (0, math_1.tensorMean)(tensorArray, 0, true);
        }
        if (this.withStd) {
            const std = (0, math_1.tensorStd)(tensorArray, 0, true);
            // Deal with zero variance issues
            this.scale = (0, math_1.turnZerosToOnes)(std);
        }
        this.nSamplesSeen = tensorArray.shape[0];
        this.nFeaturesIn = tensorArray.shape[1];
        if ((0, typesUtils_1.isDataFrameInterface)(X)) {
            this.featureNamesIn = [...X.columns];
        }
        return this;
    }
    /**
     * Transform the data using the fitted scaler
     */
    transform(X) {
        (0, typesUtils_1.assert)((0, typesUtils_1.isScikit2D)(X), 'Data can not be converted to a 2D matrix.');
        let tensorArray = (0, utils_1.convertToNumericTensor2D)(X);
        if (this.withMean) {
            tensorArray = tensorArray.sub(this.mean);
        }
        if (this.withStd) {
            tensorArray = tensorArray.div(this.scale);
        }
        return tensorArray;
    }
    /**
     * Inverse transform the data using the fitted scaler
     */
    inverseTransform(X) {
        (0, typesUtils_1.assert)((0, typesUtils_1.isScikit2D)(X), 'Data can not be converted to a 2D matrix.');
        let tensorArray = (0, utils_1.convertToNumericTensor2D)(X);
        if (this.withStd) {
            tensorArray = tensorArray.mul(this.scale);
        }
        if (this.withMean) {
            tensorArray = tensorArray.add(this.mean);
        }
        return tensorArray;
    }
}
exports.StandardScaler = StandardScaler;
