"use strict";
/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.RobustScaler = void 0;
const utils_1 = require("../utils");
const typesUtils_1 = require("../typesUtils");
const math_1 = require("../math");
const mixins_1 = require("../mixins");
const mathjs_1 = require("mathjs");
const tf_singleton_1 = require("../tf-singleton");
/**
 * Transform features by scaling each feature to a given range.
 * This estimator scales and translates each feature individually such
 * that it is in the given range on the training set, e.g. between the maximum and minimum value.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isEmpty(value) {
    return (value === undefined ||
        value === null ||
        (isNaN(value) && typeof value !== 'string'));
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function removeMissingValuesFromArray(arr) {
    const values = arr.filter((val) => {
        return !isEmpty(val);
    });
    return values;
}
/**
 * Scales the data but is robust to outliers. While StandardScaler will subtract the mean, and
 * divide by the variance, both of those measures are not robust to outliers. So instead of the mean
 * we use the median, and instead of the variance we use the Interquartile Range (which is the distance
 * between the quantile .25, and quantile .75).
 *
 * @example
 * ```js
 * import { RobustScaler } from 'scikitjs'
 *
    const X = [
      [1, -2, 2],
      [-2, 1, 3],
      [4, 1, -2]
    ]

    const scaler = new RobustScaler()
    scaler.fitTransform(X)

    const result = [
      [0, -2, 0],
      [-1, 0, 0.4],
      [1, 0, -1.6]
    ]
 * ```
 */
class RobustScaler extends mixins_1.TransformerMixin {
    /** The per-feature scale that we see in the dataset. We divide by this number. */
    scale;
    /** The per-feature median that we see in the dataset. We subtrace this number. */
    center;
    /** The number of features seen during fit */
    nFeaturesIn;
    /** Names of features seen during fit. Only stores feature names if input is a DataFrame */
    featureNamesIn;
    quantileRange;
    withScaling;
    withCentering;
    /** Useful for pipelines and column transformers to have a default name for transforms */
    name = 'RobustScaler';
    constructor({ quantileRange = [25.0, 75.0], withCentering = true, withScaling = true } = {}) {
        super();
        this.tf = (0, tf_singleton_1.getBackend)();
        this.scale = this.tf.tensor1d([]);
        this.center = this.tf.tensor1d([]);
        this.quantileRange = quantileRange;
        this.withScaling = withScaling;
        this.withCentering = withCentering;
        this.nFeaturesIn = 0;
        this.featureNamesIn = [];
    }
    isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    }
    fit(X) {
        (0, typesUtils_1.assert)((0, typesUtils_1.isScikit2D)(X), 'Data can not be converted to a 2D matrix.');
        (0, typesUtils_1.assert)(this.isNumber(this.quantileRange[0]) &&
            this.isNumber(this.quantileRange[1]), 'quantileRange values must be numbers');
        let lowPercentile = this.quantileRange[0];
        let highPercentile = this.quantileRange[1];
        (0, typesUtils_1.assert)(lowPercentile < highPercentile &&
            0 <= lowPercentile &&
            lowPercentile <= 100 &&
            0 <= highPercentile &&
            highPercentile <= 100, 'quantileRange numbers must be between 0 and 100');
        const tensorArray = (0, utils_1.convertToNumericTensor2D)(X);
        const rowOrientedArray = tensorArray.transpose().arraySync();
        if (this.withCentering) {
            const quantiles = rowOrientedArray.map((arr) => (0, mathjs_1.quantileSeq)(removeMissingValuesFromArray(arr), 0.5));
            this.center = this.tf.tensor1d(quantiles);
        }
        if (this.withScaling) {
            const quantiles = rowOrientedArray.map((arr) => (0, mathjs_1.quantileSeq)(removeMissingValuesFromArray(arr), [
                lowPercentile / 100,
                highPercentile / 100
            ]));
            const scale = this.tf.tensor1d(quantiles.map((el) => el[1] - el[0]));
            // But what happens if max = min, ie.. we are dealing with a constant vector?
            // In the case above, scale = max - min = 0 and we'll divide by 0 which is no bueno.
            // The common practice in cases where the vector is constant is to change the 0 elements
            // in scale to 1, so that the division doesn't fail. We do that below
            this.scale = (0, math_1.turnZerosToOnes)(scale);
        }
        this.nFeaturesIn = tensorArray.shape[1];
        if ((0, typesUtils_1.isDataFrameInterface)(X)) {
            this.featureNamesIn = [...X.columns];
        }
        return this;
    }
    transform(X) {
        (0, typesUtils_1.assert)((0, typesUtils_1.isScikit2D)(X), 'Data can not be converted to a 2D matrix.');
        let tensorArray = (0, utils_1.convertToNumericTensor2D)(X);
        if (this.withCentering) {
            tensorArray = tensorArray.sub(this.center);
        }
        if (this.withScaling) {
            tensorArray = tensorArray.div(this.scale);
        }
        return tensorArray;
    }
    inverseTransform(X) {
        (0, typesUtils_1.assert)((0, typesUtils_1.isScikit2D)(X), 'Data can not be converted to a 2D matrix.');
        let tensorArray = (0, utils_1.convertToNumericTensor2D)(X);
        if (this.withScaling) {
            tensorArray = tensorArray.mul(this.scale);
        }
        if (this.withCentering) {
            tensorArray = tensorArray.add(this.center);
        }
        return tensorArray;
    }
}
exports.RobustScaler = RobustScaler;
