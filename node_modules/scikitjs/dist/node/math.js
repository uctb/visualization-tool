"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.turnZerosToOnes = exports.tensorStd = exports.tensorMean = exports.simpleMean = exports.tensorCount = exports.simpleCount = exports.tensorSum = exports.simpleSum = exports.tensorMax = exports.simpleMax = exports.tensorMin = exports.simpleMin = void 0;
const typesUtils_1 = require("./typesUtils");
const tf_singleton_1 = require("./tf-singleton");
/*
In creating the preprocessors, I wanted functions that computed the min, max, mean,
etc... but that also ignored NaN values. The min / max functions that come from
Tensorflow don't support ignoring NaN's, so we perform some magic to get the result.

After running some tests, I've concluded that the fastest way to
get the min, mean, median, most_frequent, etc... is to not copy the input array.
So the "fastest" way to perform any action is to simply loop over the initial
array if the user passes in an array, or to use Tensor methods if the user
passes in a Tensor.

The "copying" of the array into a tf Tensor is way slower than simply writing the
for loop.

So below we have simple mean, max, min, functions that work with arrays, or tensors
that ignore NaNs
*/
//////////////////////////////////////////////////////////////////////////
// Min Functions
//////////////////////////////////////////////////////////////////////////
function simpleMin(arr, ignoreNaN) {
    (0, typesUtils_1.assert)(arr.length > 0, `Array ${arr} must have length greater than 0 in order to find a minimum element`);
    let min = arr[0];
    for (let i = 0; i < arr.length; i++) {
        let current = arr[i];
        if (ignoreNaN && isNaN(current)) {
            continue;
        }
        if (current < min) {
            min = current;
        }
    }
    return min;
}
exports.simpleMin = simpleMin;
function tensorMin(tensor, axis, ignoreNaN) {
    let tf = (0, tf_singleton_1.getBackend)();
    if (ignoreNaN) {
        return tf.tidy(() => tf.where(tensor.isNaN(), Infinity, tensor).min(axis));
    }
    return tensor.min(axis);
}
exports.tensorMin = tensorMin;
//////////////////////////////////////////////////////////////////////////
// Max Functions
//////////////////////////////////////////////////////////////////////////
function simpleMax(arr, ignoreNaN) {
    (0, typesUtils_1.assert)(arr.length > 0, `Array ${arr} must have length greater than 0 in order to find a maximum element`);
    let max = arr[0];
    for (let i = 0; i < arr.length; i++) {
        let current = arr[i];
        if (ignoreNaN && isNaN(current)) {
            continue;
        }
        if (current > max) {
            max = current;
        }
    }
    return max;
}
exports.simpleMax = simpleMax;
function tensorMax(tensor, axis, ignoreNaN) {
    let tf = (0, tf_singleton_1.getBackend)();
    if (ignoreNaN) {
        return tf.tidy(() => tf.where(tensor.isNaN(), -Infinity, tensor).max(axis));
    }
    return tensor.min(axis);
}
exports.tensorMax = tensorMax;
//////////////////////////////////////////////////////////////////////////
// Sum Functions
//////////////////////////////////////////////////////////////////////////
function simpleSum(arr, ignoreNaN) {
    let total = 0;
    for (let i = 0; i < arr.length; i++) {
        const current = arr[i];
        if (ignoreNaN && isNaN(current)) {
            continue;
        }
        total += Number(current);
    }
    return total;
}
exports.simpleSum = simpleSum;
function tensorSum(tensor, axis, ignoreNaN) {
    let tf = (0, tf_singleton_1.getBackend)();
    if (ignoreNaN) {
        return tf.tidy(() => tf.where(tensor.isNaN(), 0, tensor).sum(axis));
    }
    return tensor.sum(axis);
}
exports.tensorSum = tensorSum;
//////////////////////////////////////////////////////////////////////////
// Count Functions
//////////////////////////////////////////////////////////////////////////
function simpleCount(arr, ignoreNaN) {
    if (!ignoreNaN) {
        return arr.length;
    }
    let count = 0;
    for (let i = 0; i < arr.length; i++) {
        const current = arr[i];
        if (isNaN(current)) {
            continue;
        }
        count += 1;
    }
    return count;
}
exports.simpleCount = simpleCount;
function tensorCount(tensor, axis, ignoreNaN) {
    let tf = (0, tf_singleton_1.getBackend)();
    if (ignoreNaN) {
        return tf.tidy(() => tf.logicalNot(tensor.isNaN()).sum(axis));
    }
    // Could definitely do this faster
    return tf.onesLike(tensor).sum(axis);
}
exports.tensorCount = tensorCount;
//////////////////////////////////////////////////////////////////////////
// Mean Functions
//////////////////////////////////////////////////////////////////////////
function simpleMean(arr) {
    let count = simpleCount(arr);
    if (count === 0) {
        return 0;
    }
    let sum = simpleSum(arr);
    return sum / count;
}
exports.simpleMean = simpleMean;
function tensorMean(tensor, axis, ignoreNaN, safe) {
    let tf = (0, tf_singleton_1.getBackend)();
    if (!ignoreNaN) {
        return tensor.mean(axis);
    }
    if (safe) {
        return tf.tidy(() => tensorSum(tensor, axis, ignoreNaN).div(turnZerosToOnes(tensorCount(tensor, axis, ignoreNaN))));
    }
    return tf.tidy(() => tensorSum(tensor, axis, ignoreNaN).div(tensorCount(tensor, axis, ignoreNaN)));
}
exports.tensorMean = tensorMean;
//////////////////////////////////////////////////////////////////////////
// Std Functions
//////////////////////////////////////////////////////////////////////////
function tensorStd(tensor, dim, ignoreNaN) {
    (0, typesUtils_1.assert)(Boolean(ignoreNaN), 'We only need to call this function when ignoreNaN is true');
    let tf = (0, tf_singleton_1.getBackend)();
    return tf.tidy(() => {
        const mean = tensorMean(tensor, dim, ignoreNaN);
        const countNaN = tensorCount(tensor, dim, ignoreNaN);
        const numerator = tensorSum(tensor.sub(mean).square(), dim, ignoreNaN);
        // Choose biased variance over unbiased to match sklearn
        const denominator = turnZerosToOnes(countNaN);
        return numerator.div(denominator).sqrt();
    });
}
exports.tensorStd = tensorStd;
function turnZerosToOnes(tensor) {
    let tf = (0, tf_singleton_1.getBackend)();
    return tf.tidy(() => {
        const zeros = tf.zerosLike(tensor);
        const booleanAddition = tensor.equal(zeros);
        return tensor.add(booleanAddition);
    });
}
exports.turnZerosToOnes = turnZerosToOnes;
