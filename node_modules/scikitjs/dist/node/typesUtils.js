"use strict";
/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.isScikitVecOrMatrix = exports.isScikit2D = exports.isScikit1D = exports.isDataFrameInterface = exports.isSeriesInterface = exports.isTensor = exports.isScikitLike2D = exports.isScikitLike1D = exports.isTypedArray = exports.inferDtype = exports.deepAssertShapeConsistency = exports.inferShape = exports.assert = exports.isNumber = exports.isBoolean = exports.isString = void 0;
const tf_singleton_1 = require("./tf-singleton");
function isString(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.isString = isString;
function isBoolean(value) {
    return typeof value === 'boolean';
}
exports.isBoolean = isBoolean;
function isNumber(value) {
    return typeof value === 'number';
}
exports.isNumber = isNumber;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function inferShape(val, dtype) {
    let firstElem = val;
    if (isTypedArray(val)) {
        return dtype === 'string' ? [] : [val.length];
    }
    if (!Array.isArray(val)) {
        return []; // Scalar.
    }
    const shape = [];
    while (Array.isArray(firstElem) ||
        (isTypedArray(firstElem) && dtype !== 'string')) {
        shape.push(firstElem.length);
        firstElem = firstElem[0];
    }
    if (Array.isArray(val)) {
        deepAssertShapeConsistency(val, shape, []);
    }
    return shape;
}
exports.inferShape = inferShape;
function deepAssertShapeConsistency(val, shape, indices) {
    indices = indices || [];
    if (!Array.isArray(val) && !isTypedArray(val)) {
        assert(shape.length === 0, `Element arr[${indices.join('][')}] is a primitive, ` +
            `but should be an array/TypedArray of ${shape[0]} elements`);
        return;
    }
    assert(shape.length > 0, `Element arr[${indices.join('][')}] should be a primitive, ` +
        `but is an array of ${val.length} elements`);
    assert(val.length === shape[0], `Element arr[${indices.join('][')}] should have ${shape[0]} ` +
        `elements, but has ${val.length} elements`);
    const subShape = shape.slice(1);
    for (let i = 0; i < val.length; ++i) {
        deepAssertShapeConsistency(val[i], subShape, indices.concat(i));
    }
}
exports.deepAssertShapeConsistency = deepAssertShapeConsistency;
function inferDtype(values) {
    if (Array.isArray(values)) {
        return inferDtype(values[0]);
    }
    if (values instanceof Float32Array) {
        return 'float32';
    }
    else if (values instanceof Int32Array || values instanceof Uint8Array) {
        return 'int32';
    }
    else if (isNumber(values)) {
        return 'float32';
    }
    else if (isString(values)) {
        return 'string';
    }
    else if (isBoolean(values)) {
        return 'bool';
    }
    // Failed inference
    return null;
}
exports.inferDtype = inferDtype;
function isTypedArray(a) {
    return (a instanceof Float32Array ||
        a instanceof Int32Array ||
        a instanceof Uint8Array);
}
exports.isTypedArray = isTypedArray;
function isScikitLike1D(arr) {
    const shape = inferShape(arr);
    const dtype = inferDtype(arr);
    return shape.length === 1 && dtype !== null;
}
exports.isScikitLike1D = isScikitLike1D;
function isScikitLike2D(arr) {
    const shape = inferShape(arr);
    const dtype = inferDtype(arr);
    return shape.length === 2 && dtype !== null;
}
exports.isScikitLike2D = isScikitLike2D;
function isTensor(arr) {
    let tf = (0, tf_singleton_1.getBackend)();
    return arr instanceof tf.Tensor;
}
exports.isTensor = isTensor;
function isSeriesInterface(arr) {
    if (typeof arr !== 'object') {
        return false;
    }
    if (arr && arr.iloc && !arr.applyMap) {
        return true;
    }
    return false;
}
exports.isSeriesInterface = isSeriesInterface;
function isDataFrameInterface(arr) {
    if (typeof arr !== 'object') {
        return false;
    }
    if (arr && arr.iloc && arr.applyMap) {
        return true;
    }
    return false;
}
exports.isDataFrameInterface = isDataFrameInterface;
function isScikit1D(arr) {
    if (isSeriesInterface(arr)) {
        return true;
    }
    if (isTensor(arr)) {
        return arr.rank === 1;
    }
    return isScikitLike1D(arr);
}
exports.isScikit1D = isScikit1D;
function isScikit2D(arr) {
    if (isDataFrameInterface(arr)) {
        return true;
    }
    if (isTensor(arr)) {
        return arr.rank === 2;
    }
    return isScikitLike2D(arr);
}
exports.isScikit2D = isScikit2D;
function isScikitVecOrMatrix(arr) {
    return isScikit1D(arr) || isScikit2D(arr);
}
exports.isScikitVecOrMatrix = isScikitVecOrMatrix;
