/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
import { convertToNumericTensor1D, convertToNumericTensor2D } from '../utils';
import { assert, isScikit1D, isScikit2D } from '../typesUtils';
import { median, quantileSeq } from 'mathjs';
import { RegressorMixin } from '../mixins';
import { getBackend } from '../tf-singleton';
/** Builds a regressor with simple rules.
 *
 * @example
 * ```js
 * import { DummyRegressor } from 'scikitjs'
 * const reg = new DummyRegressor({ strategy: 'mean' })

    const X = [
      [-1, 5],
      [-0.5, 5],
      [0, 10]
    ]
    const y = [10, 20, 30] // The mean is 20
    reg.fit(X, y) // This regressor will return 20 for any input
 * ```
 */
export class DummyRegressor extends RegressorMixin {
    strategy;
    constant;
    quantile;
    /** Useful for pipelines and column transformers to have a default name for transforms */
    name = 'DummyRegressor';
    tf;
    constructor({ strategy = 'mean', constant, quantile } = {}) {
        super();
        this.tf = getBackend();
        this.strategy = strategy;
        this.constant = constant;
        this.quantile = quantile;
    }
    fit(X, y) {
        assert(isScikit1D(y), 'y variable can not be converted to a 1D Tensor.');
        assert(['mean', 'median', 'constant', 'quantile'].includes(this.strategy), `Strategy ${this.strategy} not supported. We support 'mean', 'median', 'constant', and 'quantile'`);
        const newY = convertToNumericTensor1D(y);
        if (this.strategy === 'mean') {
            this.constant = newY.mean().dataSync()[0];
            return this;
        }
        if (this.strategy === 'median') {
            this.constant = median(newY.arraySync());
            return this;
        }
        if (this.strategy === 'quantile') {
            assert(typeof this.quantile === 'number' &&
                !isNaN(this.quantile) &&
                isFinite(this.quantile), 'quantile is not set to a number. Please set it to a value between 0 and 1 in the constructor');
            assert(this.quantile < 0 || this.quantile > 1, 'quantile must be set to a value between 0 and 1');
            this.constant = quantileSeq(newY.arraySync(), this.quantile);
            return this;
        }
        // Handles 'constant' case
        return this;
    }
    predict(X) {
        assert(isScikit2D(X), 'Data can not be converted to a 2D matrix.');
        let newData = convertToNumericTensor2D(X);
        let length = newData.shape[0];
        return this.tf.tensor1d(Array(length).fill(this.constant));
    }
}
