/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
import { ArrayType1D, ArrayType2D, DataFrameInterface, Initializers, LossTypes, OptimizerTypes, Scikit1D, Scikit2D, ScikitVecOrMatrix, SeriesInterface, TypedArray, DataType, Tensor2D, Tensor1D, Tensor, TensorLike } from './types';
/**
 * Generates an array of dim (row x column) with inner values set to zero
 * @param row
 * @param column
 */
export declare const zeros: (row: number, column: number) => ArrayType1D | ArrayType2D;
/**
 * Checks if array is 1D
 * @param arr The array
 */
export declare const is1DArray: (arr: ArrayType1D | ArrayType2D) => boolean;
/**
 *
 * @param data Scikit1D One dimensional array of data
 * @returns Tensor1D. If you pass in something that isn't 1D, then it will throw an error.
 * This is the case with 2D Tensors as well. If you really want to reshape them then use tf.reshape
 */
export declare function convertToTensor1D(data: Scikit1D, dtype?: DataType): Tensor1D;
export declare function convertToNumericTensor1D(data: Scikit1D, dtype?: DataType): Tensor1D;
export declare function convertToTensor2D(data: Scikit2D, dtype?: DataType): Tensor2D;
export declare function convertToTensor1D_2D(data: ScikitVecOrMatrix, dtype?: DataType): Tensor1D | Tensor2D;
export declare function convertToNumericTensor2D(data: Scikit2D, dtype?: DataType): Tensor2D;
export declare function convertToNumericTensor1D_2D(data: ScikitVecOrMatrix, dtype?: DataType): Tensor1D | Tensor2D;
export declare function convertToTensor(data: TensorLike | Tensor | DataFrameInterface | SeriesInterface, shape?: number[], dtype?: DataType): Tensor;
/**
 * Check that if two tensor are of same shape
 * @param tensor1
 * @param tensor2
 * @returns
 */
export declare const shapeEqual: (tensor1: Tensor, tensor2: Tensor) => boolean;
/**
 * Check that two tensors are equal to within some additive tolerance.
 * @param tensor1
 * @param tensor2
 * @param
 */
export declare const tensorEqual: (tensor1: Tensor, tensor2: Tensor, tol?: number) => boolean;
export declare const arrayEqual: (array: Array<any> | any, array2: Array<any> | any, tol?: number) => boolean;
export declare function convertScikit2DToArray(data: Scikit2D): any[][] | TypedArray[];
export declare function convertScikit1DToArray(data: Scikit1D): any[] | TypedArray;
export declare function arrayTo2DColumn(array: any[] | TypedArray): any[][];
export declare function getLength(X: Scikit2D | Scikit1D): number;
/**
 * Modified Fisher-Yates algorithm which takes
 * a seed and selects n random numbers from a
 * set of integers going from 0 to size-1
 */
export declare function sampleWithoutReplacement(size: number, n: number, seed?: number): number[];
export declare function optimizer(opt: OptimizerTypes): any;
export declare function getLoss(loss: LossTypes): any;
export declare function initializer(init: Initializers): any;
