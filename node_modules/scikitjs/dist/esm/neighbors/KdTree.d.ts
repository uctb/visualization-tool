/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
import { Neighborhood, NeighborhoodParams } from './Neighborhood';
import { Tensor2D } from '../types';
declare type Vec = {
    [i: number]: number;
    readonly length: number;
    slice(start?: number, end?: number): Vec;
    subarray(start?: number, end?: number): Vec;
};
interface KdMetric {
    distance(u: ArrayLike<number>, v: ArrayLike<number>): number;
    minDistToBBox(pt: ArrayLike<number>, bBox: ArrayLike<number>): number;
}
/**
 * A {@link Neighborhood} implementation using a kd-tree as data structure.
 * Instead of an object-oriented representation, the implementation uses an
 * inorder array-based representation of the tree, similar to binary heaps.
 * The tree is always balanced. It is constructed by recursively spliting
 * up the largest dimension of the axis-aligned bounding box of the remaining
 * set of points.
 */
export declare class KdTree implements Neighborhood {
    _nSamples: number;
    _nFeatures: number;
    _metric: KdMetric;
    /**
     * Coordinates of the points contained in this kdTree, not in the order
     * as they were passed to {@link KdTree.build}.
     */
    _points: Vec[];
    /**
     * Keeps track of the order, in which the points were originally passed
     * to {@link KdTree.build}. The `i+1`-th point in `_points` was originally
     * passed as `_indices[i]+1`-th point to {@link KdTree.build}.
     */
    _indices: Int32Array;
    /**
     * The bounding box of each tree node.
     */
    _bBoxes: Float32Array[];
    /**
     * The (i+1)-th leaf of this tree contains the points
     * `_points[_offsets[i]]` to `_points[_offsets[i+1]-1]`.
     */
    _offsets: Int32Array;
    tf: any;
    constructor(nSamples: number, nFeatures: number, metric: KdMetric, points: Vec[], bBoxes: Float32Array[], offsets: Int32Array, indices: Int32Array);
    /**
     * Asynchronously builds a {@link KdTree}.
     */
    static build({ metric, entries, leafSize }: NeighborhoodParams): Promise<KdTree>;
    kNearest(k: number, queryPoints: Tensor2D): {
        distances: Tensor2D;
        indices: Tensor2D;
    };
}
export {};
