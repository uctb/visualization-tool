/**
*  @license
* Copyright 2021, JsData. All rights reserved.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* ==========================================================================
*/
import { convertToNumericTensor2D, convertToTensor2D } from '../utils';
import { tensorMean } from '../math';
import { median } from 'mathjs';
import { modeFast } from 'simple-statistics';
import { TransformerMixin } from '../mixins';
import { getBackend } from '../tf-singleton';
/*
Next steps:
1. Make SimpleImputer work with strings
*/
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isEmpty(value) {
    return (value === undefined ||
        value === null ||
        (isNaN(value) && typeof value !== 'string'));
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function removeMissingValuesFromArray(arr) {
    const values = arr.filter((val) => {
        return !isEmpty(val);
    });
    return values;
}
export class SimpleImputer extends TransformerMixin {
    missingValues;
    fillValue;
    strategy;
    statistics;
    /** Useful for pipelines and column transformers to have a default name for transforms */
    name = 'SimpleImputer';
    tf;
    constructor({ strategy = 'mean', fillValue = undefined, missingValues = NaN } = {}) {
        super();
        this.tf = getBackend();
        this.missingValues = missingValues;
        this.strategy = strategy;
        this.fillValue = fillValue;
        this.statistics = this.tf.tensor1d([]);
    }
    fit(X) {
        // Fill with value passed into fillValue argument
        if (this.strategy === 'constant') {
            return this;
        }
        if (this.strategy === 'mean') {
            const newTensor = convertToNumericTensor2D(X);
            const mean = tensorMean(newTensor, 0, true);
            this.statistics = mean;
            return this;
        }
        if (this.strategy === 'mostFrequent') {
            const newTensor = convertToNumericTensor2D(X);
            const mostFrequents = newTensor
                .transpose()
                .arraySync()
                .map((arr) => modeFast(removeMissingValuesFromArray(arr)));
            this.statistics = this.tf.tensor1d(mostFrequents);
            return this;
        }
        if (this.strategy === 'median') {
            const newTensor = convertToNumericTensor2D(X);
            const medians = newTensor
                .transpose()
                .arraySync()
                .map((arr) => median(removeMissingValuesFromArray(arr)));
            this.statistics = this.tf.tensor1d(medians);
            return this;
        }
        throw new Error(`Strategy ${this.strategy} is unsupported. Supported strategies are 'mean', 'median', 'mostFrequent', and 'constant'`);
    }
    transform(X) {
        if (this.strategy === 'constant') {
            const newTensor = convertToTensor2D(X);
            if (this.fillValue === undefined) {
                if (newTensor.dtype !== 'string') {
                    return this.tf.where(newTensor.isNaN(), 0, newTensor);
                }
                else {
                    return this.tf.where(newTensor.isNaN(), 'missing_value', newTensor);
                }
            }
            return this.tf.where(newTensor.isNaN(), this.fillValue, newTensor);
        }
        // Not strategy constant
        const newTensor = convertToNumericTensor2D(X);
        return this.tf.where(newTensor.isNaN(), this.statistics.reshape([1, -1]), newTensor);
    }
}
