/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./public/js/SelectDataseets.js":
/*!**************************************!*\
  !*** ./public/js/SelectDataseets.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ctor_Load\": () => (/* binding */ Ctor_Load),\n/* harmony export */   \"SelectDataset\": () => (/* binding */ SelectDataset),\n/* harmony export */   \"app\": () => (/* binding */ app)\n/* harmony export */ });\n/* harmony import */ var _myfun_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./myfun.js */ \"./public/js/myfun.js\");\n\n/*下拉框选择数据集*/\nvar SelectDataset = {\n  el: '#dataset',\n  data: function data() {\n    return {\n      ds_obj_list: []\n    };\n  },\n  methods: {\n    transferdata: function transferdata(selectedid) {\n      var prefix = './data/';\n      var suffix = '_pred.json';\n      if (selectedid >= 0) {\n        console.log('I\\'m In');\n        this.$forceUpdate();\n        // console.log(this.ds_obj_list.id, this.ds_obj_list.name);\n        console.log(this.ds_obj_list);\n        console.log(dataset_name_list);\n        var request = new XMLHttpRequest();\n        request.open(\"get\", prefix + dataset_name_list[selectedid] + suffix);\n        /!*设置请求方法与路径*!/;\n        request.send(null);\n        /!*不发送数据到服务器*!/;\n        request.onload = function () {\n          /!*XHR对象获取到返回信息后执行*!/;\n          if (request.status == 200) {\n            /!*返回状态为200，即为数据获取成功*!/;\n            var json = JSON.parse(request.responseText);\n            console.log('Parse Success!');\n            MAPInd = 0;\n            data = json;\n            _myfun_js__WEBPACK_IMPORTED_MODULE_0__.ClearDataSet();\n            for (var _x in data.Pred) {\n              DatasetList.push(_x);\n            }\n            _myfun_js__WEBPACK_IMPORTED_MODULE_0__.StartDataSet();\n          }\n        };\n      }\n    }\n  }\n};\nvar app = new Vue(SelectDataset);\n\n\n/*按钮选择数据集*/\n/*\nconst ItemplusButton = {\n    emits: ['selectData'],\n    props: ['title', 'datasetid'],\n    template: `<div><li class=\"datasets\">{{title}}</li><li class=\"button\"><el-button circle icon=\"el-icon-circle-check\" size=\"mini\" id=\"item\" @click=\"$emit('select',datasetid)\"></el-button></li></div>`\n}\nconst app = new Vue(SelectDataset)\nVue.component('ib', ItemplusButton)\n*/\n\n/*Load*/\nvar Load = {\n  data: function data() {\n    return {};\n  },\n  methods: {\n    beforeUpload: function beforeUpload(file) {\n      console.log(\"here\");\n      var SelectedFile = file;\n      var reader = new FileReader();\n      reader.readAsText(SelectedFile);\n      reader.onload = function () {\n        var json = JSON.parse(this.result);\n        data = json;\n        MAPInd = 0;\n        ClearDataSet();\n        for (x in data.Pred) {\n          DatasetList.push(x);\n        }\n        StartDataSet();\n      };\n      return false;\n    }\n  }\n};\nvar Ctor_Load = Vue.extend(Load);\nnew Ctor_Load().$mount('#load');\n\n\n// function update_buttons() {\n//     for (let i = 0; i < dataset_list_len; i++) {\n//         console.log('fuck')\n\n//         data_obj_list[i].button = new function (mydata) {\n//             this.methods = {\n//                 test() {\n//                     data = mydata;\n//                     MAPInd = 0;\n\n//                     ClearDataSet();\n//                     for (x in data.Pred) {\n//                         DatasetList.push(x)\n//                     }\n//                     StartDataSet();\n//                 }\n//             }\n//             return this\n//         }(data_obj_list[i].data)\n//         var Cto = Vue.extend(data_obj_list[i].button)\n//         new Cto().$mount('#' + data_obj_list[i].name)\n//     }\n// }\n\n// var NYC = {\n//     methods: {\n//         test() {\n\n//# sourceURL=webpack://visualization-tool-uctb/./public/js/SelectDataseets.js?");

/***/ }),

/***/ "./public/js/SelectModel.js":
/*!**********************************!*\
  !*** ./public/js/SelectModel.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bpp\": () => (/* binding */ bpp)\n/* harmony export */ });\n/* harmony import */ var _myfun__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./myfun */ \"./public/js/myfun.js\");\n/*model*/\n\n/*HM*/\n\nvar SelectModel = {\n  el: '#model',\n  data: function data() {\n    return {\n      model_list: []\n    };\n  },\n  methods: {\n    transferdata: function transferdata(selectedid) {\n      this.$forceUpdate();\n      (0,_myfun__WEBPACK_IMPORTED_MODULE_0__.ChangeMethod)(selectedid);\n    }\n  }\n};\nvar ItemplusButton_model = {\n  emits: ['selectData'],\n  props: ['title', 'modelid'],\n  template: \"<div><li class=\\\"datasets\\\">{{title}}</li><li class=\\\"button\\\"><el-button circle icon=\\\"el-icon-circle-check\\\" size=\\\"mini\\\" id=\\\"item\\\" @click=\\\"$emit('select',modelid)\\\"></el-button></li></div>\"\n};\nvar bpp = new Vue(SelectModel);\nVue.component('ibm', ItemplusButton_model);\n\n\n// var HM = {\n//     data () {\n//         return {\n//             value: true\n//         };\n//     },\n//     methods: {\n//         test() {\n//             var methodid = MethodNameArray.map(item => item).indexOf('HM');\n//             if(methodid < 0 || methodid > (FunctionNum-2) ){\n//                 alert(\"The model does not exist!\")\n//             }\n//             ChangeMethod(methodid);\n//         }\n//     }\n// }\n// var CtorHM = Vue.extend(HM)\n// new CtorHM().$mount('#HM')\n\n//# sourceURL=webpack://visualization-tool-uctb/./public/js/SelectModel.js?");

/***/ }),

/***/ "./public/js/anomaly_detection.js":
/*!****************************************!*\
  !*** ./public/js/anomaly_detection.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"iforest\": () => (/* binding */ iforest)\n/* harmony export */ });\n/* harmony import */ var ml_isolation_forest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ml-isolation-forest */ \"./node_modules/ml-isolation-forest/src/index.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\nvar _require = __webpack_require__(/*! jstat */ \"./node_modules/jstat/dist/jstat.js\"),\n  jStat = _require.jStat;\n// const ss = require('simple-statistics');\n\nfunction normalize(X) {\n  var matrix = X.flat();\n  var min = Math.min.apply(Math, _toConsumableArray(matrix));\n  var max = Math.max.apply(Math, _toConsumableArray(matrix));\n  for (var i = 0; i < X.length; i++) {\n    X[i] = (X[i] - min) / (max - min);\n  }\n  return X;\n}\n\n/**\n * 构建 Isolation Forest 模型\n * @param {Array} data 输入数据集，每行为一个样本，每列为一个特征\n * @param {Number} t 树的数量\n * @param {Number} h 树的最大深度\n * @returns {Object} Isolation Forest 模型\n */\nfunction buildIsolationForest(data, t, h) {\n  var forest = [];\n  for (var i = 0; i < t; i++) {\n    var tree = buildIsolationTree(data, 0, h);\n    forest.push(tree);\n  }\n  return {\n    forest: forest,\n    avgPathLength: getAveragePathLength(data.length)\n  };\n}\n\n/**\n * 构建 Isolation Tree\n * @param {Array} data 输入数据集，每行为一个样本，每列为一个特征\n * @param {Number} curHeight 当前树的深度\n * @param {Number} maxHeight 树的最大深度\n * @returns {Object} Isolation Tree\n */\nfunction buildIsolationTree(data, curHeight, maxHeight) {\n  if (curHeight >= maxHeight || data.length <= 1) {\n    return {\n      type: 'external',\n      size: data.length\n    };\n  }\n  var splitAttr = getRandomAttribute(data[0].length);\n  var splitValue = getRandomValue(data, splitAttr);\n  var leftData = [];\n  var rightData = [];\n  for (var i = 0; i < data.length; i++) {\n    if (data[i][splitAttr] < splitValue) {\n      leftData.push(data[i]);\n    } else {\n      rightData.push(data[i]);\n    }\n  }\n  return {\n    type: 'internal',\n    splitAttr: splitAttr,\n    splitValue: splitValue,\n    leftChild: buildIsolationTree(leftData, curHeight + 1, maxHeight),\n    rightChild: buildIsolationTree(rightData, curHeight + 1, maxHeight)\n  };\n}\n\n/**\n * 获取随机属性\n * @param {Number} n 属性的数量\n * @returns {Number} 随机属性的索引\n */\nfunction getRandomAttribute(n) {\n  return Math.floor(Math.random() * n);\n}\n\n/**\n * 获取随机分割点\n * @param {Array} data 输入数据集，每行为一个样本，每列为一个特征\n * @param {Number} attr 分割属性的索引\n * @returns {Number} 随机分割点的值\n */\nfunction getRandomValue(data, attr) {\n  var min = Number.MAX_VALUE;\n  var max = Number.MIN_VALUE;\n  for (var i = 0; i < data.length; i++) {\n    if (data[i][attr] < min) {\n      min = data[i][attr];\n    }\n    if (data[i][attr] > max) {\n      max = data[i][attr];\n    }\n  }\n  return Math.random() * (max - min) + min;\n}\n\n/**\n * 获取样本的平均路径长度\n * @param {Object} model Isolation Forest 模型\n * @param {Array} sample 输入样本，每列为一个特征\n * @returns {Number} 样本的平均路径长度\n */\nfunction getAveragePathLength(model, sample) {\n  var pathLengths = [];\n  for (var i = 0; i < model.forest.length; i++) {\n    var tree = model.forest[i];\n    var pathLength = 0;\n    var node = tree;\n    while (node.type === 'internal') {\n      if (sample[node.splitAttr] < node.splitValue) {\n        node = node.leftChild;\n      } else {\n        node = node.rightChild;\n      }\n      pathLength++;\n    }\n    pathLength += c(node.size);\n    pathLengths.push(pathLength);\n  }\n  var sum = pathLengths.reduce(function (a, b) {\n    return a + b;\n  }, 0);\n  return Math.pow(2, -sum / (model.forest.length * model.avgPathLength));\n}\n\n/**\n * 计算 c(n)\n * @param {Number} n 样本数\n * @returns {Number} c(n)\n */\nfunction c(n) {\n  if (n > 2) {\n    return 2 * (Math.log(n - 1) + 0.5772156649) - 2 * (n - 1) / n;\n  } else if (n === 2) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\n/**\n * 检测离群值\n * @param {Object} model Isolation Forest 模型\n * @param {Array} data 输入数据集，每行为一个样本，每列为一个特征\n * @param {Number} threshold 阈值，小于该值的样本将被认为是离群值\n * @returns {Array} 离群值的索引\n */\nfunction detectOutliers(model, data, threshold) {\n  var outliers = [];\n  for (var i = 0; i < data.length; i++) {\n    var sample = data[i];\n    var avgPathLength = getAveragePathLength(model, sample);\n    if (avgPathLength < threshold) {\n      outliers.push(i);\n    }\n  }\n  return outliers;\n}\n\n/**\n * 将时间序列划分成窗口，并将每个窗口作为一个样本\n * @param {Array} timeSeries 时间序列数据，每个元素为一个时间点的值\n * @param {Number} windowSize 窗口大小\n * @returns {Array} 样本集，每个样本为一个窗口，每个窗口包含 windowSize 个时间点的值\n */\nfunction splitTimeSeriesToSamples(timeSeries, windowSize) {\n  var samples = [];\n  for (var i = 0; i < timeSeries.length - windowSize + 1; i++) {\n    var sample = timeSeries.slice(i, i + windowSize);\n    samples.push(sample);\n  }\n  return samples;\n}\nfunction iforest() {\n  /*\n  let x_train = diff_normal;\n  let x_test = diff_normal;\n  console.log(\"训练值：\", x_train);\n  let anomalyDetector = new IsolationForest();\n  anomalyDetector.train(x_train);\n  let result = anomalyDetector.predict(x_test);\n  console.log(result);\n  */\n  // data preparation\n\n  // 归一化\n  var diff = Prediction.map(function (item, index) {\n    return Math.abs(item - GroundTruth[index]);\n  });\n  var diff_normal = normalize(diff);\n  console.log(\"after normalize:\", diff_normal);\n\n  // 判断数据是否符合正态分布\n  // // 进行Shapiro-Wilk检验\n  var pvalue = jStat.shapiroWilk(diff_normal);\n  console.log(pvalue); // 输出正态分布检验结果\n  // // 判断p值是否小于0.05，即是否拒绝原假设（数据不服从正态分布）\n  if (pvalue < 0.05) {\n    console.log('数据不服从正态分布');\n  } else {\n    console.log('数据服从正态分布');\n  }\n\n  // 划分时间窗口\n  var windowSize = 10;\n  var samples = splitTimeSeriesToSamples(diff_normal, windowSize);\n  console.log(samples); // 输出样本集，每个样本为一个窗口，每个窗口包含 10 个时间点的值\n  var x_train = samples.slice(0, samples.length / 2);\n  var x_test = samples.slice(samples.length / 2);\n  console.log(\"训练值：\", x_train);\n  console.log(\"测试值：\", x_test);\n  var anomalyDetector = new ml_isolation_forest__WEBPACK_IMPORTED_MODULE_0__.IsolationForest();\n  anomalyDetector.train(x_train);\n  var result = anomalyDetector.predict(x_test);\n  console.log(result);\n}\n\n//# sourceURL=webpack://visualization-tool-uctb/./public/js/anomaly_detection.js?");

/***/ }),

/***/ "./public/js/draw.js":
/*!***************************!*\
  !*** ./public/js/draw.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"drawLine\": () => (/* binding */ drawLine),\n/* harmony export */   \"drawMap\": () => (/* binding */ drawMap)\n/* harmony export */ });\n/* harmony import */ var _anomaly_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./anomaly_detection */ \"./public/js/anomaly_detection.js\");\n/* harmony import */ var _line_final__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./line_final */ \"./public/js/line_final.js\");\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ \"./public/js/map.js\");\n/*draw map, Groundtruth and Prediction, RMSE*/\n\n\n\nfunction drawLine() {\n  /*左下柱状图*/\n  var model_option = _line_final__WEBPACK_IMPORTED_MODULE_1__.createModelAnanlysisOption();\n  _line_final__WEBPACK_IMPORTED_MODULE_1__.drawModelAnalysis(model_option, 'model_analysis');\n  /*右上折线图*/\n  var Initoption = _line_final__WEBPACK_IMPORTED_MODULE_1__.createoption(data, pointID, StartInd, EndInd, MethodID);\n  _line_final__WEBPACK_IMPORTED_MODULE_1__.drawline(Initoption, 'container_line');\n\n  /*metric折线图*/\n  var metric_option = _line_final__WEBPACK_IMPORTED_MODULE_1__.createMetricsoption(MethodID, pointID);\n  _line_final__WEBPACK_IMPORTED_MODULE_1__.drawhistogram(metric_option, 'rmseline2');\n\n  /*异常检测*/\n  (0,_anomaly_detection__WEBPACK_IMPORTED_MODULE_0__.iforest)();\n}\nfunction drawMap() {\n  console.log(\"now_MAPInd：\", MAPInd);\n  if (MAPInd == 0) {\n    if (FilterInvalidNodeFlag == 0) {\n      var InitMapoption = _map__WEBPACK_IMPORTED_MODULE_2__.createMapOption(data, data['Node']['StationInfo'], StationIndArr, pointID);\n      _map__WEBPACK_IMPORTED_MODULE_2__.drawmap(InitMapoption);\n    } else if (FilterInvalidNodeFlag == 1) {\n      var InitMapoption = _map__WEBPACK_IMPORTED_MODULE_2__.createMapOption(data, FilterInvalidNodeInfo, InvalidNodeIndArr, pointID);\n      _map__WEBPACK_IMPORTED_MODULE_2__.drawmap(InitMapoption);\n    }\n  } else if (MAPInd == 1) {\n    // XMBaidu\n    _map__WEBPACK_IMPORTED_MODULE_2__.map();\n  }\n}\n\n//# sourceURL=webpack://visualization-tool-uctb/./public/js/draw.js?");

/***/ }),

/***/ "./public/js/js.js":
/*!*************************!*\
  !*** ./public/js/js.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"./public/js/map.js\");\n/* harmony import */ var _myfun_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./myfun.js */ \"./public/js/myfun.js\");\n/* harmony import */ var _line_final__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line_final */ \"./public/js/line_final.js\");\n/* harmony import */ var _SelectDataseets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SelectDataseets */ \"./public/js/SelectDataseets.js\");\n\n\n\n\n/*读取本地数据集（json文件）存入全局变量*/\n\nfunction read_json() {\n  var url_record = './data/record.json';\n  var prefix = './data/';\n  var suffix = '_pred.json';\n  var request = new XMLHttpRequest();\n  request.open(\"get\", url_record);\n  /!*设置请求方法与路径*!/;\n  request.send(null);\n  /!*不发送数据到服务器*!/;\n  request.onload = function () {\n    /!*XHR对象获取到返回信息后执行*!/;\n    if (request.status == 200) {\n      /!*返回状态为200，即为数据获取成功*!/;\n      record = JSON.parse(request.responseText);\n      console.log(record);\n      dataset_name_list = record;\n      dataset_list_len = dataset_name_list.length;\n      for (var i = 0; i < dataset_list_len; i++) {\n        _SelectDataseets__WEBPACK_IMPORTED_MODULE_3__.app.ds_obj_list.push(new function (name, index) {\n          this.name = name;\n          this.id = index;\n        }(dataset_name_list[i], i));\n      }\n      // for (var i = 0; i < dataset_name_list.length; i++) {\n      //     data_obj_list.push(new function(name){\n      //         this.name = name\n      //         this.data = {}\n      //         this.item ={\n      //             methodlist:null,\n      //             button:null\n      //         }\n      //     }(dataset_name_list[i]));\n      // 默认数据集导入\n      load_default_dataset(prefix, dataset_name_list[0], suffix);\n    }\n  };\n}\nfunction load_default_dataset(prefix, dataset_name, suffix) {\n  var request = new XMLHttpRequest();\n  request.open(\"get\", prefix + dataset_name + suffix);\n  /!*设置请求方法与路径*!/;\n  request.send(null);\n  /!*不发送数据到服务器*!/;\n  request.onload = function () {\n    /!*XHR对象获取到返回信息后执行*!/;\n    if (request.status == 200) {\n      /!*返回状态为200，即为数据获取成功*!/;\n      var json = JSON.parse(request.responseText);\n      console.log('Parse Success!');\n      data = json;\n      console.log(\"data:\", data);\n      MAPInd = 0;\n      for (x in data.Pred) {\n        DatasetList.push(x);\n      }\n      _myfun_js__WEBPACK_IMPORTED_MODULE_1__.StartDataSet();\n    }\n  };\n}\nwindow.onload = function () {\n  read_json();\n\n  /*  var request1 = new XMLHttpRequest();\n    request1.open(\"get\", url_chongqing);/!*设置请求方法与路径*!/\n    request1.send(null);/!*不发送数据到服务器*!/\n    request1.onload = function () {/!*XHR对象获取到返回信息后执行*!/\n        if (request1.status == 200) {/!*返回状态为200，即为数据获取成功*!/\n            Metro_Chongqing = JSON.parse(request1.responseText);\n        }\n    }\n    var request2 = new XMLHttpRequest();\n    request2.open(\"get\", url_xian);/!*设置请求方法与路径*!/\n    request2.send(null);/!*不发送数据到服务器*!/\n    request2.onload = function () {/!*XHR对象获取到返回信息后执行*!/\n        if (request2.status == 200) {/!*返回状态为200，即为数据获取成功*!/\n            DiDi_Xian = JSON.parse(request2.responseText);\n        }\n    }*/\n};\n\n/*highlight button*/\nvar HighlightButton = {\n  methods: {\n    // 是否开启折线图拐点，用颜色区分相对误差\n    Highlight: function Highlight() {\n      if (line_highlight === 0) {\n        line_highlight = 1;\n      } else {\n        line_highlight = 0;\n      }\n\n      /*error折线图*/\n      var Initoption = _line_final__WEBPACK_IMPORTED_MODULE_2__.createoption(data, pointID, StartInd, EndInd, MethodID);\n      _line_final__WEBPACK_IMPORTED_MODULE_2__.drawline(Initoption);\n      var RMSE_option = _line_final__WEBPACK_IMPORTED_MODULE_2__.createMetricsoption(MethodID);\n      _line_final__WEBPACK_IMPORTED_MODULE_2__.drawhistogram(RMSE_option, 'rmseline2');\n    }\n  }\n};\nvar Ctor_highlight = Vue.extend(HighlightButton);\nnew Ctor_highlight().$mount('#highlightbutton');\n\n/*bad case button*/\n/*let badcasebutton = {\n    data() {\n        return {\n            options: [{\n                value: '0',\n                label: 'spatial view'\n            }, {\n                value: '1',\n                label: 'temporal view'\n            }, {\n                value: '2',\n                label: 'value'\n            }],\n            value: ''\n        }\n    },\n    methods: {\n        BadCase() {\n            console.log(typeof(this.value))\n            if (this.value === '0') {\n                // 修改容器名称\n                document.getElementById('line_graph').innerText = 'All Regions Bad Case Amount Rank List';\n\n                // bad case rank histogram\n                let BadCase_option = createBadCaseoption(MethodID, pointID);\n                drawhistogram(BadCase_option, 'container_line');\n            }\n            else if (this.value === '1') {\n                // 修改容器名称\n                document.getElementById('line_graph').innerText = 'Terrible Time';\n\n                // bad case timeslots amount line\n                let option = createTimeBadCaseoption(data, pointID, StartInd, EndInd, MethodID);\n                drawline(option);\n            }\n            else if (this.value === '2') {\n                // 修改容器名称\n                document.getElementById('line_graph').innerText = 'Groundtruth and Prediction (point 0)';\n\n                // prediction and groundtruth\n                let Initoption = createoption(data, pointID, StartInd, EndInd, MethodID);\n                drawline(Initoption);\n            }\n\n        }\n    }\n}\nlet Ctor_badcasebutton = Vue.extend(badcasebutton)\nnew Ctor_badcasebutton().$mount('#badcasebutton')*/\n\n/*Metrics Distribution button*/\nvar MetricsDistributionButton = {\n  data: function data() {\n    return {\n      options: [{\n        value: '0',\n        label: 'RMSE Distribution'\n      }, {\n        value: '1',\n        label: 'MAE Distribution'\n      }, {\n        value: '2',\n        label: 'MAPE Distribution'\n      }, {\n        value: '3',\n        label: 'Metrics Rank List'\n      }, {\n        value: '4',\n        label: 'spatial view'\n      }, {\n        value: '5',\n        label: 'temporal view'\n      }],\n      value: ''\n    };\n  },\n  methods: {\n    MetricsDistribution: function MetricsDistribution() {\n      if (this.value === '0') {\n        // 修改容器名称\n        document.getElementById('rmse2').innerText = 'RMSE Distribution';\n\n        // rmse distribution histogram\n        var option = _line_final__WEBPACK_IMPORTED_MODULE_2__.createRMSEDistributionoption(MethodID, PointRMSERange);\n        _line_final__WEBPACK_IMPORTED_MODULE_2__.drawhistogram(option, 'rmseline2');\n      } else if (this.value === '1') {\n        metricflag = 2;\n        // 修改容器名称\n        document.getElementById('rmse2').innerText = 'MAE Distribution';\n\n        // mae distribution histogram\n        var _option = _line_final__WEBPACK_IMPORTED_MODULE_2__.createRMSEDistributionoption(MethodID, PointMAERange);\n        _line_final__WEBPACK_IMPORTED_MODULE_2__.drawhistogram(_option, 'rmseline2');\n      } else if (this.value === '2') {\n        // 修改容器名称\n        document.getElementById('rmse2').innerText = 'MAPE Distribution';\n\n        // mape distribution histogram\n        var _option2 = _line_final__WEBPACK_IMPORTED_MODULE_2__.createRMSEDistributionoption(MethodID, PointMAPERange);\n        _line_final__WEBPACK_IMPORTED_MODULE_2__.drawhistogram(_option2, 'rmseline2');\n      } else if (this.value === '3') {\n        // 修改容器名称\n        document.getElementById('rmse2').innerText = 'Metrics Rank List';\n\n        // Metrics Rank List\n        var metric_option = _line_final__WEBPACK_IMPORTED_MODULE_2__.createMetricsoption(MethodID, pointID);\n        _line_final__WEBPACK_IMPORTED_MODULE_2__.drawhistogram(metric_option, 'rmseline2');\n      } else if (this.value === '4') {\n        // 修改容器名称\n        document.getElementById('rmse2').innerText = 'All Regions Bad Case Amount Rank List';\n\n        // bad case rank histogram\n        var BadCase_option = _line_final__WEBPACK_IMPORTED_MODULE_2__.createBadCaseoption(MethodID, pointID);\n        _line_final__WEBPACK_IMPORTED_MODULE_2__.drawhistogram(BadCase_option, 'rmseline2');\n      } else if (this.value === '5') {\n        // 修改容器名称\n        document.getElementById('rmse2').innerText = 'Terrible Time';\n\n        // bad case timeslots amount line\n        var _option3 = _line_final__WEBPACK_IMPORTED_MODULE_2__.createTimeBadCaseoption(data, pointID, StartInd, EndInd, MethodID);\n        _line_final__WEBPACK_IMPORTED_MODULE_2__.drawline(_option3, 'rmseline2');\n      }\n    }\n  }\n};\nvar Ctor_metric = Vue.extend(MetricsDistributionButton);\nnew Ctor_metric().$mount('#MetricsDistributionButton');\n\n/*过滤无效点*/\nvar InvalidSwitch = {\n  data: function data() {\n    return {\n      value: false\n    };\n  },\n  methods: {\n    // 由于原本的metric就是去除了无效点后计算的，因此无需重新绘制各类分析图，仅需修改地图上绘制的点\n    FilterInvalidPoint: function FilterInvalidPoint($event) {\n      console.log($event);\n      if ($event == 1) {\n        console.log(\"打开过滤无效点开关！\");\n        FilterInvalidNodeFlag = 1;\n        // 重新绘制地图\n        RemovePointOfStationInfo();\n        var InitMapoption = _map_js__WEBPACK_IMPORTED_MODULE_0__.createMapOption(data, FilterInvalidNodeInfo, InvalidNodeIndArr, pointID);\n        _map_js__WEBPACK_IMPORTED_MODULE_0__.drawmap(InitMapoption);\n      } else if ($event == 0) {\n        console.log(\"关闭过滤无效点开关！\");\n        FilterInvalidNodeFlag = 0;\n        var _InitMapoption = _map_js__WEBPACK_IMPORTED_MODULE_0__.createMapOption(data, data['Node']['StationInfo'], StationIndArr, pointID);\n        _map_js__WEBPACK_IMPORTED_MODULE_0__.drawmap(_InitMapoption);\n      }\n    }\n  }\n};\nvar Ctor_filter = Vue.extend(InvalidSwitch);\nnew Ctor_filter().$mount('#InvalidSwitch');\n\n//# sourceURL=webpack://visualization-tool-uctb/./public/js/js.js?");

/***/ }),

/***/ "./public/js/line_final.js":
/*!*********************************!*\
  !*** ./public/js/line_final.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createBadCaseoption\": () => (/* binding */ createBadCaseoption),\n/* harmony export */   \"createMetricsoption\": () => (/* binding */ createMetricsoption),\n/* harmony export */   \"createModelAnanlysisOption\": () => (/* binding */ createModelAnanlysisOption),\n/* harmony export */   \"createRMSEDistributionoption\": () => (/* binding */ createRMSEDistributionoption),\n/* harmony export */   \"createTimeBadCaseoption\": () => (/* binding */ createTimeBadCaseoption),\n/* harmony export */   \"createoption\": () => (/* binding */ createoption),\n/* harmony export */   \"drawModelAnalysis\": () => (/* binding */ drawModelAnalysis),\n/* harmony export */   \"drawhistogram\": () => (/* binding */ drawhistogram),\n/* harmony export */   \"drawline\": () => (/* binding */ drawline)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"./public/js/map.js\");\n\n/*create option*/\n\n/*左下：Model Analysis*/\nfunction createModelAnanlysisOption() {\n  console.log(\"=======model analysis==========\");\n  var childdatasetid = [];\n  for (var i = 0; i < DatasetList.length; i++) {\n    childdatasetid.push(\"dataset\" + i);\n  }\n  var model_metrics = new Array(); // 同一个模型i在不同子数据集j下的metrics\n  for (var _i = 0; _i < MethodNameArray.length; _i++) {\n    // 同一个模型\n    model_metrics[MethodNameArray[_i]] = [];\n    for (var j = 0; j < DatasetList.length; j++) {\n      // 不同数据子集\n      if (MethodNameArray[_i] in ModelMetrics[DatasetList[j]]) {\n        model_metrics[MethodNameArray[_i]].push(Number(ModelMetrics[DatasetList[j]][MethodNameArray[_i]]['rmse']));\n      } else {\n        model_metrics[MethodNameArray[_i]].push(0);\n      }\n    }\n  }\n  console.log(\"model metrics data:\", model_metrics);\n  var option = {\n    tooltip: {\n      trigger: 'axis',\n      axisPointer: {\n        type: 'shadow'\n      }\n    },\n    legend: {\n      top: 20,\n      data: MethodNameArray,\n      textStyle: {\n        color: '#fff'\n      }\n    },\n    grid: {\n      top: 120,\n      left: 70\n    },\n    toolbox: {\n      show: true,\n      feature: {\n        saveAsImage: {}\n      }\n    },\n    xAxis: {\n      type: 'value',\n      name: 'Days',\n      axisLabel: {\n        show: false\n      },\n      axisLine: {\n        show: false\n      },\n      splitLine: {\n        show: false\n      },\n      axisTick: {\n        show: false\n      }\n    },\n    yAxis: {\n      type: 'category',\n      data: childdatasetid,\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    series: function () {\n      var Myseries = new Array();\n      for (var _i2 = 0; _i2 < MethodNameArray.length; _i2++) {\n        var item = {\n          name: MethodNameArray[_i2],\n          type: 'bar',\n          label: {\n            show: true\n          },\n          data: model_metrics[MethodNameArray[_i2]],\n          barWidthL: 10\n        };\n        console.log(\"item data:\", model_metrics[MethodNameArray[_i2]]);\n        Myseries.push(item);\n      }\n      console.log(\"Myseries:\", Myseries);\n      return Myseries;\n    }()\n  };\n  return option;\n}\n\n/*右上*/\nfunction createoption(obj, SelectedNodeID) {\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var endIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n  var methodid = arguments.length > 4 ? arguments[4] : undefined;\n  var DatasetName = DatasetList[DatasetID];\n  var tmp = obj['Pred'][DatasetName];\n  var TimeNum = tmp['GroundTruth'].length;\n\n  // 默认datazoom位置\n  if (startIndex > TimeNum | endIndex > TimeNum | startIndex < -1 | endIndex < -1) {\n    window.alert(\"Error 02: out of range!\");\n    startIndex = -1;\n    endIndex = -1;\n  }\n  if (startIndex == -1) startIndex = Math.floor(TimeNum * 0.2);\n  if (endIndex == -1) endIndex = TimeNum - 1;\n  if (startIndex > endIndex) {\n    window.alert(\"Error 01: wrong time selected\");\n    startIndex = -1;\n    endIndex = -1;\n  }\n\n  // ydata：这个数据点各个时间的真实值 获得真实值数组\n  var RealNodeID = -1; // 记录这个节点对应在traffic_data_index里的位置，-1代表没这个玩意\n  var methodName = MethodNameArray[methodid];\n  console.log(\"now_methodName:\", methodName);\n  RealNodeID = tmp[methodName]['traffic_data_index'].indexOf(SelectedNodeID);\n  var ydata = new Array();\n  for (var i = 0; i < TimeNum; i++) {\n    ydata[i] = tmp['GroundTruth'][i][RealNodeID];\n  }\n  GroundTruth = Object.values(ydata);\n  console.log(\"GroundTruth:\", GroundTruth);\n\n  // pred_data: 预测值\n  var pred_data = new Array();\n  // 如果存在这个点,把预测值填入predata数组（采用尾端对齐）\n  if (RealNodeID != -1) {\n    // 遍历所有时间点\n    for (var k = 0; k < tmp[methodName]['TrafficNode'].length; k++) {\n      // 真实值和预测值的时间长度不等，预测的段应该是尾端对齐\n      var index = tmp[methodName]['TrafficNode'].length - k - 1;\n      pred_data[TimeNum - 1 - k] = tmp[methodName]['TrafficNode'][index][RealNodeID];\n    }\n  }\n  Prediction = Object.values(pred_data);\n  console.log(\"Prediction:\", Prediction);\n\n  // mark_area\n  var mark_area = markArea[methodid][RealNodeID];\n  console.log(\"mark_area is\", mark_area);\n  var color_list = ['#2f4554', '#61a0a8', '#FF8C00', '#20B2AA', '#ffc20e', '#4169E1', '#afb4db', '#c4ccd3'];\n  var j = 0;\n\n  /* 注：这里有个问题\n      因为拿到的数据集特殊，都是0.1划分，所以程序是按0.1写的\n      但实际上不一定是0.1，所以Pred里头数据集才附带了真实值。\n      现在并没有使用这个真实值，但可能会有问题。\n  */\n\n  // 指定图表的配置项和数据\n  var option = {\n    legend: {\n      orient: 'horizontal',\n      left: '2%',\n      top: '5%',\n      textStyle: {\n        color: '#fff'\n      }\n    },\n    tooltip: {\n      trigger: 'axis',\n      axisPointer: {\n        type: 'cross'\n      },\n      formatter: function formatter(params, ticket, callback) {\n        var result = params[0].axisValue + '<br/>';\n        result += '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + params[0].color + '\"></span>' + params[0].seriesName + ' : ' + params[0].data.toFixed(2) + '<br/>';\n        for (var _i3 = 1; _i3 < params.length; _i3++) {\n          /* 结果 */\n          result += '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + params[_i3].color + '\"></span>' + params[_i3].seriesName + ' : ' + params[_i3].data.toFixed(2) + '<br/>';\n\n          /* 相对误差 */\n          result += '&nbsp&nbsp&nbsp&nbsp' + '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:6px;width:5px;height:5px;background-color:' + params[_i3].color + '\"></span>' + 'RE: ';\n          var relative_error = Math.abs((params[_i3].data - params[0].data) / params[0].data);\n          if (params[0].data == 0) {\n            if (params[1].data == 0) {\n              var error_rate = 0;\n            }\n            result += (relative_error * 100).toFixed(2) + '&nbsp;';\n          } else {\n            result += (relative_error * 100).toFixed(2) + '%&nbsp;';\n          }\n\n          /* 绝对误差 */\n          result += '&nbsp&nbsp&nbsp' + '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:6px;width:5px;height:5px;background-color:' + params[_i3].color + '\"></span>' + 'AE: ';\n          var absolute_error = Math.abs(params[_i3].data - params[0].data);\n          result += absolute_error.toFixed(2) + '<br/>';\n\n          /* 判断结果 */\n          result += '&nbsp&nbsp&nbsp&nbsp' + '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:6px;width:5px;height:5px;background-color:' + params[_i3].color + '\"></span>';\n          if (relative_error <= MAXError) {\n            if (absolute_error <= MAXABSError) {\n              result += 'Result: ' + '√' + '<br/>';\n            } else {\n              // 暂时还是没有想到太合适的方法把AE纳入评价依据，暂时不用\n              // result += 'Result: ' + '× (AE)' + '<br/>';\n              result += 'Result: ' + '√' + '<br/>';\n            }\n          } else if (absolute_error <= MAXABSError) {\n            result += 'Result: ' + '× (RE)' + '<br/>';\n          } else {\n            result += 'Result: ' + '× (Both)' + '<br/>';\n          }\n        }\n        return [result];\n      },\n      position: function position(pt) {\n        return [pt[0], '10%'];\n      }\n    },\n    color: ['#2f4554', '#61a0a8', '#d48265', '#bda29a', '#6e7074', '#87CEFA', '#546570', '#c4ccd3'],\n    axisPointer: {\n      label: {\n        backgroundColor: '#1177',\n        precision: 2\n      }\n    },\n    xAxis: {\n      type: 'category',\n      data: TimeSlots,\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    yAxis: {\n      type: 'value',\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    series: function () {\n      var Myseries = new Array();\n      var item1 = {\n        name: \"Ground Truth\",\n        data: ydata,\n        type: 'line',\n        symbol: 'triangle',\n        symbolSize: 8,\n        itemStyle: {\n          borderColor: \"#111AAA\",\n          color: '#fff',\n          shadowColor: 'rgba(0, 0, 0, 0.5)',\n          shadowBlur: 10\n        },\n        lineStyle: {\n          width: 3\n        },\n        markArea: {\n          slient: true,\n          itemStyle: {\n            color: '#f8aba6',\n            opacity: 0.3\n          },\n          data: mark_area\n        }\n      };\n      Myseries.push(item1);\n      var item2 = {\n        name: methodName,\n        data: pred_data,\n        type: 'line',\n        color: color_list[j + 2],\n        symbol: function symbol(number, params) {\n          var index = params.dataIndex;\n          var re = Math.abs(number - ydata[index]) / ydata[index];\n          if (ydata[index] == 0) {\n            return 'emptyCircle';\n          }\n          if (line_highlight == 1) {\n            if (re <= MAXError) {\n              return 'image://./images/greendot2.png';\n            } else {\n              return 'image://./images/reddot.png';\n            }\n          } else {\n            return 'emptyCircle';\n          }\n        },\n        //showSymbol : false,\n        showAllSymbol: true,\n        symbolSize: function symbolSize(number, params) {\n          var index = params.dataIndex;\n          var re = Math.abs(number - ydata[index]) / ydata[index];\n          if (ydata[index] == 0) {\n            return 2;\n          }\n          if (line_highlight == 1) {\n            if (re <= MAXError) {\n              return 8;\n            } else {\n              return 8;\n            }\n          } else {\n            return 4;\n          }\n        }\n      };\n      Myseries.push(item2);\n      return Myseries;\n    }(),\n    dataZoom: [{\n      type: 'slider',\n      show: true,\n      xAxisIndex: 0,\n      //filterMode: 'empty',   //这句话加上的话，不会随着数据改变轴\n      startValue: TimeSlots[startIndex],\n      endValue: TimeSlots[endIndex],\n      handleIcon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',\n      handleSize: '60%',\n      height: 20,\n      handleStyle: {\n        color: '#fff',\n        shadowBlur: 3,\n        shadowColor: 'rgba(0, 0, 0, 0.6)',\n        shadowOffsetX: 2,\n        shadowOffsetY: 2\n      }\n    }, {\n      type: 'inside',\n      show: true,\n      xAxisIndex: 0,\n      startValue: TimeSlots[startIndex],\n      endValue: TimeSlots[endIndex]\n    }, {\n      type: 'slider',\n      yAxisIndex: 0,\n      handleIcon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',\n      handleSize: '80%',\n      width: 20,\n      handleStyle: {\n        color: '#fff',\n        shadowBlur: 3,\n        shadowColor: 'rgba(0, 0, 0, 0.6)',\n        shadowOffsetX: 2,\n        shadowOffsetY: 2\n      }\n    }]\n  };\n  // 使用刚指定的配置项和数据显示图表。\n\n  return option;\n}\n\n/*右下*/\n\nfunction createBadCaseoption(methodid) {\n  var xdata = new Array();\n  var ydata = new Array();\n  var BadCaseNum = PointSortedBadCaseNum[methodid];\n  for (var i = 0; i < BadCaseNum.length; i++) {\n    var dict = BadCaseNum[i];\n    // 获得x轴数据\n    xdata.push(dict['index']);\n    // 获得y轴数据\n    ydata.push(dict['BadCaseNum']);\n  }\n  var option = {\n    legend: {\n      left: '7%',\n      textStyle: {\n        color: '#fff'\n      }\n    },\n    xAxis: {\n      type: 'category',\n      data: xdata,\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    yAxis: {\n      type: 'value',\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    tooltip: {\n      show: true,\n      trigger: 'axis'\n    },\n    series: {\n      data: ydata,\n      type: 'bar',\n      name: 'Bad Case Num',\n      itemStyle: {\n        normal: {\n          color: '#d48265'\n        }\n      }\n    },\n    dataZoom: [{\n      type: 'slider',\n      show: true,\n      xAxisIndex: 0,\n      //filterMode: 'empty',   //这句话加上的话，不会随着数据改变轴\n      startValue: 0,\n      endValue: 30,\n      handleIcon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',\n      handleSize: '80%',\n      height: 20,\n      handleStyle: {\n        color: '#fff',\n        shadowBlur: 3,\n        shadowColor: 'rgba(0, 0, 0, 0.6)',\n        shadowOffsetX: 2,\n        shadowOffsetY: 2\n      }\n    }, {\n      type: 'inside',\n      show: true,\n      xAxisIndex: 0\n    }, {\n      type: 'slider',\n      yAxisIndex: 0,\n      handleIcon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',\n      handleSize: '80%',\n      width: 20,\n      handleStyle: {\n        color: '#fff',\n        shadowBlur: 3,\n        shadowColor: 'rgba(0, 0, 0, 0.6)',\n        shadowOffsetX: 2,\n        shadowOffsetY: 2\n      }\n    }]\n  };\n  return option;\n}\nfunction createTimeBadCaseoption(obj, SelectedNodeID) {\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var endIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n  var methodid = arguments.length > 4 ? arguments[4] : undefined;\n  var DatasetName = DatasetList[DatasetID];\n  var tmp = obj['Pred'][DatasetName];\n  var TimeNum = tmp['GroundTruth'].length;\n\n  // 默认datazoom位置\n\n  if (startIndex > TimeNum | endIndex > TimeNum | startIndex < -1 | endIndex < -1) {\n    window.alert(\"Error 02: out of range!\");\n    startIndex = -1;\n    endIndex = -1;\n  }\n  if (startIndex == -1) startIndex = Math.floor(TimeNum * 0.2);\n  if (endIndex == -1) endIndex = TimeNum - 1;\n  if (startIndex > endIndex) {\n    window.alert(\"Error 01: wrong time selected\");\n    startIndex = -1;\n    endIndex = -1;\n  }\n\n  // 求ydata\n  var time_bad_case_dict = PointTimeBadCase[methodid];\n  var ydata = [];\n  for (var i = 0; i < TimeArrayLength; i++) {\n    ydata.push(time_bad_case_dict[TimeSlots[i]]);\n  }\n\n  // 指定图表的配置项和数据\n  var option = {\n    legend: {\n      orient: 'horizontal',\n      left: '2%',\n      top: '2%',\n      textStyle: {\n        color: '#fff'\n      }\n    },\n    tooltip: {\n      trigger: 'axis',\n      axisPointer: {\n        type: 'cross'\n      },\n      formatter: function formatter(params, ticket, callback) {\n        var result = params[0].axisValue + '<br/>';\n        result += '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + params[0].color + '\"></span>' + params[0].seriesName + ' : ' + params[0].data.toFixed(2) + '<br/>';\n        for (var _i4 = 1; _i4 < params.length; _i4++) {\n          /* 结果 */\n          result += '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:10px;width:9px;height:9px;background-color:' + params[_i4].color + '\"></span>' + params[_i4].seriesName + ' : ' + params[_i4].data.toFixed(2) + '<br/>';\n\n          /* 相对误差 */\n          result += '&nbsp&nbsp&nbsp&nbsp' + '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:6px;width:5px;height:5px;background-color:' + params[_i4].color + '\"></span>' + 'RE: ';\n          var relative_error = Math.abs((params[_i4].data - params[0].data) / params[0].data);\n          if (params[0].data == 0) {\n            if (params[1].data == 0) {\n              var error_rate = 0;\n            }\n            result += (relative_error * 100).toFixed(2) + '&nbsp;';\n          } else {\n            result += (relative_error * 100).toFixed(2) + '%&nbsp;';\n          }\n\n          /* 绝对误差 */\n          result += '&nbsp&nbsp&nbsp' + '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:6px;width:5px;height:5px;background-color:' + params[_i4].color + '\"></span>' + 'AE: ';\n          var absolute_error = Math.abs(params[_i4].data - params[0].data);\n          result += absolute_error.toFixed(2) + '<br/>';\n\n          /* 判断结果 */\n          result += '&nbsp&nbsp&nbsp&nbsp' + '<span style=\"display:inline-block;position:relative; top:-3px;margin-right:5px;border-radius:6px;width:5px;height:5px;background-color:' + params[_i4].color + '\"></span>';\n          if (relative_error <= MAXError) {\n            if (absolute_error <= MAXABSError) {\n              result += 'Result: ' + '√' + '<br/>';\n            } else {\n              // 暂时还是没有想到太合适的方法把AE纳入评价依据，暂时不用\n              // result += 'Result: ' + '× (AE)' + '<br/>';\n              result += 'Result: ' + '√' + '<br/>';\n            }\n          } else if (absolute_error <= MAXABSError) {\n            result += 'Result: ' + '× (RE)' + '<br/>';\n          } else {\n            result += 'Result: ' + '× (Both)' + '<br/>';\n          }\n        }\n        return [result];\n      },\n      position: function position(pt) {\n        return [pt[0], '10%'];\n      }\n    },\n    axisPointer: {\n      label: {\n        backgroundColor: '#1177',\n        precision: 2\n      }\n    },\n    xAxis: {\n      type: 'category',\n      data: TimeSlots,\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    yAxis: {\n      type: 'value',\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    series: {\n      // name: \"Bad Case Region Num\",\n      // data: ydata,\n      // type: 'bar',\n      // symbol:'triangle',\n      // symbolSize: 8,\n      // itemStyle: {\n      //     borderColor: \"#111AAA\",\n      //     color: '#FFE4C4',\n      //     shadowColor: 'rgba(0, 0, 0, 0.5)',\n      //     shadowBlur: 10\n      // },\n      // lineStyle: {\n      //     width : 3\n      // },\n      data: ydata,\n      type: 'bar',\n      name: 'Bad Case Region Num',\n      itemStyle: {\n        normal: {\n          color: '#d48265'\n        }\n      }\n    },\n    dataZoom: [{\n      type: 'slider',\n      show: true,\n      xAxisIndex: 0,\n      //filterMode: 'empty',   //这句话加上的话，不会随着数据改变轴\n      startValue: TimeSlots[startIndex],\n      endValue: TimeSlots[endIndex],\n      handleIcon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',\n      handleSize: '80%',\n      height: 20,\n      handleStyle: {\n        color: '#fff',\n        shadowBlur: 3,\n        shadowColor: 'rgba(0, 0, 0, 0.6)',\n        shadowOffsetX: 2,\n        shadowOffsetY: 2\n      }\n    }, {\n      type: 'inside',\n      show: true,\n      xAxisIndex: 0,\n      startValue: TimeSlots[startIndex],\n      endValue: TimeSlots[endIndex]\n    }, {\n      type: 'slider',\n      yAxisIndex: 0,\n      handleIcon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',\n      handleSize: '80%',\n      width: 20,\n      handleStyle: {\n        color: '#fff',\n        shadowBlur: 3,\n        shadowColor: 'rgba(0, 0, 0, 0.6)',\n        shadowOffsetX: 2,\n        shadowOffsetY: 2\n      }\n    }]\n  };\n  // 使用刚指定的配置项和数据显示图表。\n\n  return option;\n}\nfunction createMetricsoption(methodid, pointid) {\n  var xdata = new Array();\n  var rmse_data = new Array();\n  var mae_data = new Array();\n  var mape_data = new Array();\n  for (var i = 0; i < PointSortedRMSE[methodid].length; i++) {\n    var dict = PointSortedRMSE[methodid][i];\n    // 获得x轴数据\n    xdata.push(dict['index']);\n    rmse_data.push(dict['rmse']);\n  }\n  for (var _i5 = 0; _i5 < PointSortedMAE[methodid].length; _i5++) {\n    var _dict = PointSortedMAE[methodid][_i5];\n    mae_data.push(_dict['mae']);\n  }\n  for (var _i6 = 0; _i6 < PointSortedMAPE[methodid].length; _i6++) {\n    var _dict2 = PointSortedMAPE[methodid][_i6];\n    mape_data.push(_dict2['mape']);\n  }\n  var option = {\n    legend: {\n      left: '2%',\n      top: '5%',\n      textStyle: {\n        color: '#fff'\n      }\n    },\n    xAxis: {\n      type: 'category',\n      data: xdata,\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    yAxis: {\n      type: 'value',\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    tooltip: {\n      show: true,\n      trigger: 'axis'\n    },\n    series: function () {\n      var Myseries = new Array();\n      var item_rmse = {\n        name: 'RMSE',\n        type: 'bar',\n        itemStyle: {\n          normal: {\n            color: '#FFB6C1'\n          }\n        },\n        data: function () {\n          var MyData = new Array();\n          if (line_highlight != 1) {\n            for (var _i7 = 0; _i7 < rmse_data.length; _i7++) {\n              if (_i7 != pointid) {\n                MyData.push(rmse_data[_i7]);\n              } else {\n                var item = {\n                  value: rmse_data[_i7],\n                  itemStyle: {\n                    color: '#FFD700'\n                  }\n                };\n                MyData.push(item);\n              }\n            }\n          } else {\n            for (var _i8 = 0; _i8 < rmse_data.length; _i8++) {\n              if (rmse_data[_i8] < MINACCURACY) {\n                MyData.push(rmse_data[_i8]);\n              } else {\n                var _item = {\n                  value: rmse_data[_i8],\n                  itemStyle: {\n                    color: '#DC143C'\n                  }\n                };\n                MyData.push(_item);\n              }\n            }\n          }\n          return MyData;\n        }()\n      };\n      Myseries.push(item_rmse);\n      var item_mae = {\n        name: 'MAE',\n        type: 'bar',\n        itemStyle: {\n          normal: {\n            color: '#FFA07A'\n          }\n        },\n        data: function () {\n          var MyData = new Array();\n          if (line_highlight != 1) {\n            for (var _i9 = 0; _i9 < mae_data.length; _i9++) {\n              if (_i9 != pointid) {\n                MyData.push(mae_data[_i9]);\n              } else {\n                var item = {\n                  value: mae_data[_i9],\n                  itemStyle: {\n                    color: '#FFD700'\n                  }\n                };\n                MyData.push(item);\n              }\n            }\n          } else {\n            for (var _i10 = 0; _i10 < mae_data.length; _i10++) {\n              if (mae_data[_i10] < MINACCURACY) {\n                MyData.push(mae_data[_i10]);\n              } else {\n                var _item2 = {\n                  value: mae_data[_i10],\n                  itemStyle: {\n                    color: '#DC143C'\n                  }\n                };\n                MyData.push(_item2);\n              }\n            }\n          }\n          return MyData;\n        }()\n      };\n      Myseries.push(item_mae);\n      var item_mape = {\n        name: 'MAPE',\n        type: 'bar',\n        itemStyle: {\n          normal: {\n            color: '#FF8C00'\n          }\n        },\n        data: function () {\n          var MyData = new Array();\n          if (line_highlight != 1) {\n            for (var _i11 = 0; _i11 < mape_data.length; _i11++) {\n              if (_i11 != pointid) {\n                MyData.push(mape_data[_i11]);\n              } else {\n                var item = {\n                  value: mape_data[_i11],\n                  itemStyle: {\n                    color: '#FFD700'\n                  }\n                };\n                MyData.push(item);\n              }\n            }\n          } else {\n            for (var _i12 = 0; _i12 < mape_data.length; _i12++) {\n              if (mape_data[_i12] < MINACCURACY) {\n                MyData.push(mape_data[_i12]);\n              } else {\n                var _item3 = {\n                  value: mape_data[_i12],\n                  itemStyle: {\n                    color: '#DC143C'\n                  }\n                };\n                MyData.push(_item3);\n              }\n            }\n          }\n          return MyData;\n        }()\n      };\n      Myseries.push(item_mape);\n      return Myseries;\n    }(),\n    dataZoom: [{\n      type: 'slider',\n      show: true,\n      xAxisIndex: 0,\n      //filterMode: 'empty',   //这句话加上的话，不会随着数据改变轴\n      startValue: 0,\n      endValue: 30,\n      handleIcon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',\n      handleSize: '80%',\n      height: 20,\n      handleStyle: {\n        color: '#fff',\n        shadowBlur: 3,\n        shadowColor: 'rgba(0, 0, 0, 0.6)',\n        shadowOffsetX: 2,\n        shadowOffsetY: 2\n      }\n    }, {\n      type: 'inside',\n      show: true,\n      xAxisIndex: 0\n    }, {\n      type: 'slider',\n      yAxisIndex: 0,\n      handleIcon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4v1.3h1.3v-1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7V23h6.6V24.4z M13.3,19.6H6.7v-1.4h6.6V19.6z',\n      handleSize: '80%',\n      width: 20,\n      handleStyle: {\n        color: '#fff',\n        shadowBlur: 3,\n        shadowColor: 'rgba(0, 0, 0, 0.6)',\n        shadowOffsetX: 2,\n        shadowOffsetY: 2\n      }\n    }]\n  };\n  return option;\n}\nfunction createRMSEDistributionoption(methodid, pointMetricRange) {\n  var x_data = pointMetricRange[methodid]['interval_name'];\n  var y_data = [];\n  for (var i = 0; i < interval_num; i++) {\n    y_data.push(pointMetricRange[methodid][i]);\n  }\n  var option = {\n    legend: {\n      left: '2%',\n      top: '5%',\n      textStyle: {\n        color: '#fff'\n      }\n    },\n    xAxis: {\n      type: 'category',\n      data: x_data,\n      axisLabel: {\n        color: '#fff',\n        interval: 0,\n        rotate: 45\n      }\n    },\n    yAxis: {\n      type: 'value',\n      axisLabel: {\n        color: '#fff'\n      }\n    },\n    tooltip: {\n      show: true,\n      trigger: 'axis'\n    },\n    series: {\n      name: 'point amount',\n      type: 'bar',\n      itemStyle: {\n        normal: {\n          color: '#FFB6C1'\n        }\n      },\n      data: y_data\n    },\n    dataZoom: {\n      type: 'slider',\n      show: true,\n      start: 0,\n      end: 70,\n      height: 20,\n      handleStyle: {\n        color: '#fff',\n        shadowBlur: 3,\n        shadowColor: 'rgba(0, 0, 0, 0.6)',\n        shadowOffsetX: 2,\n        shadowOffsetY: 2\n      }\n    }\n  };\n  return option;\n}\n\n/*draw*/\nfunction drawline(option, id) {\n  var myChart = echarts.init(document.getElementById(id));\n  myChart.clear();\n  myChart.setOption(option);\n  myChart.on('datazoom', function (params) {\n    var startValue = myChart.getOption().dataZoom[1].startValue;\n    var endValue = myChart.getOption().dataZoom[1].endValue;\n    var Gap = 1000 * 60 * now_Timefitness;\n    var Origin_endDate = TimeRange[2];\n    var now = new Date(Origin_endDate - Gap * (TimeArrayLength - startValue));\n    var nowend = new Date(Origin_endDate - Gap * (TimeArrayLength - endValue));\n    var start_year = now.getFullYear().toString();\n    var start_month = (now.getMonth() + 1).toString();\n    var start_day = now.getDate().toString();\n    var start_hour = now.getHours().toString();\n    var start_minute = now.getMinutes().toString();\n    if (now.getMonth() + 1 < 10) {\n      start_month = '0' + start_month;\n    }\n    if (now.getDate() < 10) {\n      start_day = '0' + start_day;\n    }\n    if (now.getHours() < 10) {\n      start_hour = '0' + start_hour;\n    }\n    if (now.getMinutes() < 10) {\n      start_minute = '0' + start_minute;\n    }\n    var now_time = start_year + '-' + start_month + '-' + start_day + 'T' + start_hour + ':' + start_minute + ':00';\n    document.getElementById('starttime').value = now_time;\n    var end_year = nowend.getFullYear().toString();\n    var end_month = (nowend.getMonth() + 1).toString();\n    var end_day = nowend.getDate().toString();\n    var end_hour = nowend.getHours().toString();\n    var end_minute = nowend.getMinutes().toString();\n    if (nowend.getMonth() + 1 < 10) {\n      end_month = '0' + end_month;\n    }\n    if (nowend.getDate() < 10) {\n      end_day = '0' + end_day;\n    }\n    if (nowend.getHours() < 10) {\n      end_hour = '0' + end_hour;\n    }\n    if (nowend.getMinutes() < 10) {\n      end_minute = '0' + end_minute;\n    }\n    var nowend_time = end_year + '-' + end_month + '-' + end_day + 'T' + end_hour + ':' + end_minute + ':00';\n    document.getElementById('endtime').value = nowend_time;\n    StartInd = startValue;\n    EndInd = endValue;\n  });\n}\nfunction drawhistogram(option, id) {\n  var myChart = echarts.init(document.getElementById(id));\n  myChart.clear();\n  myChart.setOption(option);\n  window.addEventListener(\"resize\", function () {\n    myChart.resize();\n  });\n  myChart.on('click', function (params) {\n    pointID = params.name;\n    console.log(\"====test=====\");\n    console.log(\"test id:\", params.name);\n\n    /*作图*/\n    pointName = data['Node']['StationInfo'][pointID][4];\n    // document.getElementById('points').value = pointID;\n    document.getElementById('uv_name').innerText = pointName;\n    document.getElementById('line_graph').innerText = 'Groundtruth and Prediction (' + pointName + ')';\n    var Initoption = createoption(data, Number(pointID), StartInd, EndInd, MethodID);\n    drawline(Initoption, 'container_line');\n\n    /*在地图上标记出该点*/\n    if (FilterInvalidNodeFlag == 0) {\n      // 过滤无效点开关关闭\n      var InitMapoption = _map_js__WEBPACK_IMPORTED_MODULE_0__.createMapOption(data, data['Node']['StationInfo'], StationIndArr, pointID);\n      _map_js__WEBPACK_IMPORTED_MODULE_0__.drawmap(InitMapoption);\n    } else if (FilterInvalidNodeFlag == 1) {\n      // 过滤无效点开关打开\n      var _InitMapoption = _map_js__WEBPACK_IMPORTED_MODULE_0__.createMapOption(data, FilterInvalidNodeInfo, InvalidNodeIndArr, pointID);\n      _map_js__WEBPACK_IMPORTED_MODULE_0__.drawmap(_InitMapoption);\n    }\n  });\n}\nfunction drawModelAnalysis(option, id) {\n  var myChart = echarts.init(document.getElementById(id));\n  myChart.clear();\n  myChart.setOption(option);\n  window.addEventListener(\"resize\", function () {\n    myChart.resize();\n  });\n}\n\n//# sourceURL=webpack://visualization-tool-uctb/./public/js/line_final.js?");

/***/ }),

/***/ "./public/js/map.js":
/*!**************************!*\
  !*** ./public/js/map.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createMapOption\": () => (/* binding */ createMapOption),\n/* harmony export */   \"drawmap\": () => (/* binding */ drawmap),\n/* harmony export */   \"map\": () => (/* binding */ map)\n/* harmony export */ });\n/* harmony import */ var _line_final_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line_final.js */ \"./public/js/line_final.js\");\n/* harmony import */ var _myfun__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./myfun */ \"./public/js/myfun.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n\nfunction drawmap(option) {\n  var dom = document.getElementById(\"map_1\");\n  var myChart = echarts.init(dom);\n  if (option && _typeof(option) === \"object\") {\n    myChart.setOption(option, true);\n  }\n  myChart.on('click', function (params) {\n    console.log(\"test params:\", params);\n    pointID = params.dataIndex;\n    pointName = params.value[3];\n    // document.getElementById('points').value = pointID;\n    document.getElementById('uv_name').innerText = pointName;\n    document.getElementById('line_graph').innerText = 'Groundtruth and Prediction (' + pointName + ')';\n\n    // drawmap(option);\n    if (FilterInvalidNodeFlag == 0) {\n      // 过滤无效点开关关闭\n      var InitMapoption = createMapOption(data, data['Node']['StationInfo'], StationIndArr, pointID);\n      drawmap(InitMapoption);\n    } else if (FilterInvalidNodeFlag == 1) {\n      // 过滤无效点开关打开\n      var _InitMapoption = createMapOption(data, FilterInvalidNodeInfo, InvalidNodeIndArr, pointID);\n      drawmap(_InitMapoption);\n    }\n\n    /*右上折线图*/\n    var Newoption = _line_final_js__WEBPACK_IMPORTED_MODULE_0__.createoption(data, pointID, StartInd, EndInd, MethodID);\n    _line_final_js__WEBPACK_IMPORTED_MODULE_0__.drawline(Newoption, 'container_line');\n\n    /*error折线图*/\n    // RMSE_option = createMetricsoption(MethodID,pointID);\n    // drawhistogram(RMSE_option);\n  });\n}\n\nfunction createMapOption(obj, StationInfo, StationIndArr) {\n  var centerID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n  var mapsize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : myMapSize;\n  var option = null;\n  console.log(\"=======plot new map!!==========\");\n\n  // 站点的数量\n  var NodeNum = StationInfo.length;\n\n  // 生成站点名称：坐标数据对\n  var resData = [];\n  var totallongitude = 0;\n  var totallatitude = 0;\n  for (var i = 0; i < NodeNum; i++) {\n    if (typeof StationInfo[i][3] == \"string\") {\n      totallongitude += parseFloat(StationInfo[i][3]);\n      totallatitude += parseFloat(StationInfo[i][2]);\n      resData.push({\n        name: StationInfo[i][0],\n        value: [parseFloat(StationInfo[i][3]), parseFloat(StationInfo[i][2]), StationIndArr[i], StationInfo[i][4]]\n      });\n    } else {\n      totallongitude += StationInfo[i][3];\n      totallatitude += StationInfo[i][2];\n      resData.push({\n        name: StationInfo[i][0],\n        // name属性是stationinfo的第一位（编号）\n        value: [StationInfo[i][3], StationInfo[i][2], StationIndArr[i], StationInfo[i][4]] // value 包含坐标，和地点名称\n      });\n    }\n  }\n\n  console.log(\"resData:\", resData);\n  console.log(\"totallongitude/NodeNum\", totallongitude / NodeNum);\n  console.log(totallatitude / NodeNum);\n  option = {\n    tooltip: {\n      trigger: 'item',\n      formatter: function formatter(params) {\n        var res = \"Point Node(first dimension of StationInfo): \" + params.name + '<br/>';\n        res += \"Coordinates: [\" + params.data.value[0] + ', ' + params.data.value[1] + '] </br>';\n        res += \"NodeName: \" + params.data.value[3] + '<br/>';\n        res += \"NodeID in dataset: \" + params.data.value[2] + '<br/>';\n        return [res];\n      }\n    },\n    bmap: {\n      center: [totallongitude / NodeNum, totallatitude / NodeNum],\n      zoom: mapsize,\n      roam: true,\n      mapStyle: {\n        styleJson: [{\n          'featureType': 'water',\n          'elementType': 'all',\n          'stylers': {\n            'color': '#d1d1d1'\n          }\n        }, {\n          'featureType': 'land',\n          'elementType': 'all',\n          'stylers': {\n            'color': '#f3f3f3'\n          }\n        }, {\n          'featureType': 'railway',\n          'elementType': 'all',\n          'stylers': {\n            'visibility': 'off'\n          }\n        }, {\n          'featureType': 'highway',\n          'elementType': 'all',\n          'stylers': {\n            'color': '#fdfdfd'\n          }\n        }, {\n          'featureType': 'highway',\n          'elementType': 'labels',\n          'stylers': {\n            'visibility': 'off'\n          }\n        }, {\n          'featureType': 'arterial',\n          'elementType': 'geometry',\n          'stylers': {\n            'color': '#fefefe'\n          }\n        }, {\n          'featureType': 'arterial',\n          'elementType': 'geometry.fill',\n          'stylers': {\n            'color': '#fefefe'\n          }\n        }, {\n          'featureType': 'poi',\n          'elementType': 'all',\n          'stylers': {\n            'visibility': 'off'\n          }\n        }, {\n          'featureType': 'green',\n          'elementType': 'all',\n          'stylers': {\n            'visibility': 'off'\n          }\n        }, {\n          'featureType': 'subway',\n          'elementType': 'all',\n          'stylers': {\n            'visibility': 'off'\n          }\n        }, {\n          'featureType': 'manmade',\n          'elementType': 'all',\n          'stylers': {\n            'color': '#d1d1d1'\n          }\n        }, {\n          'featureType': 'local',\n          'elementType': 'all',\n          'stylers': {\n            'color': '#d1d1d1'\n          }\n        }, {\n          'featureType': 'arterial',\n          'elementType': 'labels',\n          'stylers': {\n            'visibility': 'off'\n          }\n        }, {\n          'featureType': 'boundary',\n          'elementType': 'all',\n          'stylers': {\n            'color': '#fefefe'\n          }\n        }, {\n          'featureType': 'building',\n          'elementType': 'all',\n          'stylers': {\n            'color': '#d1d1d1'\n          }\n        }, {\n          'featureType': 'label',\n          'elementType': 'labels.text.fill',\n          'stylers': {\n            'color': '#999999'\n          }\n        }]\n      }\n    },\n    series: [{\n      name: 'Points',\n      type: 'scatter',\n      coordinateSystem: 'bmap',\n      data: resData,\n      // symbolSize:10,\n      symbolSize: function symbolSize(number, params) {\n        var id = params.data.value[2];\n        var real_id = _myfun__WEBPACK_IMPORTED_MODULE_1__.FindRealNodeID(id);\n        if (real_id == pointID) {\n          return 20;\n        } else {\n          return 10;\n        }\n      },\n      itemStyle: {\n        color: function color(params) {\n          var id = params.data.value[2];\n          var real_id = _myfun__WEBPACK_IMPORTED_MODULE_1__.FindRealNodeID(id);\n          if (real_id == -1) {\n            return 'black';\n          } else if (real_id == pointID) {\n            return 'yellow';\n          } else if (PointMinRMSE[real_id] >= MINACCURACY && real_id != pointID) {\n            return 'red';\n          } else {\n            return 'green';\n          }\n        }\n      },\n      label: {\n        formatter: '{@[2]}',\n        position: 'right',\n        show: true\n      },\n      emphasis: {\n        label: {\n          show: false\n        }\n      }\n    }]\n  };\n\n  /* 人为修改中心点 */\n  if (centerID >= NodeNum) {\n    window.alert(\"Map error 02 - pointID out of range!\");\n  } else if (centerID != -1) {\n    var Myseries = option.series;\n    var Value = Myseries[0].data[centerID].value;\n    option.bmap.center = [Value[0], Value[1]];\n  }\n\n  /* 人为修改地图点的颜色 */\n\n  return option;\n}\nfunction renderItem(params, api) {\n  // console.log(api.value(2))\n  var coords = polygon[api.value(0)]; //取出每一个区域的id\n  var points = [];\n  for (var i = 0; i < coords.length; i++) {\n    points.push(api.coord(coords[i])); //points数组存放该区域边界的点\n  }\n  // console.log(\"points:\", points)\n  var color = api.visual('color'); //得到视觉映射的样式信息\n\n  return {\n    type: 'polygon',\n    shape: {\n      points: echarts.graphic.clipPointsByRect(points, {\n        x: params.coordSys.x,\n        y: params.coordSys.y,\n        width: params.coordSys.width,\n        height: params.coordSys.height\n      })\n    },\n    style: api.style({\n      fill: color,\n      stroke: echarts.color.lift(color)\n    })\n  };\n}\nfunction map() {\n  // 基于准备好的dom，初始化echarts实例\n  var myChart = echarts.init(document.getElementById('map_1'));\n  var NodeNum = data.Node.StationInfo.length;\n  TotalPointNum = NodeNum;\n  var resData = [];\n  for (var i = 0; i < VaildPointNum; i++) {\n    id = data.Node.StationInfo[i][4];\n    resData.push({\n      name: ConvertNameType[id][0],\n      value: [i, ConvertNameType[id][1], data.Node.StationInfo[i][4]]\n    });\n  }\n  var option = {\n    title: {\n      left: 'center',\n      top: '10px',\n      textStyle: {\n        color: '#fff'\n      }\n    },\n    // tooltip : {\n    //     trigger: 'item',\n    //     formatter: function(params) {\n    //         var res = params.name+'<br/>'+ '总流量:' + params.value[4];\n    //         return res;\n    //     }\n    // },\n    visualMap: {\n      dimension: 1,\n      categories: ['交通站点', '医院', '学校', '城中村', '展馆', '景点', '酒店', '商圈', '寺庙'],\n      right: '3%',\n      bottom: '3%',\n      calculable: true,\n      hoverLink: true,\n      inRange: {\n        color: ['#00FFFF', '#90EE90', '#FFD700', '#D2B48C', '#FF00FF', '#cde6c7', '#f8aba6', '#f58220', '#9b95c9']\n      },\n      textStyle: {\n        color: '#fff'\n      }\n    },\n    bmap: {\n      center: [118.14363, 24.55285],\n      zoom: 12,\n      roam: true,\n      mapStyle: {\n        styleJson: [{\n          \"featureType\": \"water\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"color\": \"#044161\"\n          }\n        }, {\n          \"featureType\": \"land\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"color\": \"#004981\"\n          }\n        }, {\n          \"featureType\": \"boundary\",\n          \"elementType\": \"geometry\",\n          \"stylers\": {\n            \"color\": \"#064f85\"\n          }\n        }, {\n          \"featureType\": \"railway\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"visibility\": \"off\"\n          }\n        }, {\n          \"featureType\": \"highway\",\n          \"elementType\": \"geometry\",\n          \"stylers\": {\n            \"color\": \"#004981\"\n          }\n        }, {\n          \"featureType\": \"highway\",\n          \"elementType\": \"geometry.fill\",\n          \"stylers\": {\n            \"color\": \"#005b96\",\n            \"lightness\": 1\n          }\n        }, {\n          \"featureType\": \"highway\",\n          \"elementType\": \"labels\",\n          \"stylers\": {\n            \"visibility\": \"off\"\n          }\n        }, {\n          \"featureType\": \"arterial\",\n          \"elementType\": \"geometry\",\n          \"stylers\": {\n            \"color\": \"#004981\"\n          }\n        }, {\n          \"featureType\": \"arterial\",\n          \"elementType\": \"geometry.fill\",\n          \"stylers\": {\n            \"color\": \"#00508b\"\n          }\n        }, {\n          \"featureType\": \"poi\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"visibility\": \"off\"\n          }\n        }, {\n          \"featureType\": \"green\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"color\": \"#056197\",\n            \"visibility\": \"off\"\n          }\n        }, {\n          \"featureType\": \"subway\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"visibility\": \"off\"\n          }\n        }, {\n          \"featureType\": \"manmade\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"visibility\": \"off\"\n          }\n        }, {\n          \"featureType\": \"local\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"visibility\": \"off\"\n          }\n        }, {\n          \"featureType\": \"arterial\",\n          \"elementType\": \"labels\",\n          \"stylers\": {\n            \"visibility\": \"off\"\n          }\n        }, {\n          \"featureType\": \"boundary\",\n          \"elementType\": \"geometry.fill\",\n          \"stylers\": {\n            \"color\": \"#029fd4\"\n          }\n        }, {\n          \"featureType\": \"building\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"color\": \"#1a5787\"\n          }\n        }, {\n          \"featureType\": \"label\",\n          \"elementType\": \"all\",\n          \"stylers\": {\n            \"visibility\": \"off\"\n          }\n        }]\n      }\n    },\n    series: [{\n      type: 'custom',\n      coordinateSystem: 'bmap',\n      renderItem: renderItem,\n      data: resData,\n      itemStyle: {\n        normal: {\n          opacity: 1 //图形透明度\n        }\n      },\n\n      animation: false,\n      silent: false\n    }]\n  };\n  myChart.setOption(option);\n  window.addEventListener(\"resize\", function () {\n    myChart.resize();\n  });\n\n  // 处理点击事件\n  myChart.on('click', function (params) {\n    // 修改barbox内容\n    pointID = params.dataIndex;\n    pointName = params.data.name;\n    document.getElementById('points').value = pointID;\n    document.getElementById('uv_name').innerText = pointName;\n    document.getElementById('line_graph').innerText = 'Groundtruth and Prediction (' + pointName + ')';\n\n    /*右上折线图*/\n    var Newoption = _line_final_js__WEBPACK_IMPORTED_MODULE_0__.createoption(data, pointID, StartInd, EndInd, MethodID);\n    _line_final_js__WEBPACK_IMPORTED_MODULE_0__.drawline(Newoption);\n\n    /*error折线图*/\n    var RMSE_option = _line_final_js__WEBPACK_IMPORTED_MODULE_0__.createMetricsoption(MethodID, pointID);\n    _line_final_js__WEBPACK_IMPORTED_MODULE_0__.drawhistogram(RMSE_option);\n  });\n}\n\n//# sourceURL=webpack://visualization-tool-uctb/./public/js/map.js?");

/***/ }),

/***/ "./public/js/myfun.js":
/*!****************************!*\
  !*** ./public/js/myfun.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChangeDataSet\": () => (/* binding */ ChangeDataSet),\n/* harmony export */   \"ChangeFinish\": () => (/* binding */ ChangeFinish),\n/* harmony export */   \"ChangeMethod\": () => (/* binding */ ChangeMethod),\n/* harmony export */   \"ChangeModelError\": () => (/* binding */ ChangeModelError),\n/* harmony export */   \"ClearDataSet\": () => (/* binding */ ClearDataSet),\n/* harmony export */   \"ClearModelList\": () => (/* binding */ ClearModelList),\n/* harmony export */   \"FindMarkArea\": () => (/* binding */ FindMarkArea),\n/* harmony export */   \"FindRealNodeID\": () => (/* binding */ FindRealNodeID),\n/* harmony export */   \"FinishDataSet\": () => (/* binding */ FinishDataSet),\n/* harmony export */   \"FinishMethod\": () => (/* binding */ FinishMethod),\n/* harmony export */   \"FinishPointSelect\": () => (/* binding */ FinishPointSelect),\n/* harmony export */   \"GetModelError\": () => (/* binding */ GetModelError),\n/* harmony export */   \"IsPinYear\": () => (/* binding */ IsPinYear),\n/* harmony export */   \"RemovePointOfStationInfo\": () => (/* binding */ RemovePointOfStationInfo),\n/* harmony export */   \"SetREStandard\": () => (/* binding */ SetREStandard),\n/* harmony export */   \"SetStandard\": () => (/* binding */ SetStandard),\n/* harmony export */   \"StartDataSet\": () => (/* binding */ StartDataSet),\n/* harmony export */   \"add0\": () => (/* binding */ add0),\n/* harmony export */   \"getIntervalID\": () => (/* binding */ getIntervalID),\n/* harmony export */   \"getMetricsDistribution\": () => (/* binding */ getMetricsDistribution),\n/* harmony export */   \"getMetricsRange\": () => (/* binding */ getMetricsRange),\n/* harmony export */   \"getMetricsRankList\": () => (/* binding */ getMetricsRankList),\n/* harmony export */   \"getPointTimeBadCase\": () => (/* binding */ getPointTimeBadCase),\n/* harmony export */   \"getRelativeError\": () => (/* binding */ getRelativeError),\n/* harmony export */   \"getSortedBadCaseNum\": () => (/* binding */ getSortedBadCaseNum),\n/* harmony export */   \"getTimeSlots\": () => (/* binding */ getTimeSlots),\n/* harmony export */   \"optionsClear\": () => (/* binding */ optionsClear),\n/* harmony export */   \"writeDay\": () => (/* binding */ writeDay)\n/* harmony export */ });\n/* harmony import */ var _draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draw */ \"./public/js/draw.js\");\n/* harmony import */ var _SelectModel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SelectModel */ \"./public/js/SelectModel.js\");\n\n\n\n/* 初次选定数据集时执行：先清空，再赋值 */\nfunction ClearDataSet() {\n  DatasetList.splice(0, DatasetList.length);\n  document.getElementById('Dataset').options.length = 0;\n  DatasetID = 0;\n  ClearModelList();\n}\nfunction ClearModelList() {\n  _SelectModel__WEBPACK_IMPORTED_MODULE_1__.bpp.model_list.splice(0, _SelectModel__WEBPACK_IMPORTED_MODULE_1__.bpp.model_list.length);\n}\nfunction StartDataSet() {\n  /*增加子数据集作为options*/\n  var i = 0;\n  for (x in DatasetList) {\n    var dataset_information_list = DatasetList[x].split('_');\n    var closeness = dataset_information_list[3];\n    var period = dataset_information_list[4];\n    var trend = dataset_information_list[5];\n    var OptionName = 'closeness=' + closeness + ' period=' + period + ' trend=' + trend;\n    document.getElementById('Dataset').options.add(new Option(OptionName, i++));\n  }\n  FinishDataSet();\n}\n\n/* 该函数在选定数据集时执行（无论是刚读入文件，还是手动修改数据集，都会执行） */\nfunction FinishDataSet() {\n  console.log(\"==========new dataset!=============\");\n  /* 将StartIndex，EndIndex归零 */\n  StartInd = -1;\n  EndInd = -1;\n\n  /* 将过滤开关都关闭 */\n  FilterInvalidNodeFlag = 0;\n\n  /* 确定数据集以后，先读出其中的方法数 */\n  console.log(\"now_data:\", data);\n  console.log(\"now_DatasetList:\", DatasetList);\n  console.log(\"now_DatasetID:\", DatasetID);\n  console.log(\"now_DatasetName:\", DatasetList[DatasetID]);\n  FunctionNum = Object.getOwnPropertyNames(data['Pred'][DatasetList[DatasetID]]).length;\n\n  /* 修改数据集后，让地图点的选择先归0 */\n  pointID = 0;\n  // document.getElementById('points').value = pointID;\n\n  /* 读取Dataset的名称里的信息，把各项分开以后处理 */\n  var dataset_name = DatasetList[DatasetID];\n  var dataset_information_list = dataset_name.split('_');\n\n  /* 获得该数据集中有效节点个数，以及相应的时间节点数 */\n  var tmp = data.Pred[dataset_name];\n  var TimeNum = tmp.GroundTruth.length; // 真实值包括了多少个时间点。\n  VaildPointNum = tmp.GroundTruth[0].length;\n  TimeArrayLength = TimeNum; // 标记当前选择的数据集中，每个数据点，其对应的时间节点有多少个\n  TotalPointNum = data['Node']['StationInfo'].length;\n  StationIndArr = [];\n  for (var i = 0; i < TotalPointNum; i++) {\n    StationIndArr.push(i);\n  }\n  console.log(\"now_ValidPointNum:\", VaildPointNum);\n  console.log(\"now_TimeArrayLength:\", TimeArrayLength);\n  console.log(\"now_StationIndArr:\", StationIndArr);\n\n  /* 读取出数据集使用部分的参数，若不是all的话，进行截取 */\n  if (dataset_information_list[0] != 'all') {\n    portion_index = parseFloat(dataset_information_list[1]);\n  }\n\n  /* 读取最后一个参数，判断是节点型还是网格型(网格型暂时不处理) */\n  datatype_index = dataset_information_list[7];\n  if (datatype_index == 'G') {\n    windows.alert(\"Grid Data is not available now.\");\n    return;\n  }\n\n  /* 读取小数据集的时间粒度和时间范围 */\n  now_Timefitness = parseInt(dataset_information_list[6]);\n\n  /*获得所有方法的数组*/\n  var k = 0;\n  var Mydata = data.Pred[dataset_name];\n  for (var method in Mydata) {\n    if (method == \"GroundTruth\") continue;else {\n      MethodNameArray[k] = method;\n      _SelectModel__WEBPACK_IMPORTED_MODULE_1__.bpp.model_list.push(new function (name, index) {\n        this.name = name;\n        this.id = index;\n      }(method, k));\n      k++;\n    }\n  }\n  console.log(\"methodNameArray:\", MethodNameArray);\n\n  /* 修改模型误差值 */\n  GetModelError();\n  ChangeModelError();\n\n  /* 获取Date类型的TimeRange，第三个元素为TimeRange的后一天 这部分好像没用了？*/\n  var origin_begin = data.TimeRange[0];\n  var origin_end = data.TimeRange[1];\n  var origin_beginyear = Number(origin_begin.substring(0, 4));\n  var origin_beginmonth = Number(origin_begin.substring(5, 7));\n  var origin_beginday = Number(origin_begin.substring(8, 10));\n  var origin_endyear = Number(origin_end.substring(0, 4));\n  var origin_endmonth = Number(origin_end.substring(5, 7));\n  var origin_endday = Number(origin_end.substring(8, 10));\n  var Origin_beginDate = new Date(origin_beginyear, origin_beginmonth - 1, origin_beginday);\n  var Origin_endDate = new Date(origin_endyear, origin_endmonth - 1, origin_endday);\n  var EndDate = new Date(origin_endyear, origin_endmonth - 1, origin_endday + 1);\n  TimeRange = [];\n  TimeRange.push(Origin_beginDate);\n  TimeRange.push(Origin_endDate);\n  TimeRange.push(EndDate);\n  console.log(\"Time Range is\", TimeRange);\n\n  /*获得一些全局变量*/\n  getTimeSlots();\n  getMetricsRankList();\n  getRelativeError();\n  FindMarkArea(2);\n  getSortedBadCaseNum();\n  getPointTimeBadCase();\n  getMetricsDistribution();\n\n  /*修改右上日期控件的起止时间*/\n  document.getElementById(\"starttime\").value = TimeSlots[0];\n  document.getElementById(\"endtime\").value = TimeSlots[TimeArrayLength - 1];\n\n  /* 处理完成，作图 */\n  (0,_draw__WEBPACK_IMPORTED_MODULE_0__.drawMap)();\n  (0,_draw__WEBPACK_IMPORTED_MODULE_0__.drawLine)();\n}\nfunction ChangeDataSet(str) {\n  DatasetID = str;\n  FinishDataSet();\n}\n\n/* 计算模型整体误差 */\nfunction GetModelError() {\n  console.log(\"======Calculate Model Error========\");\n  // i-子数据集 j-模型 k-时间片 m-区域\n  for (var i = 0; i < DatasetList.length; i++) {\n    var datasetName = DatasetList[i];\n    ModelMetrics[datasetName] = {};\n    var groundtruth = data['Pred'][datasetName]['GroundTruth'];\n    for (var methodName in data['Pred'][datasetName]) {\n      if (methodName == \"GroundTruth\") {\n        continue;\n      } else {\n        var prediction = data['Pred'][datasetName][methodName]['TrafficNode'];\n        var total_rmse_variance = 0;\n        var total_absolute_error = 0;\n        var total_mape_variance = 0;\n        var num = 0;\n        for (var k = 0; k < TimeArrayLength; k++) {\n          for (var m = 0; m < VaildPointNum; m++) {\n            // let real_node_id = data['Pred'][datasetName][methodName]['traffic_data_index'][m];\n            total_rmse_variance += Math.pow(Math.abs(prediction[k][m] - groundtruth[k][m]), 2);\n            total_absolute_error += Math.abs(prediction[k][m] - groundtruth[k][m]);\n            // 如果真实值为0，则MAPE为infinity，因此把真实值为0的去掉\n            if (groundtruth[k][m] !== 0) {\n              num++;\n              total_mape_variance += Math.abs((prediction[k][m] - groundtruth[k][m]) / groundtruth[k][m]);\n            }\n          }\n        }\n        var RMSE = Math.sqrt(total_rmse_variance / (TimeArrayLength * VaildPointNum));\n        var MAE = total_absolute_error / (TimeArrayLength * VaildPointNum);\n        var MAPE = total_mape_variance / num * 100;\n        if (isNaN(MAPE)) {\n          MAPE = 'NAN';\n        }\n        console.log(\"rmse, mae, mape is:\", RMSE, MAE, MAPE);\n        ModelMetrics[datasetName][methodName] = {\n          'rmse': RMSE.toFixed(2),\n          'mae': MAE.toFixed(2),\n          'mape': MAPE.toFixed(2)\n        };\n      }\n    }\n  }\n  console.log(\"Model Metrics:\", ModelMetrics);\n}\n\n/* 修改并体现模型误差 */\nfunction ChangeModelError() {\n  console.log(\"======Change Model Error========\");\n  var rmse = ModelMetrics[DatasetList[DatasetID]][MethodNameArray[MethodID]]['rmse'];\n  var mae = ModelMetrics[DatasetList[DatasetID]][MethodNameArray[MethodID]]['mae'];\n  var mape = ModelMetrics[DatasetList[DatasetID]][MethodNameArray[MethodID]]['mape'];\n  // let datasetName = DatasetList[DatasetID];\n  // let methodName = MethodNameArray[MethodID];\n  //\n  // if ('rmse' in data['Pred'][datasetName][methodName]){\n  //     rmse = parseFloat(data['Pred'][datasetName][methodName]['rmse']).toFixed(2)\n  // }\n  // else{\n  //     rmse = 'NaN'\n  // }\n  // if ('mape' in data['Pred'][datasetName][methodName]){\n  //     mape = parseFloat(data['Pred'][datasetName][methodName]['mape']).toFixed(2)\n  // }\n  // else{\n  //     mape = 'NaN'\n  // }\n  // if ('mae' in data['Pred'][datasetName][methodName]){\n  //     mae = parseFloat(data['Pred'][datasetName][methodName]['mae']).toFixed(2)\n  // }\n  // else{\n  //     mae = 'NaN'\n  // }\n  document.getElementById('rmse').innerText = rmse;\n  document.getElementById('mape').innerText = mape;\n  document.getElementById('mae').innerText = mae;\n}\n\n/*获得折线图的时间片*/\nfunction getTimeSlots() {\n  TimeSlots = [];\n  var DatasetName = DatasetList[DatasetID];\n  var TimeNum = data['Pred'][DatasetName]['GroundTruth'].length;\n  var Gap = 1000 * 60 * now_Timefitness; // 将timefitness转化为ms\n  var EndDate = +TimeRange[2];\n  for (var i = TimeNum - 1; i >= 0; i--) {\n    var now = new Date(EndDate - (TimeNum - i) * Gap);\n    // TimeSlots[i] = [now.getFullYear(),now.getMonth()+1,now.getDate()].join('/') +' '+[now.getHours(),now.getMinutes()].join(':');\n    TimeSlots[i] = [now.getFullYear(), add0(now.getMonth() + 1), add0(now.getDate())].join('-') + ' ' + [add0(now.getHours()), add0(now.getMinutes())].join(':');\n  }\n  console.log(\"TimeSlots is:\", TimeSlots);\n}\n\n/*get relative error*/\nfunction getRelativeError() {\n  // 获得每种方法下每个区域（有效点）在各时间点上的相对误差\n\n  var DatasetName = DatasetList[DatasetID];\n  var Mydata = data['Pred'][DatasetName];\n  var k = 0;\n\n  // 对每个方法\n  for (var method in Mydata) {\n    if (method === \"GroundTruth\") continue;else {\n      Point_Timeslots_error[k] = [];\n      // 对每个有效点\n      for (var i = 0; i < VaildPointNum; i++) {\n        var DictVar = {}; // 存放方法k中站点i在不同时间片的relative error\n        // 注意：这里的i不等同于编号，而是对应有效点。这样才能覆盖所有有效点。\n        DictVar['index'] = Mydata[method]['traffic_data_index'][i];\n        DictVar['re'] = [];\n        for (var j = 0; j < TimeArrayLength; j++) {\n          // k - 方法， i - 地图点， j - 时间点\n          var ground_truth = Mydata['GroundTruth'][j][i];\n          var prediction = Mydata[method]['TrafficNode'][j][i];\n          var re = Math.abs(prediction - ground_truth) / ground_truth;\n          DictVar['re'].push(re);\n        }\n        Point_Timeslots_error[k][i] = DictVar;\n      }\n      k++;\n    }\n  }\n  console.log(\"the relative error of each point:\", Point_Timeslots_error);\n}\n\n/*计算mark_area*/\nfunction FindMarkArea() {\n  var std_num = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n  var start_time = '';\n  var end_time = '';\n  console.log(\"find mark area!\");\n\n  //对每个方法\n  for (var index = 0; index < MethodNameArray.length; index++) {\n    markArea[index] = [];\n    global_error_list[index] = [];\n\n    // 对每个有效点\n    for (var i = 0; i < VaildPointNum; i++) {\n      // 对每一个有效点，count从0开始计数\n      var count = 0;\n      markArea[index][i] = [];\n      var error_time_list = Point_Timeslots_error[index][i]; // Point_Timeslots_error[MethodID] shape is [ValidPointNum,TimeArrayLength]\n\n      // 求该区域（有效点）的global error\n      // 将各时间点的相对误差的平均数作为global error（判定标准），后续可以改为更有效的判定方式；并且计算平均值时跳过那些误差为infinity的时间点\n      var error_time_sum = 0;\n      for (var k = 0; k < TimeArrayLength; k++) {\n        var error = error_time_list['re'][k];\n        if (isFinite(error)) {\n          error_time_sum = error_time_sum + error_time_list['re'][k];\n        }\n      }\n      var global_error = error_time_sum / TimeArrayLength;\n      global_error_list[index].push(global_error);\n\n      // 求该区域的mark_Area\n      for (var j = 0; j < TimeArrayLength; j++) {\n        var _error = error_time_list['re'][j];\n        if (_error > global_error || _error === Infinity) {\n          if (count === 0) {\n            count++;\n            start_time = TimeSlots[j];\n            // console.log(\"start time is \", start_time);\n          } else {\n            count++;\n          }\n        } else {\n          if (count >= std_num) {\n            end_time = TimeSlots[j];\n            // console.log(\"end time is \", end_time);\n            count = 0;\n            markArea[index][i].push([{\n              'xAxis': start_time,\n              'itemStyle': {\n                'color': 'red',\n                'opacity': 0.3\n              }\n            }, {\n              'xAxis': end_time\n            }]);\n            // markArea[i].push([{'xAxis': start_time}, {'xAxis': end_time}]);\n          } else if (count > 0 && count < std_num) {\n            count = 0;\n          }\n        }\n      }\n      // 最后一个时间片若满足mark_area也应该加入列表中\n      if (count > std_num) {\n        end_time = TimeSlots[TimeArrayLength - 1];\n        // console.log(\"end time is \", end_time);\n        markArea[index][i].push([{\n          'xAxis': start_time,\n          'itemStyle': {\n            'color': 'yellow',\n            'opacity': 0.3\n          }\n        }, {\n          'xAxis': end_time\n        }]);\n        count = 0;\n      }\n    }\n  }\n  console.log(\"global error list is:\", global_error_list);\n  console.log(\"markArea is:\", markArea);\n}\n\n/*获得降序排列的各区域Bad Case个数*/\nfunction getSortedBadCaseNum() {\n  var PointBadCaseNum = {};\n  for (var k = 0; k < MethodNameArray.length; k++) {\n    PointBadCaseNum[k] = [];\n    for (var j = 0; j < VaildPointNum; j++) {\n      var TmpDict = {};\n      TmpDict['index'] = j;\n      TmpDict['BadCaseNum'] = markArea[k][j].length;\n      PointBadCaseNum[k][j] = TmpDict;\n    }\n    PointSortedBadCaseNum[k] = PointBadCaseNum[k].sort(function (a, b) {\n      return a.BadCaseNum > b.BadCaseNum ? -1 : a.BadCaseNum < b.BadCaseNum ? 1 : 0;\n    });\n  }\n  console.log(\"After sort, PointBadCaseNum:\", PointSortedBadCaseNum);\n}\n\n/*获得各时间片在各区域预测值相对误差大于平均值的个数*/\nfunction getPointTimeBadCase() {\n  /*初始化PointTimeBadCase*/\n  // 对每个方法\n  for (var i = 0; i < MethodNameArray.length; i++) {\n    PointTimeBadCase[i] = {};\n    // 对每个时间片\n    for (var index = 0; index < TimeArrayLength; index++) {\n      var time = TimeSlots[index];\n      PointTimeBadCase[i][time] = 0;\n    }\n  }\n\n  /*求PointTimeBadCase*/\n  // 对每个方法\n  for (var _i = 0; _i < MethodNameArray.length; _i++) {\n    // 对每个区域\n    for (var j = 0; j < VaildPointNum; j++) {\n      var error_list = Point_Timeslots_error[_i][j]['re'];\n      var global_error = global_error_list[_i][j];\n      // 对每个时间片\n      for (var k = 0; k < TimeArrayLength; k++) {\n        var error = error_list[k];\n        var _time = TimeSlots[k];\n        if (error > global_error || error === Infinity) {\n          PointTimeBadCase[_i][_time] = PointTimeBadCase[_i][_time] + 1;\n        }\n      }\n    }\n  }\n  console.log(\"PointTimeBadCase is:\", PointTimeBadCase);\n}\n\n/*获得降序排列的各站点的RMSE,MAE,MAPE*/\nfunction getMetricsRankList() {\n  var DatasetName = DatasetList[DatasetID];\n  var Mydata = data['Pred'][DatasetName];\n  var k = 0;\n  for (var method in Mydata) {\n    if (method === \"GroundTruth\") continue;else {\n      // PointMetrics[k] = [];\n      PointSortedRMSE[k] = [];\n      PointSortedMAE[k] = [];\n      PointSortedMAPE[k] = [];\n      for (var i = 0; i < VaildPointNum; i++) {\n        var DictVar_rmse = {};\n        var DictVar_mae = {};\n        var DictVar_mape = {};\n        // let real_node_id = Mydata[method]['traffic_data_index'][i]; // 注意：这里的i不等同于编号，而是对应有效点。这样才能覆盖所有有效点。\n        var real_node_id = i;\n        var total_rmse_variance = 0;\n        var total_absolute_error = 0;\n        var total_mape_variance = 0;\n        var num = 0;\n        for (var j = 0; j < TimeArrayLength; j++) {\n          // k - 方法， i - 地图点， j - 时间点\n          var ground_truth = Mydata['GroundTruth'][j][real_node_id];\n          total_rmse_variance += Math.pow(Math.abs(Mydata[method]['TrafficNode'][j][real_node_id] - ground_truth), 2);\n          total_absolute_error += Math.abs(Mydata[method]['TrafficNode'][j][real_node_id] - ground_truth);\n          // 如果真实值为0，则MAPE为infinity，因此把真实值为0的去掉\n          if (ground_truth !== 0) {\n            num++;\n            total_mape_variance += Math.abs((Mydata[method]['TrafficNode'][j][real_node_id] - ground_truth) / ground_truth);\n          }\n        }\n\n        // 求RMSE，MAE(平均绝对误差)，MAPE(平均绝对百分比误差)\n        var RMSE = Math.sqrt(total_rmse_variance / TimeArrayLength);\n        var MAE = total_absolute_error / TimeArrayLength;\n        var MAPE = total_mape_variance / num * 100;\n        if (isNaN(MAPE)) {\n          MAPE = 0;\n        }\n\n        // 把每个站点的index和rmse值存入字典\n        DictVar_rmse['index'] = real_node_id;\n        DictVar_rmse['rmse'] = RMSE;\n        DictVar_mae['mae'] = MAE;\n        DictVar_mape['mape'] = MAPE;\n        PointSortedRMSE[k][i] = DictVar_rmse;\n        PointSortedMAE[k][i] = DictVar_mae;\n        PointSortedMAPE[k][i] = DictVar_mape;\n        if (k === 0 || PointMinRMSE[i] >= RMSE)\n          // 第一种方法，就直接存了\n          {\n            PointMinRMSE[i] = RMSE;\n          }\n      }\n\n      // 对RMSE,MAE,MAPE数组降序排列\n      PointSortedRMSE[k].sort(function (a, b) {\n        return a.rmse > b.rmse ? -1 : a.rmse < b.rmse ? 1 : 0;\n      });\n      PointSortedMAE[k].sort(function (a, b) {\n        return a.mae > b.mae ? -1 : a.mae < b.mae ? 1 : 0;\n      });\n      PointSortedMAPE[k].sort(function (a, b) {\n        return a.mape > b.mape ? -1 : a.mape < b.mape ? 1 : 0;\n      });\n      k++;\n    }\n  }\n  console.log(\"=========Sorted Metrics List as follows============\");\n  console.log(\"sorted RMSE:\", PointSortedRMSE);\n  console.log(\"sorted MAE:\", PointSortedMAE);\n  console.log(\"sorted MAPE:\", PointSortedMAPE);\n  console.log(\"===================================================\");\n}\n\n/*获得RMSE、MAE、MAPE分布情况*/\nfunction getMetricsRange(left, interval_num, interval) {\n  var tmp = {};\n  var interval_point = [];\n  var interval_name = [];\n  var right = left + interval;\n  for (var i = 0; i < interval_num; i++) {\n    interval_point.push(left);\n    right = left + interval;\n    var range = left.toFixed(0) + ' ~ ' + right.toFixed(0);\n    interval_name.push(range);\n    tmp[i] = 0;\n    left = right;\n  }\n  interval_point.push(left);\n  tmp['interval_point'] = interval_point;\n  tmp['interval_name'] = interval_name;\n  return tmp;\n}\nfunction getIntervalID(interval_list, interval_num, metric) {\n  if (metric === interval_list[interval_num]) {\n    return interval_num - 1;\n  }\n  for (var i = 1; i < interval_num + 1; i++) {\n    if (metric < interval_list[i] && metric >= interval_list[i - 1]) {\n      return i - 1;\n    }\n  }\n}\nfunction getMetricsDistribution() {\n  // 对每种方法\n  for (var i = 0; i < MethodNameArray.length; i++) {\n    // rmse\n    var max_rmse = PointSortedRMSE[i][0]['rmse'];\n    var min_rmse = PointSortedRMSE[i][VaildPointNum - 1]['rmse'];\n    var interval_rmse = (max_rmse - min_rmse) / interval_num;\n    // mae\n    var max_mae = PointSortedMAE[i][0]['mae'];\n    var min_mae = PointSortedMAE[i][VaildPointNum - 1]['mae'];\n    var interval_mae = (max_mae - min_mae) / interval_num;\n    //mape\n    var max_mape = PointSortedMAPE[i][0]['mape'];\n    var min_mape = PointSortedMAPE[i][VaildPointNum - 1]['mape'];\n    var interval_mape = (max_mape - min_mape) / interval_num;\n    PointRMSERange[i] = getMetricsRange(min_rmse, interval_num, interval_rmse);\n    PointMAERange[i] = getMetricsRange(min_mae, interval_num, interval_mae);\n    PointMAPERange[i] = getMetricsRange(min_mape, interval_num, interval_mape);\n    for (var j = 0; j < VaildPointNum; j++) {\n      var rmse = PointSortedRMSE[i][j]['rmse'];\n      var mae = PointSortedMAE[i][j]['mae'];\n      var mape = PointSortedMAPE[i][j]['mape'];\n      var rmse_id = getIntervalID(PointRMSERange[i]['interval_point'], interval_num, rmse);\n      var mae_id = getIntervalID(PointMAERange[i]['interval_point'], interval_num, mae);\n      var mape_id = getIntervalID(PointMAPERange[i]['interval_point'], interval_num, mape);\n\n      // console.log(\"rmse:\", rmse);\n      // console.log(\"rmse_id:\", rmse_id);\n\n      PointRMSERange[i][rmse_id]++;\n      PointMAERange[i][mae_id]++;\n      PointMAPERange[i][mape_id]++;\n    }\n  }\n  console.log(\"========Point Metrics Range=========\");\n  console.log(\"PointRMSERange:\", PointRMSERange);\n  console.log(\"PointMAERange:\", PointMAERange);\n  console.log(\"PointMAPERange:\", PointMAPERange);\n  console.log(\"====================================\");\n}\nfunction FinishMethod() {\n  /*修改模型误差值*/\n  ChangeModelError();\n\n  /*默认过滤开关都关闭*/\n  FilterInvalidNodeFlag = 0;\n\n  /* 处理完成，作图 */\n  (0,_draw__WEBPACK_IMPORTED_MODULE_0__.drawMap)();\n  (0,_draw__WEBPACK_IMPORTED_MODULE_0__.drawLine)();\n}\nfunction ChangeMethod(str) {\n  MethodID = str;\n  FinishMethod();\n}\nfunction SetStandard() {\n  MINACCURACY = parseFloat(document.getElementById('standard').value);\n  (0,_draw__WEBPACK_IMPORTED_MODULE_0__.drawMap)();\n\n  /*error折线图*/\n  var RMSE_option = createMetricsoption(MethodID, pointID);\n  drawhistogram(RMSE_option, 'rmseline2');\n}\nfunction SetREStandard() {\n  MAXError = parseFloat(document.getElementById('re_standard').value) * 0.01;\n  var Initoption = createoption(data, pointID, StartInd, EndInd);\n  drawline(Initoption, 'container_line');\n}\n\n/* 修改pointID/点击地图上的point时 */\nfunction FinishPointSelect() {\n  pointID = parseInt(document.getElementById('points').value);\n\n  /*作图*/\n  (0,_draw__WEBPACK_IMPORTED_MODULE_0__.drawMap)();\n  (0,_draw__WEBPACK_IMPORTED_MODULE_0__.drawLine)();\n}\n\n/*获得当前point对应的有效ID*/\n/*FinishPointSelect里用到了*/\nfunction FindRealNodeID(point_id) {\n  var index_array = [];\n  for (x in data.Pred[DatasetList[DatasetID]]) {\n    if (x != \"GroundTruth\") {\n      index_array = data.Pred[DatasetList[DatasetID]][x].traffic_data_index;\n      break;\n    }\n  }\n  return index_array.indexOf(point_id);\n}\n\n// 程序：日期栏初始化与手动设置日期（开始日期）\n\n/* 这是给日期区域赋值的程序，读取了文件以后才会调用 */\n\nfunction ChangeFinish() {\n  var start_time = document.getElementById(\"starttime\").value;\n  var end_time = document.getElementById(\"endtime\").value;\n  console.log(\"start_time:\", start_time);\n  var Year = start_time.substr(0, 4);\n  var Month = start_time.substr(5, 2);\n  var Day = start_time.substr(8, 2);\n  var Hour = start_time.substr(11, 2);\n  var Minute = start_time.substr(14, 2);\n  var end_Year = end_time.substr(0, 4);\n  var end_Month = end_time.substr(5, 2);\n  var end_Day = end_time.substr(8, 2);\n  var end_Hour = end_time.substr(11, 2);\n  var end_Minute = end_time.substr(14, 2);\n\n  /* 处理下这个数值 */\n\n  var Gap = 1000 * 60 * now_Timefitness;\n  var Origin_endDate = TimeRange[2];\n  var NowDate = new Date(Year, Month - 1, Day, Hour, Minute);\n  var NowEndDate = new Date(end_Year, end_Month - 1, end_Day, end_Hour, end_Minute);\n  StartInd = TimeArrayLength - (Origin_endDate - NowDate) / Gap;\n  EndInd = TimeArrayLength - (Origin_endDate - NowEndDate) / Gap;\n\n  //在这里，修改起始值。另外一个就是修改结束值。\n  if (StartInd > EndInd && EndInd != -1) window.alert(\"Error 01: Wrong time selected, please choose a correct time!\");else {\n    var ChangeDatazoomOption = createoption(data, pointID, StartInd, EndInd);\n    drawline(ChangeDatazoomOption, 'container_line');\n  }\n}\nfunction writeDay(n)\n//据条件写日期的下拉框\n{\n  var e = document.reg_testdate.DD;\n  optionsClear(e);\n  for (var i = 1; i < n + 1; i++) e.options.add(new Option(\" \" + i + \"D\", i));\n}\nfunction IsPinYear(year)\n//判断是否闰平年\n{\n  return 0 == year % 4 && (year % 100 != 0 || year % 400 == 0);\n}\nfunction optionsClear(e) {\n  e.options.length = 1;\n}\nfunction add0(m) {\n  return m < 10 ? '0' + m : m;\n}\n\n/* 过滤无效点 */\nfunction RemovePointOfStationInfo() {\n  console.log(\"=======Filter Test!!========\");\n  FilterInvalidNodeInfo = [];\n  InvalidNodeIndArr = [];\n  for (var i = 0; i < TotalPointNum; i++) {\n    // let isFilter = 0;\n    // 过滤UCTB中判定为无效点的点\n    var real_id = FindRealNodeID(i);\n    if (real_id != -1) {\n      // isFilter = 1;\n      FilterInvalidNodeInfo.push(data['Node']['StationInfo'][i]);\n      InvalidNodeIndArr.push(i);\n    }\n    // 过滤x%时间片的真实值为零的点\n    // let count = 0;   // 统计groundtruth非零时间片个数\n    // for(let j=0; j<TimeArrayLength; j++){\n    //     let groundtruth = data['Pred'][[DatasetList[DatasetID]]]['GroundTruth'][j][i];\n    //     if(groundtruth != 0){\n    //         count ++;\n    //     }\n    // }\n    // if(count >= InvalidNodeStd*TimeArrayLength){\n    //     isFilter = 1;\n    //     // if(InvalidNodeIndArr.indexOf(i) == -1){\n    //     //     FilterInvalidNodeInfo.push(data['Node']['StationInfo'][i]);\n    //     //     InvalidNodeIndArr.push(i);\n    //     // }\n    // }\n    // if(isFilter == 1){\n    //     FilterInvalidNodeInfo.push(data['Node']['StationInfo'][i]);\n    //     InvalidNodeIndArr.push(i);\n    // }\n  }\n\n  console.log(\"filter node index\", InvalidNodeIndArr);\n  console.log(\"filter node info\", FilterInvalidNodeInfo);\n}\n\n//# sourceURL=webpack://visualization-tool-uctb/./public/js/myfun.js?");

/***/ }),

/***/ "./node_modules/is-any-array/lib-esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/is-any-array/lib-esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"isAnyArray\": () => (/* binding */ isAnyArray)\n/* harmony export */ });\nconst toString = Object.prototype.toString;\n/**\n * Checks if an object is an instance of an Array (array or typed array).\n *\n * @param {any} value - Object to check.\n * @returns {boolean} True if the object is an array.\n */\nfunction isAnyArray(value) {\n    return toString.call(value).endsWith('Array]');\n}\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://visualization-tool-uctb/./node_modules/is-any-array/lib-esm/index.js?");

/***/ }),

/***/ "./node_modules/jstat/dist/jstat.js":
/*!******************************************!*\
  !*** ./node_modules/jstat/dist/jstat.js ***!
  \******************************************/
/***/ (function(module) {

eval("(function (window, factory) {\n    if (true) {\n        module.exports = factory();\n    } else {}\n})(this, function () {\nvar jStat = (function(Math, undefined) {\n\n// For quick reference.\nvar concat = Array.prototype.concat;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n// Calculate correction for IEEE error\n// TODO: This calculation can be improved.\nfunction calcRdx(n, m) {\n  var val = n > m ? n : m;\n  return Math.pow(10,\n                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));\n}\n\n\nvar isArray = Array.isArray || function isArray(arg) {\n  return toString.call(arg) === '[object Array]';\n};\n\n\nfunction isFunction(arg) {\n  return toString.call(arg) === '[object Function]';\n}\n\n\nfunction isNumber(num) {\n  return (typeof num === 'number') ? num - num === 0 : false;\n}\n\n\n// Converts the jStat matrix to vector.\nfunction toVector(arr) {\n  return concat.apply([], arr);\n}\n\n\n// The one and only jStat constructor.\nfunction jStat() {\n  return new jStat._init(arguments);\n}\n\n\n// TODO: Remove after all references in src files have been removed.\njStat.fn = jStat.prototype;\n\n\n// By separating the initializer from the constructor it's easier to handle\n// always returning a new instance whether \"new\" was used or not.\njStat._init = function _init(args) {\n  // If first argument is an array, must be vector or matrix.\n  if (isArray(args[0])) {\n    // Check if matrix.\n    if (isArray(args[0][0])) {\n      // See if a mapping function was also passed.\n      if (isFunction(args[1]))\n        args[0] = jStat.map(args[0], args[1]);\n      // Iterate over each is faster than this.push.apply(this, args[0].\n      for (var i = 0; i < args[0].length; i++)\n        this[i] = args[0][i];\n      this.length = args[0].length;\n\n    // Otherwise must be a vector.\n    } else {\n      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];\n      this.length = 1;\n    }\n\n  // If first argument is number, assume creation of sequence.\n  } else if (isNumber(args[0])) {\n    this[0] = jStat.seq.apply(null, args);\n    this.length = 1;\n\n  // Handle case when jStat object is passed to jStat.\n  } else if (args[0] instanceof jStat) {\n    // Duplicate the object and pass it back.\n    return jStat(args[0].toArray());\n\n  // Unexpected argument value, return empty jStat object.\n  // TODO: This is strange behavior. Shouldn't this throw or some such to let\n  // the user know they had bad arguments?\n  } else {\n    this[0] = [];\n    this.length = 1;\n  }\n\n  return this;\n};\njStat._init.prototype = jStat.prototype;\njStat._init.constructor = jStat;\n\n\n// Utility functions.\n// TODO: for internal use only?\njStat.utils = {\n  calcRdx: calcRdx,\n  isArray: isArray,\n  isFunction: isFunction,\n  isNumber: isNumber,\n  toVector: toVector\n};\n\n\njStat._random_fn = Math.random;\njStat.setRandom = function setRandom(fn) {\n  if (typeof fn !== 'function')\n    throw new TypeError('fn is not a function');\n  jStat._random_fn = fn;\n};\n\n\n// Easily extend the jStat object.\n// TODO: is this seriously necessary?\njStat.extend = function extend(obj) {\n  var i, j;\n\n  if (arguments.length === 1) {\n    for (j in obj)\n      jStat[j] = obj[j];\n    return this;\n  }\n\n  for (i = 1; i < arguments.length; i++) {\n    for (j in arguments[i])\n      obj[j] = arguments[i][j];\n  }\n\n  return obj;\n};\n\n\n// Returns the number of rows in the matrix.\njStat.rows = function rows(arr) {\n  return arr.length || 1;\n};\n\n\n// Returns the number of columns in the matrix.\njStat.cols = function cols(arr) {\n  return arr[0].length || 1;\n};\n\n\n// Returns the dimensions of the object { rows: i, cols: j }\njStat.dimensions = function dimensions(arr) {\n  return {\n    rows: jStat.rows(arr),\n    cols: jStat.cols(arr)\n  };\n};\n\n\n// Returns a specified row as a vector or return a sub matrix by pick some rows\njStat.row = function row(arr, index) {\n  if (isArray(index)) {\n    return index.map(function(i) {\n      return jStat.row(arr, i);\n    })\n  }\n  return arr[index];\n};\n\n\n// return row as array\n// rowa([[1,2],[3,4]],0) -> [1,2]\njStat.rowa = function rowa(arr, i) {\n  return jStat.row(arr, i);\n};\n\n\n// Returns the specified column as a vector or return a sub matrix by pick some\n// columns\njStat.col = function col(arr, index) {\n  if (isArray(index)) {\n    var submat = jStat.arange(arr.length).map(function() {\n      return new Array(index.length);\n    });\n    index.forEach(function(ind, i){\n      jStat.arange(arr.length).forEach(function(j) {\n        submat[j][i] = arr[j][ind];\n      });\n    });\n    return submat;\n  }\n  var column = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++)\n    column[i] = [arr[i][index]];\n  return column;\n};\n\n\n// return column as array\n// cola([[1,2],[3,4]],0) -> [1,3]\njStat.cola = function cola(arr, i) {\n  return jStat.col(arr, i).map(function(a){ return a[0] });\n};\n\n\n// Returns the diagonal of the matrix\njStat.diag = function diag(arr) {\n  var nrow = jStat.rows(arr);\n  var res = new Array(nrow);\n  for (var row = 0; row < nrow; row++)\n    res[row] = [arr[row][row]];\n  return res;\n};\n\n\n// Returns the anti-diagonal of the matrix\njStat.antidiag = function antidiag(arr) {\n  var nrow = jStat.rows(arr) - 1;\n  var res = new Array(nrow);\n  for (var i = 0; nrow >= 0; nrow--, i++)\n    res[i] = [arr[i][nrow]];\n  return res;\n};\n\n// Transpose a matrix or array.\njStat.transpose = function transpose(arr) {\n  var obj = [];\n  var objArr, rows, cols, j, i;\n\n  // Make sure arr is in matrix format.\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  rows = arr.length;\n  cols = arr[0].length;\n\n  for (i = 0; i < cols; i++) {\n    objArr = new Array(rows);\n    for (j = 0; j < rows; j++)\n      objArr[j] = arr[j][i];\n    obj.push(objArr);\n  }\n\n  // If obj is vector, return only single array.\n  return obj.length === 1 ? obj[0] : obj;\n};\n\n\n// Map a function to an array or array of arrays.\n// \"toAlter\" is an internal variable.\njStat.map = function map(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    for (col = 0; col < ncol; col++)\n      res[row][col] = func(arr[row][col], row, col);\n  }\n\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Cumulatively combine the elements of an array or array of arrays using a function.\njStat.cumreduce = function cumreduce(arr, func, toAlter) {\n  var row, nrow, ncol, res, col;\n\n  if (!isArray(arr[0]))\n    arr = [arr];\n\n  nrow = arr.length;\n  ncol = arr[0].length;\n  res = toAlter ? arr : new Array(nrow);\n\n  for (row = 0; row < nrow; row++) {\n    // if the row doesn't exist, create it\n    if (!res[row])\n      res[row] = new Array(ncol);\n    if (ncol > 0)\n      res[row][0] = arr[row][0];\n    for (col = 1; col < ncol; col++)\n      res[row][col] = func(res[row][col-1], arr[row][col]);\n  }\n  return res.length === 1 ? res[0] : res;\n};\n\n\n// Destructively alter an array.\njStat.alter = function alter(arr, func) {\n  return jStat.map(arr, func, true);\n};\n\n\n// Generate a rows x cols matrix according to the supplied function.\njStat.create = function  create(rows, cols, func) {\n  var res = new Array(rows);\n  var i, j;\n\n  if (isFunction(cols)) {\n    func = cols;\n    cols = rows;\n  }\n\n  for (i = 0; i < rows; i++) {\n    res[i] = new Array(cols);\n    for (j = 0; j < cols; j++)\n      res[i][j] = func(i, j);\n  }\n\n  return res;\n};\n\n\nfunction retZero() { return 0; }\n\n\n// Generate a rows x cols matrix of zeros.\njStat.zeros = function zeros(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retZero);\n};\n\n\nfunction retOne() { return 1; }\n\n\n// Generate a rows x cols matrix of ones.\njStat.ones = function ones(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retOne);\n};\n\n\n// Generate a rows x cols matrix of uniformly random numbers.\njStat.rand = function rand(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, jStat._random_fn);\n};\n\n\nfunction retIdent(i, j) { return i === j ? 1 : 0; }\n\n\n// Generate an identity matrix of size row x cols.\njStat.identity = function identity(rows, cols) {\n  if (!isNumber(cols))\n    cols = rows;\n  return jStat.create(rows, cols, retIdent);\n};\n\n\n// Tests whether a matrix is symmetric\njStat.symmetric = function symmetric(arr) {\n  var size = arr.length;\n  var row, col;\n\n  if (arr.length !== arr[0].length)\n    return false;\n\n  for (row = 0; row < size; row++) {\n    for (col = 0; col < size; col++)\n      if (arr[col][row] !== arr[row][col])\n        return false;\n  }\n\n  return true;\n};\n\n\n// Set all values to zero.\njStat.clear = function clear(arr) {\n  return jStat.alter(arr, retZero);\n};\n\n\n// Generate sequence.\njStat.seq = function seq(min, max, length, func) {\n  if (!isFunction(func))\n    func = false;\n\n  var arr = [];\n  var hival = calcRdx(min, max);\n  var step = (max * hival - min * hival) / ((length - 1) * hival);\n  var current = min;\n  var cnt;\n\n  // Current is assigned using a technique to compensate for IEEE error.\n  // TODO: Needs better implementation.\n  for (cnt = 0;\n       current <= max && cnt < length;\n       cnt++, current = (min * hival + step * hival * cnt) / hival) {\n    arr.push((func ? func(current, cnt) : current));\n  }\n\n  return arr;\n};\n\n\n// arange(5) -> [0,1,2,3,4]\n// arange(1,5) -> [1,2,3,4]\n// arange(5,1,-1) -> [5,4,3,2]\njStat.arange = function arange(start, end, step) {\n  var rl = [];\n  var i;\n  step = step || 1;\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n  if (start === end || step === 0) {\n    return [];\n  }\n  if (start < end && step < 0) {\n    return [];\n  }\n  if (start > end && step > 0) {\n    return [];\n  }\n  if (step > 0) {\n    for (i = start; i < end; i += step) {\n      rl.push(i);\n    }\n  } else {\n    for (i = start; i > end; i += step) {\n      rl.push(i);\n    }\n  }\n  return rl;\n};\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// slice(A,{row:{end:2},col:{start:1}}) -> [[2,3],[5,6]]\n// slice(A,1,{start:1}) -> [5,6]\n// as numpy code A[:2,1:]\njStat.slice = (function(){\n  function _slice(list, start, end, step) {\n    // note it's not equal to range.map mode it's a bug\n    var i;\n    var rl = [];\n    var length = list.length;\n    if (start === undefined && end === undefined && step === undefined) {\n      return jStat.copy(list);\n    }\n\n    start = start || 0;\n    end = end || list.length;\n    start = start >= 0 ? start : length + start;\n    end = end >= 0 ? end : length + end;\n    step = step || 1;\n    if (start === end || step === 0) {\n      return [];\n    }\n    if (start < end && step < 0) {\n      return [];\n    }\n    if (start > end && step > 0) {\n      return [];\n    }\n    if (step > 0) {\n      for (i = start; i < end; i += step) {\n        rl.push(list[i]);\n      }\n    } else {\n      for (i = start; i > end;i += step) {\n        rl.push(list[i]);\n      }\n    }\n    return rl;\n  }\n\n  function slice(list, rcSlice) {\n    var colSlice, rowSlice;\n    rcSlice = rcSlice || {};\n    if (isNumber(rcSlice.row)) {\n      if (isNumber(rcSlice.col))\n        return list[rcSlice.row][rcSlice.col];\n      var row = jStat.rowa(list, rcSlice.row);\n      colSlice = rcSlice.col || {};\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    }\n\n    if (isNumber(rcSlice.col)) {\n      var col = jStat.cola(list, rcSlice.col);\n      rowSlice = rcSlice.row || {};\n      return _slice(col, rowSlice.start, rowSlice.end, rowSlice.step);\n    }\n\n    rowSlice = rcSlice.row || {};\n    colSlice = rcSlice.col || {};\n    var rows = _slice(list, rowSlice.start, rowSlice.end, rowSlice.step);\n    return rows.map(function(row) {\n      return _slice(row, colSlice.start, colSlice.end, colSlice.step);\n    });\n  }\n\n  return slice;\n}());\n\n\n// A=[[1,2,3],[4,5,6],[7,8,9]]\n// sliceAssign(A,{row:{start:1},col:{start:1}},[[0,0],[0,0]])\n// A=[[1,2,3],[4,0,0],[7,0,0]]\njStat.sliceAssign = function sliceAssign(A, rcSlice, B) {\n  var nl, ml;\n  if (isNumber(rcSlice.row)) {\n    if (isNumber(rcSlice.col))\n      return A[rcSlice.row][rcSlice.col] = B;\n    rcSlice.col = rcSlice.col || {};\n    rcSlice.col.start = rcSlice.col.start || 0;\n    rcSlice.col.end = rcSlice.col.end || A[0].length;\n    rcSlice.col.step = rcSlice.col.step || 1;\n    nl = jStat.arange(rcSlice.col.start,\n                          Math.min(A.length, rcSlice.col.end),\n                          rcSlice.col.step);\n    var m = rcSlice.row;\n    nl.forEach(function(n, i) {\n      A[m][n] = B[i];\n    });\n    return A;\n  }\n\n  if (isNumber(rcSlice.col)) {\n    rcSlice.row = rcSlice.row || {};\n    rcSlice.row.start = rcSlice.row.start || 0;\n    rcSlice.row.end = rcSlice.row.end || A.length;\n    rcSlice.row.step = rcSlice.row.step || 1;\n    ml = jStat.arange(rcSlice.row.start,\n                          Math.min(A[0].length, rcSlice.row.end),\n                          rcSlice.row.step);\n    var n = rcSlice.col;\n    ml.forEach(function(m, j) {\n      A[m][n] = B[j];\n    });\n    return A;\n  }\n\n  if (B[0].length === undefined) {\n    B = [B];\n  }\n  rcSlice.row.start = rcSlice.row.start || 0;\n  rcSlice.row.end = rcSlice.row.end || A.length;\n  rcSlice.row.step = rcSlice.row.step || 1;\n  rcSlice.col.start = rcSlice.col.start || 0;\n  rcSlice.col.end = rcSlice.col.end || A[0].length;\n  rcSlice.col.step = rcSlice.col.step || 1;\n  ml = jStat.arange(rcSlice.row.start,\n                        Math.min(A.length, rcSlice.row.end),\n                        rcSlice.row.step);\n  nl = jStat.arange(rcSlice.col.start,\n                        Math.min(A[0].length, rcSlice.col.end),\n                        rcSlice.col.step);\n  ml.forEach(function(m, i) {\n    nl.forEach(function(n, j) {\n      A[m][n] = B[i][j];\n    });\n  });\n  return A;\n};\n\n\n// [1,2,3] ->\n// [[1,0,0],[0,2,0],[0,0,3]]\njStat.diagonal = function diagonal(diagArray) {\n  var mat = jStat.zeros(diagArray.length, diagArray.length);\n  diagArray.forEach(function(t, i) {\n    mat[i][i] = t;\n  });\n  return mat;\n};\n\n\n// return copy of A\njStat.copy = function copy(A) {\n  return A.map(function(row) {\n    if (isNumber(row))\n      return row;\n    return row.map(function(t) {\n      return t;\n    });\n  });\n};\n\n\n// TODO: Go over this entire implementation. Seems a tragic waste of resources\n// doing all this work. Instead, and while ugly, use new Function() to generate\n// a custom function for each static method.\n\n// Quick reference.\nvar jProto = jStat.prototype;\n\n// Default length.\njProto.length = 0;\n\n// For internal use only.\n// TODO: Check if they're actually used, and if they are then rename them\n// to _*\njProto.push = Array.prototype.push;\njProto.sort = Array.prototype.sort;\njProto.splice = Array.prototype.splice;\njProto.slice = Array.prototype.slice;\n\n\n// Return a clean array.\njProto.toArray = function toArray() {\n  return this.length > 1 ? slice.call(this) : slice.call(this)[0];\n};\n\n\n// Map a function to a matrix or vector.\njProto.map = function map(func, toAlter) {\n  return jStat(jStat.map(this, func, toAlter));\n};\n\n\n// Cumulatively combine the elements of a matrix or vector using a function.\njProto.cumreduce = function cumreduce(func, toAlter) {\n  return jStat(jStat.cumreduce(this, func, toAlter));\n};\n\n\n// Destructively alter an array.\njProto.alter = function alter(func) {\n  jStat.alter(this, func);\n  return this;\n};\n\n\n// Extend prototype with methods that have no argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(func) {\n      var self = this,\n      results;\n      // Check for callback.\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self));\n        });\n        return this;\n      }\n      results = jStat[passfunc](this);\n      return isArray(results) ? jStat(results) : results;\n    };\n  })(funcs[i]);\n})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));\n\n\n// Extend prototype with methods that have one argument.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function(index, func) {\n      var self = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(self, jProto[passfunc].call(self, index));\n        });\n        return this;\n      }\n      return jStat(jStat[passfunc](this, index));\n    };\n  })(funcs[i]);\n})('row col'.split(' '));\n\n\n// Extend prototype with simple shortcut methods.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('create zeros ones rand identity'.split(' '));\n\n\n// Exposing jStat.\nreturn jStat;\n\n}(Math));\n(function(jStat, Math) {\n\nvar isFunction = jStat.utils.isFunction;\n\n// Ascending functions for sort\nfunction ascNum(a, b) { return a - b; }\n\nfunction clip(arg, min, max) {\n  return Math.max(min, Math.min(arg, max));\n}\n\n\n// sum of an array\njStat.sum = function sum(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n\n// sum squared\njStat.sumsqrd = function sumsqrd(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i] * arr[i];\n  return sum;\n};\n\n\n// sum of squared errors of prediction (SSE)\njStat.sumsqerr = function sumsqerr(arr) {\n  var mean = jStat.mean(arr);\n  var sum = 0;\n  var i = arr.length;\n  var tmp;\n  while (--i >= 0) {\n    tmp = arr[i] - mean;\n    sum += tmp * tmp;\n  }\n  return sum;\n};\n\n// sum of an array in each row\njStat.sumrow = function sumrow(arr) {\n  var sum = 0;\n  var i = arr.length;\n  while (--i >= 0)\n    sum += arr[i];\n  return sum;\n};\n\n// product of an array\njStat.product = function product(arr) {\n  var prod = 1;\n  var i = arr.length;\n  while (--i >= 0)\n    prod *= arr[i];\n  return prod;\n};\n\n\n// minimum value of an array\njStat.min = function min(arr) {\n  var low = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] < low)\n      low = arr[i];\n  return low;\n};\n\n\n// maximum value of an array\njStat.max = function max(arr) {\n  var high = arr[0];\n  var i = 0;\n  while (++i < arr.length)\n    if (arr[i] > high)\n      high = arr[i];\n  return high;\n};\n\n\n// unique values of an array\njStat.unique = function unique(arr) {\n  var hash = {}, _arr = [];\n  for(var i = 0; i < arr.length; i++) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      _arr.push(arr[i]);\n    }\n  }\n  return _arr;\n};\n\n\n// mean value of an array\njStat.mean = function mean(arr) {\n  return jStat.sum(arr) / arr.length;\n};\n\n\n// mean squared error (MSE)\njStat.meansqerr = function meansqerr(arr) {\n  return jStat.sumsqerr(arr) / arr.length;\n};\n\n\n// geometric mean of an array\njStat.geomean = function geomean(arr) {\n  var logs = arr.map(Math.log)\n  var meanOfLogs = jStat.mean(logs)\n  return Math.exp(meanOfLogs)\n};\n\n\n// median of an array\njStat.median = function median(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  // check if array is even or odd, then return the appropriate\n  return !(arrlen & 1)\n    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2\n    : _arr[(arrlen / 2) | 0 ];\n};\n\n\n// cumulative sum of an array\njStat.cumsum = function cumsum(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a + b; });\n};\n\n\n// cumulative product of an array\njStat.cumprod = function cumprod(arr) {\n  return jStat.cumreduce(arr, function (a, b) { return a * b; });\n};\n\n\n// successive differences of a sequence\njStat.diff = function diff(arr) {\n  var diffs = [];\n  var arrLen = arr.length;\n  var i;\n  for (i = 1; i < arrLen; i++)\n    diffs.push(arr[i] - arr[i - 1]);\n  return diffs;\n};\n\n\n// ranks of an array\njStat.rank = function (arr) {\n  var i;\n  var distinctNumbers = [];\n  var numberCounts = {};\n  for (i = 0; i < arr.length; i++) {\n    var number = arr[i];\n    if (numberCounts[number]) {\n      numberCounts[number]++;\n    } else {\n      numberCounts[number] = 1;\n      distinctNumbers.push(number);\n    }\n  }\n\n  var sortedDistinctNumbers = distinctNumbers.sort(ascNum);\n  var numberRanks = {};\n  var currentRank = 1;\n  for (i = 0; i < sortedDistinctNumbers.length; i++) {\n    var number = sortedDistinctNumbers[i];\n    var count = numberCounts[number];\n    var first = currentRank;\n    var last = currentRank + count - 1;\n    var rank = (first + last) / 2;\n    numberRanks[number] = rank;\n    currentRank += count;\n  }\n\n  return arr.map(function (number) {\n    return numberRanks[number];\n  });\n};\n\n\n// mode of an array\n// if there are multiple modes of an array, return all of them\n// is this the appropriate way of handling it?\njStat.mode = function mode(arr) {\n  var arrLen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  var count = 1;\n  var maxCount = 0;\n  var numMaxCount = 0;\n  var mode_arr = [];\n  var i;\n\n  for (i = 0; i < arrLen; i++) {\n    if (_arr[i] === _arr[i + 1]) {\n      count++;\n    } else {\n      if (count > maxCount) {\n        mode_arr = [_arr[i]];\n        maxCount = count;\n        numMaxCount = 0;\n      }\n      // are there multiple max counts\n      else if (count === maxCount) {\n        mode_arr.push(_arr[i]);\n        numMaxCount++;\n      }\n      // resetting count for new value in array\n      count = 1;\n    }\n  }\n\n  return numMaxCount === 0 ? mode_arr[0] : mode_arr;\n};\n\n\n// range of an array\njStat.range = function range(arr) {\n  return jStat.max(arr) - jStat.min(arr);\n};\n\n// variance of an array\n// flag = true indicates sample instead of population\njStat.variance = function variance(arr, flag) {\n  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));\n};\n\n// pooled variance of an array of arrays\njStat.pooledvariance = function pooledvariance(arr) {\n  var sumsqerr = arr.reduce(function (a, samples) {return a + jStat.sumsqerr(samples);}, 0);\n  var count = arr.reduce(function (a, samples) {return a + samples.length;}, 0);\n  return sumsqerr / (count - arr.length);\n};\n\n// deviation of an array\njStat.deviation = function (arr) {\n  var mean = jStat.mean(arr);\n  var arrlen = arr.length;\n  var dev = new Array(arrlen);\n  for (var i = 0; i < arrlen; i++) {\n    dev[i] = arr[i] - mean;\n  }\n  return dev;\n};\n\n// standard deviation of an array\n// flag = true indicates sample instead of population\njStat.stdev = function stdev(arr, flag) {\n  return Math.sqrt(jStat.variance(arr, flag));\n};\n\n// pooled standard deviation of an array of arrays\njStat.pooledstdev = function pooledstdev(arr) {\n  return Math.sqrt(jStat.pooledvariance(arr));\n};\n\n// mean deviation (mean absolute deviation) of an array\njStat.meandev = function meandev(arr) {\n  var mean = jStat.mean(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - mean));\n  }\n  return jStat.mean(a);\n};\n\n\n// median deviation (median absolute deviation) of an array\njStat.meddev = function meddev(arr) {\n  var median = jStat.median(arr);\n  var a = [];\n  for (var i = arr.length - 1; i >= 0; i--) {\n    a.push(Math.abs(arr[i] - median));\n  }\n  return jStat.median(a);\n};\n\n\n// coefficient of variation\njStat.coeffvar = function coeffvar(arr) {\n  return jStat.stdev(arr) / jStat.mean(arr);\n};\n\n\n// quartiles of an array\njStat.quartiles = function quartiles(arr) {\n  var arrlen = arr.length;\n  var _arr = arr.slice().sort(ascNum);\n  return [\n    _arr[ Math.round((arrlen) / 4) - 1 ],\n    _arr[ Math.round((arrlen) / 2) - 1 ],\n    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]\n  ];\n};\n\n\n// Arbitary quantiles of an array. Direct port of the scipy.stats\n// implementation by Pierre GF Gerard-Marchant.\njStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {\n  var sortedArray = arr.slice().sort(ascNum);\n  var quantileVals = [quantilesArray.length];\n  var n = arr.length;\n  var i, p, m, aleph, k, gamma;\n\n  if (typeof alphap === 'undefined')\n    alphap = 3 / 8;\n  if (typeof betap === 'undefined')\n    betap = 3 / 8;\n\n  for (i = 0; i < quantilesArray.length; i++) {\n    p = quantilesArray[i];\n    m = alphap + p * (1 - alphap - betap);\n    aleph = n * p + m;\n    k = Math.floor(clip(aleph, 1, n - 1));\n    gamma = clip(aleph - k, 0, 1);\n    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];\n  }\n\n  return quantileVals;\n};\n\n// Return the k-th percentile of values in a range, where k is in the range 0..1, inclusive.\n// Passing true for the exclusive parameter excludes both endpoints of the range.\njStat.percentile = function percentile(arr, k, exclusive) {\n  var _arr = arr.slice().sort(ascNum);\n  var realIndex = k * (_arr.length + (exclusive ? 1 : -1)) + (exclusive ? 0 : 1);\n  var index = parseInt(realIndex);\n  var frac = realIndex - index;\n  if (index + 1 < _arr.length) {\n    return _arr[index - 1] + frac * (_arr[index] - _arr[index - 1]);\n  } else {\n    return _arr[index - 1];\n  }\n}\n\n// The percentile rank of score in a given array. Returns the percentage\n// of all values in the input array that are less than (kind='strict') or\n// less or equal than (kind='weak') score. Default is weak.\njStat.percentileOfScore = function percentileOfScore(arr, score, kind) {\n  var counter = 0;\n  var len = arr.length;\n  var strict = false;\n  var value, i;\n\n  if (kind === 'strict')\n    strict = true;\n\n  for (i = 0; i < len; i++) {\n    value = arr[i];\n    if ((strict && value < score) ||\n        (!strict && value <= score)) {\n      counter++;\n    }\n  }\n\n  return counter / len;\n};\n\n\n// Histogram (bin count) data\njStat.histogram = function histogram(arr, binCnt) {\n  binCnt = binCnt || 4;\n  var first = jStat.min(arr);\n  var binWidth = (jStat.max(arr) - first) / binCnt;\n  var len = arr.length;\n  var bins = [];\n  var i;\n\n  for (i = 0; i < binCnt; i++)\n    bins[i] = 0;\n  for (i = 0; i < len; i++)\n    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;\n\n  return bins;\n};\n\n\n// covariance of two arrays\njStat.covariance = function covariance(arr1, arr2) {\n  var u = jStat.mean(arr1);\n  var v = jStat.mean(arr2);\n  var arr1Len = arr1.length;\n  var sq_dev = new Array(arr1Len);\n  var i;\n\n  for (i = 0; i < arr1Len; i++)\n    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);\n\n  return jStat.sum(sq_dev) / (arr1Len - 1);\n};\n\n\n// (pearson's) population correlation coefficient, rho\njStat.corrcoeff = function corrcoeff(arr1, arr2) {\n  return jStat.covariance(arr1, arr2) /\n      jStat.stdev(arr1, 1) /\n      jStat.stdev(arr2, 1);\n};\n\n  // (spearman's) rank correlation coefficient, sp\njStat.spearmancoeff =  function (arr1, arr2) {\n  arr1 = jStat.rank(arr1);\n  arr2 = jStat.rank(arr2);\n  //return pearson's correlation of the ranks:\n  return jStat.corrcoeff(arr1, arr2);\n}\n\n\n// statistical standardized moments (general form of skew/kurt)\njStat.stanMoment = function stanMoment(arr, n) {\n  var mu = jStat.mean(arr);\n  var sigma = jStat.stdev(arr);\n  var len = arr.length;\n  var skewSum = 0;\n\n  for (var i = 0; i < len; i++)\n    skewSum += Math.pow((arr[i] - mu) / sigma, n);\n\n  return skewSum / arr.length;\n};\n\n// (pearson's) moment coefficient of skewness\njStat.skewness = function skewness(arr) {\n  return jStat.stanMoment(arr, 3);\n};\n\n// (pearson's) (excess) kurtosis\njStat.kurtosis = function kurtosis(arr) {\n  return jStat.stanMoment(arr, 4) - 3;\n};\n\n\nvar jProto = jStat.prototype;\n\n\n// Extend jProto with method for calculating cumulative sums and products.\n// This differs from the similar extension below as cumsum and cumprod should\n// not be run again in the case fullbool === true.\n// If a matrix is passed, automatically assume operation should be done on the\n// columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('cumsum cumprod').split(' '));\n\n\n// Extend jProto with methods which don't require arguments and work on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    // If a matrix is passed, automatically assume operation should be done on\n    // the columns.\n    jProto[passfunc] = function(fullbool, func) {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      // Assignment reassignation depending on how parameters were passed in.\n      if (isFunction(fullbool)) {\n        func = fullbool;\n        fullbool = false;\n      }\n      // Check if a callback was passed with the function.\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));\n        });\n        return this;\n      }\n      // Check if matrix and run calculations.\n      if (this.length > 1) {\n        if (passfunc !== 'sumrow')\n          tmpthis = fullbool === true ? this : this.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = jStat[passfunc](tmpthis[i]);\n        return fullbool === true\n            ? jStat[passfunc](jStat.utils.toVector(arr))\n            : arr;\n      }\n      // Pass fullbool if only vector, not a matrix. for variance and stdev.\n      return jStat[passfunc](this[0], fullbool);\n    };\n  })(funcs[i]);\n})(('sum sumsqrd sumsqerr sumrow product min max unique mean meansqerr ' +\n    'geomean median diff rank mode range variance deviation stdev meandev ' +\n    'meddev coeffvar quartiles histogram skewness kurtosis').split(' '));\n\n\n// Extend jProto with functions that take arguments. Operations on matrices are\n// done on columns.\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jProto[passfunc] = function() {\n      var arr = [];\n      var i = 0;\n      var tmpthis = this;\n      var args = Array.prototype.slice.call(arguments);\n      var callbackFunction;\n\n      // If the last argument is a function, we assume it's a callback; we\n      // strip the callback out and call the function again.\n      if (isFunction(args[args.length - 1])) {\n        callbackFunction = args[args.length - 1];\n        var argsToPass = args.slice(0, args.length - 1);\n\n        setTimeout(function() {\n          callbackFunction.call(tmpthis,\n                                jProto[passfunc].apply(tmpthis, argsToPass));\n        });\n        return this;\n\n      // Otherwise we curry the function args and call normally.\n      } else {\n        callbackFunction = undefined;\n        var curriedFunction = function curriedFunction(vector) {\n          return jStat[passfunc].apply(tmpthis, [vector].concat(args));\n        }\n      }\n\n      // If this is a matrix, run column-by-column.\n      if (this.length > 1) {\n        tmpthis = tmpthis.transpose();\n        for (; i < tmpthis.length; i++)\n          arr[i] = curriedFunction(tmpthis[i]);\n        return arr;\n      }\n\n      // Otherwise run on the vector.\n      return curriedFunction(this[0]);\n    };\n  })(funcs[i]);\n})('quantiles percentileOfScore'.split(' '));\n\n}(jStat, Math));\n// Special functions //\n(function(jStat, Math) {\n\n// Log-gamma function\njStat.gammaln = function gammaln(x) {\n  var j = 0;\n  var cof = [\n    76.18009172947146, -86.50532032941677, 24.01409824083091,\n    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5\n  ];\n  var ser = 1.000000000190015;\n  var xx, y, tmp;\n  tmp = (y = xx = x) + 5.5;\n  tmp -= (xx + 0.5) * Math.log(tmp);\n  for (; j < 6; j++)\n    ser += cof[j] / ++y;\n  return Math.log(2.5066282746310005 * ser / xx) - tmp;\n};\n\n/*\n * log-gamma function to support poisson distribution sampling. The\n * algorithm comes from SPECFUN by Shanjie Zhang and Jianming Jin and their\n * book \"Computation of Special Functions\", 1996, John Wiley & Sons, Inc.\n */\njStat.loggam = function loggam(x) {\n  var x0, x2, xp, gl, gl0;\n  var k, n;\n\n  var a = [8.333333333333333e-02, -2.777777777777778e-03,\n          7.936507936507937e-04, -5.952380952380952e-04,\n          8.417508417508418e-04, -1.917526917526918e-03,\n          6.410256410256410e-03, -2.955065359477124e-02,\n          1.796443723688307e-01, -1.39243221690590e+00];\n  x0 = x;\n  n = 0;\n  if ((x == 1.0) || (x == 2.0)) {\n      return 0.0;\n  }\n  if (x <= 7.0) {\n      n = Math.floor(7 - x);\n      x0 = x + n;\n  }\n  x2 = 1.0 / (x0 * x0);\n  xp = 2 * Math.PI;\n  gl0 = a[9];\n  for (k = 8; k >= 0; k--) {\n      gl0 *= x2;\n      gl0 += a[k];\n  }\n  gl = gl0 / x0 + 0.5 * Math.log(xp) + (x0 - 0.5) * Math.log(x0) - x0;\n  if (x <= 7.0) {\n      for (k = 1; k <= n; k++) {\n          gl -= Math.log(x0 - 1.0);\n          x0 -= 1.0;\n      }\n  }\n  return gl;\n}\n\n// gamma of x\njStat.gammafn = function gammafn(x) {\n  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,\n           629.3311553128184, 866.9662027904133, -31451.272968848367,\n           -36144.413418691176, 66456.14382024054\n  ];\n  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,\n           -3107.771671572311, 22538.118420980151, 4755.8462775278811,\n           -134659.9598649693, -115132.2596755535];\n  var fact = false;\n  var n = 0;\n  var xden = 0;\n  var xnum = 0;\n  var y = x;\n  var i, z, yi, res;\n  if (x > 171.6243769536076) {\n    return Infinity;\n  }\n  if (y <= 0) {\n    res = y % 1 + 3.6e-16;\n    if (res) {\n      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);\n      y = 1 - y;\n    } else {\n      return Infinity;\n    }\n  }\n  yi = y;\n  if (y < 1) {\n    z = y++;\n  } else {\n    z = (y -= n = (y | 0) - 1) - 1;\n  }\n  for (i = 0; i < 8; ++i) {\n    xnum = (xnum + p[i]) * z;\n    xden = xden * z + q[i];\n  }\n  res = xnum / xden + 1;\n  if (yi < y) {\n    res /= yi;\n  } else if (yi > y) {\n    for (i = 0; i < n; ++i) {\n      res *= y;\n      y++;\n    }\n  }\n  if (fact) {\n    res = fact / res;\n  }\n  return res;\n};\n\n\n// lower incomplete gamma function, which is usually typeset with a\n// lower-case greek gamma as the function symbol\njStat.gammap = function gammap(a, x) {\n  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);\n};\n\n\n// The lower regularized incomplete gamma function, usually written P(a,x)\njStat.lowRegGamma = function lowRegGamma(a, x) {\n  var aln = jStat.gammaln(a);\n  var ap = a;\n  var sum = 1 / a;\n  var del = sum;\n  var b = x + 1 - a;\n  var c = 1 / 1.0e-30;\n  var d = 1 / b;\n  var h = d;\n  var i = 1;\n  // calculate maximum number of itterations required for a\n  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);\n  var an;\n\n  if (x < 0 || a <= 0) {\n    return NaN;\n  } else if (x < a + 1) {\n    for (; i <= ITMAX; i++) {\n      sum += del *= x / ++ap;\n    }\n    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));\n  }\n\n  for (; i <= ITMAX; i++) {\n    an = -i * (i - a);\n    b += 2;\n    d = an * d + b;\n    c = b + an / c;\n    d = 1 / d;\n    h *= d * c;\n  }\n\n  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));\n};\n\n// natural log factorial of n\njStat.factorialln = function factorialln(n) {\n  return n < 0 ? NaN : jStat.gammaln(n + 1);\n};\n\n// factorial of n\njStat.factorial = function factorial(n) {\n  return n < 0 ? NaN : jStat.gammafn(n + 1);\n};\n\n// combinations of n, m\njStat.combination = function combination(n, m) {\n  // make sure n or m don't exceed the upper limit of usable values\n  return (n > 170 || m > 170)\n      ? Math.exp(jStat.combinationln(n, m))\n      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);\n};\n\n\njStat.combinationln = function combinationln(n, m){\n  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);\n};\n\n\n// permutations of n, m\njStat.permutation = function permutation(n, m) {\n  return jStat.factorial(n) / jStat.factorial(n - m);\n};\n\n\n// beta function\njStat.betafn = function betafn(x, y) {\n  // ensure arguments are positive\n  if (x <= 0 || y <= 0)\n    return undefined;\n  // make sure x + y doesn't exceed the upper limit of usable values\n  return (x + y > 170)\n      ? Math.exp(jStat.betaln(x, y))\n      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);\n};\n\n\n// natural logarithm of beta function\njStat.betaln = function betaln(x, y) {\n  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);\n};\n\n\n// Evaluates the continued fraction for incomplete beta function by modified\n// Lentz's method.\njStat.betacf = function betacf(x, a, b) {\n  var fpmin = 1e-30;\n  var m = 1;\n  var qab = a + b;\n  var qap = a + 1;\n  var qam = a - 1;\n  var c = 1;\n  var d = 1 - qab * x / qap;\n  var m2, aa, del, h;\n\n  // These q's will be used in factors that occur in the coefficients\n  if (Math.abs(d) < fpmin)\n    d = fpmin;\n  d = 1 / d;\n  h = d;\n\n  for (; m <= 100; m++) {\n    m2 = 2 * m;\n    aa = m * (b - m) * x / ((qam + m2) * (a + m2));\n    // One step (the even one) of the recurrence\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    h *= d * c;\n    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));\n    // Next step of the recurrence (the odd one)\n    d = 1 + aa * d;\n    if (Math.abs(d) < fpmin)\n      d = fpmin;\n    c = 1 + aa / c;\n    if (Math.abs(c) < fpmin)\n      c = fpmin;\n    d = 1 / d;\n    del = d * c;\n    h *= del;\n    if (Math.abs(del - 1.0) < 3e-7)\n      break;\n  }\n\n  return h;\n};\n\n\n// Returns the inverse of the lower regularized inomplete gamma function\njStat.gammapinv = function gammapinv(p, a) {\n  var j = 0;\n  var a1 = a - 1;\n  var EPS = 1e-8;\n  var gln = jStat.gammaln(a);\n  var x, err, t, u, pp, lna1, afac;\n\n  if (p >= 1)\n    return Math.max(100, a + 100 * Math.sqrt(a));\n  if (p <= 0)\n    return 0;\n  if (a > 1) {\n    lna1 = Math.log(a1);\n    afac = Math.exp(a1 * (lna1 - 1) - gln);\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    x = Math.max(1e-3,\n                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));\n  } else {\n    t = 1 - a * (0.253 + a * 0.12);\n    if (p < t)\n      x = Math.pow(p / t, 1 / a);\n    else\n      x = 1 - Math.log(1 - (p - t) / (1 - t));\n  }\n\n  for(; j < 12; j++) {\n    if (x <= 0)\n      return 0;\n    err = jStat.lowRegGamma(a, x) - p;\n    if (a > 1)\n      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));\n    else\n      t = Math.exp(-x + a1 * Math.log(x) - gln);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (Math.abs(t) < EPS * x)\n      break;\n  }\n\n  return x;\n};\n\n\n// Returns the error function erf(x)\njStat.erf = function erf(x) {\n  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,\n             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,\n             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,\n             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,\n             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,\n             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,\n             -6.886027e-12, 8.94487e-13, 3.13092e-13,\n             -1.12708e-13, 3.81e-16, 7.106e-15,\n             -1.523e-15, -9.4e-17, 1.21e-16,\n             -2.8e-17];\n  var j = cof.length - 1;\n  var isneg = false;\n  var d = 0;\n  var dd = 0;\n  var t, ty, tmp, res;\n\n  if (x < 0) {\n    x = -x;\n    isneg = true;\n  }\n\n  t = 2 / (2 + x);\n  ty = 4 * t - 2;\n\n  for(; j > 0; j--) {\n    tmp = d;\n    d = ty * d - dd + cof[j];\n    dd = tmp;\n  }\n\n  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);\n  return isneg ? res - 1 : 1 - res;\n};\n\n\n// Returns the complmentary error function erfc(x)\njStat.erfc = function erfc(x) {\n  return 1 - jStat.erf(x);\n};\n\n\n// Returns the inverse of the complementary error function\njStat.erfcinv = function erfcinv(p) {\n  var j = 0;\n  var x, err, t, pp;\n  if (p >= 2)\n    return -100;\n  if (p <= 0)\n    return 100;\n  pp = (p < 1) ? p : 2 - p;\n  t = Math.sqrt(-2 * Math.log(pp / 2));\n  x = -0.70711 * ((2.30753 + t * 0.27061) /\n                  (1 + t * (0.99229 + t * 0.04481)) - t);\n  for (; j < 2; j++) {\n    err = jStat.erfc(x) - pp;\n    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);\n  }\n  return (p < 1) ? x : -x;\n};\n\n\n// Returns the inverse of the incomplete beta function\njStat.ibetainv = function ibetainv(p, a, b) {\n  var EPS = 1e-8;\n  var a1 = a - 1;\n  var b1 = b - 1;\n  var j = 0;\n  var lna, lnb, pp, t, u, err, x, al, h, w, afac;\n  if (p <= 0)\n    return 0;\n  if (p >= 1)\n    return 1;\n  if (a >= 1 && b >= 1) {\n    pp = (p < 0.5) ? p : 1 - p;\n    t = Math.sqrt(-2 * Math.log(pp));\n    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;\n    if (p < 0.5)\n      x = -x;\n    al = (x * x - 3) / 6;\n    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));\n    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *\n        (al + 5 / 6 - 2 / (3 * h));\n    x = a / (a + b * Math.exp(2 * w));\n  } else {\n    lna = Math.log(a / (a + b));\n    lnb = Math.log(b / (a + b));\n    t = Math.exp(a * lna) / a;\n    u = Math.exp(b * lnb) / b;\n    w = t + u;\n    if (p < t / w)\n      x = Math.pow(a * w * p, 1 / a);\n    else\n      x = 1 - Math.pow(b * w * (1 - p), 1 / b);\n  }\n  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);\n  for(; j < 10; j++) {\n    if (x === 0 || x === 1)\n      return x;\n    err = jStat.ibeta(x, a, b) - p;\n    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);\n    u = err / t;\n    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));\n    if (x <= 0)\n      x = 0.5 * (x + t);\n    if (x >= 1)\n      x = 0.5 * (x + t + 1);\n    if (Math.abs(t) < EPS * x && j > 0)\n      break;\n  }\n  return x;\n};\n\n\n// Returns the incomplete beta function I_x(a,b)\njStat.ibeta = function ibeta(x, a, b) {\n  // Factors in front of the continued fraction.\n  var bt = (x === 0 || x === 1) ?  0 :\n    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -\n             jStat.gammaln(b) + a * Math.log(x) + b *\n             Math.log(1 - x));\n  if (x < 0 || x > 1)\n    return false;\n  if (x < (a + 1) / (a + b + 2))\n    // Use continued fraction directly.\n    return bt * jStat.betacf(x, a, b) / a;\n  // else use continued fraction after making the symmetry transformation.\n  return 1 - bt * jStat.betacf(1 - x, b, a) / b;\n};\n\n\n// Returns a normal deviate (mu=0, sigma=1).\n// If n and m are specified it returns a object of normal deviates.\njStat.randn = function randn(n, m) {\n  var u, v, x, y, q;\n  if (!m)\n    m = n;\n  if (n)\n    return jStat.create(n, m, function() { return jStat.randn(); });\n  do {\n    u = jStat._random_fn();\n    v = 1.7156 * (jStat._random_fn() - 0.5);\n    x = u - 0.449871;\n    y = Math.abs(v) + 0.386595;\n    q = x * x + y * (0.19600 * y - 0.25472 * x);\n  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));\n  return v / u;\n};\n\n\n// Returns a gamma deviate by the method of Marsaglia and Tsang.\njStat.randg = function randg(shape, n, m) {\n  var oalph = shape;\n  var a1, a2, u, v, x, mat;\n  if (!m)\n    m = n;\n  if (!shape)\n    shape = 1;\n  if (n) {\n    mat = jStat.zeros(n,m);\n    mat.alter(function() { return jStat.randg(shape); });\n    return mat;\n  }\n  if (shape < 1)\n    shape += 1;\n  a1 = shape - 1 / 3;\n  a2 = 1 / Math.sqrt(9 * a1);\n  do {\n    do {\n      x = jStat.randn();\n      v = 1 + a2 * x;\n    } while(v <= 0);\n    v = v * v * v;\n    u = jStat._random_fn();\n  } while(u > 1 - 0.331 * Math.pow(x, 4) &&\n          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));\n  // alpha > 1\n  if (shape == oalph)\n    return a1 * v;\n  // alpha < 1\n  do {\n    u = jStat._random_fn();\n  } while(u === 0);\n  return Math.pow(u, 1 / oalph) * a1 * v;\n};\n\n\n// making use of static methods on the instance\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(\n          jStat.map(this, function(value) { return jStat[passfunc](value); }));\n    }\n  })(funcs[i]);\n})('gammaln gammafn factorial factorialln'.split(' '));\n\n\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function() {\n      return jStat(jStat[passfunc].apply(null, arguments));\n    };\n  })(funcs[i]);\n})('randn'.split(' '));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\n// generate all distribution instance methods\n(function(list) {\n  for (var i = 0; i < list.length; i++) (function(func) {\n    // distribution instance method\n    jStat[func] = function f(a, b, c) {\n      if (!(this instanceof f))\n        return new f(a, b, c);\n      this._a = a;\n      this._b = b;\n      this._c = c;\n      return this;\n    };\n    // distribution method to be used on a jStat instance\n    jStat.fn[func] = function(a, b, c) {\n      var newthis = jStat[func](a, b, c);\n      newthis.data = this;\n      return newthis;\n    };\n    // sample instance method\n    jStat[func].prototype.sample = function(arr) {\n      var a = this._a;\n      var b = this._b;\n      var c = this._c;\n      if (arr)\n        return jStat.alter(arr, function() {\n          return jStat[func].sample(a, b, c);\n        });\n      else\n        return jStat[func].sample(a, b, c);\n    };\n    // generate the pdf, cdf and inv instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function(x) {\n          var a = this._a;\n          var b = this._b;\n          var c = this._c;\n          if (!x && x !== 0)\n            x = this.data;\n          if (typeof x !== 'number') {\n            return jStat.fn.map.call(x, function(x) {\n              return jStat[func][fnfunc](x, a, b, c);\n            });\n          }\n          return jStat[func][fnfunc](x, a, b, c);\n        };\n      })(vals[i]);\n    })('pdf cdf inv'.split(' '));\n    // generate the mean, median, mode and variance instance methods\n    (function(vals) {\n      for (var i = 0; i < vals.length; i++) (function(fnfunc) {\n        jStat[func].prototype[fnfunc] = function() {\n          return jStat[func][fnfunc](this._a, this._b, this._c);\n        };\n      })(vals[i]);\n    })('mean median mode variance'.split(' '));\n  })(list[i]);\n})((\n  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +\n  'laplace lognormal noncentralt normal pareto studentt weibull uniform ' +\n  'binomial negbin hypgeom poisson triangular tukey arcsine'\n).split(' '));\n\n\n\n// extend beta function with static methods\njStat.extend(jStat.beta, {\n  pdf: function pdf(x, alpha, beta) {\n    // PDF is zero outside the support\n    if (x > 1 || x < 0)\n      return 0;\n    // PDF is one for the uniform case\n    if (alpha == 1 && beta == 1)\n      return 1;\n\n    if (alpha < 512 && beta < 512) {\n      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /\n          jStat.betafn(alpha, beta);\n    } else {\n      return Math.exp((alpha - 1) * Math.log(x) +\n                      (beta - 1) * Math.log(1 - x) -\n                      jStat.betaln(alpha, beta));\n    }\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);\n  },\n\n  inv: function inv(x, alpha, beta) {\n    return jStat.ibetainv(x, alpha, beta);\n  },\n\n  mean: function mean(alpha, beta) {\n    return alpha / (alpha + beta);\n  },\n\n  median: function median(alpha, beta) {\n    return jStat.ibetainv(0.5, alpha, beta);\n  },\n\n  mode: function mode(alpha, beta) {\n    return (alpha - 1 ) / ( alpha + beta - 2);\n  },\n\n  // return a random sample\n  sample: function sample(alpha, beta) {\n    var u = jStat.randg(alpha);\n    return u / (u + jStat.randg(beta));\n  },\n\n  variance: function variance(alpha, beta) {\n    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));\n  }\n});\n\n// extend F function with static methods\njStat.extend(jStat.centralF, {\n  // This implementation of the pdf function avoids float overflow\n  // See the way that R calculates this value:\n  // https://svn.r-project.org/R/trunk/src/nmath/df.c\n  pdf: function pdf(x, df1, df2) {\n    var p, q, f;\n\n    if (x < 0)\n      return 0;\n\n    if (df1 <= 2) {\n      if (x === 0 && df1 < 2) {\n        return Infinity;\n      }\n      if (x === 0 && df1 === 2) {\n        return 1;\n      }\n      return (1 / jStat.betafn(df1 / 2, df2 / 2)) *\n              Math.pow(df1 / df2, df1 / 2) *\n              Math.pow(x, (df1/2) - 1) *\n              Math.pow((1 + (df1 / df2) * x), -(df1 + df2) / 2);\n    }\n\n    p = (df1 * x) / (df2 + x * df1);\n    q = df2 / (df2 + x * df1);\n    f = df1 * q / 2.0;\n    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);\n  },\n\n  cdf: function cdf(x, df1, df2) {\n    if (x < 0)\n      return 0;\n    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);\n  },\n\n  inv: function inv(x, df1, df2) {\n    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));\n  },\n\n  mean: function mean(df1, df2) {\n    return (df2 > 2) ? df2 / (df2 - 2) : undefined;\n  },\n\n  mode: function mode(df1, df2) {\n    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;\n  },\n\n  // return a random sample\n  sample: function sample(df1, df2) {\n    var x1 = jStat.randg(df1 / 2) * 2;\n    var x2 = jStat.randg(df2 / 2) * 2;\n    return (x1 / df1) / (x2 / df2);\n  },\n\n  variance: function variance(df1, df2) {\n    if (df2 <= 4)\n      return undefined;\n    return 2 * df2 * df2 * (df1 + df2 - 2) /\n        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));\n  }\n});\n\n\n// extend cauchy function with static methods\njStat.extend(jStat.cauchy, {\n  pdf: function pdf(x, local, scale) {\n    if (scale < 0) { return 0; }\n\n    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;\n  },\n\n  cdf: function cdf(x, local, scale) {\n    return Math.atan((x - local) / scale) / Math.PI + 0.5;\n  },\n\n  inv: function(p, local, scale) {\n    return local + scale * Math.tan(Math.PI * (p - 0.5));\n  },\n\n  median: function median(local/*, scale*/) {\n    return local;\n  },\n\n  mode: function mode(local/*, scale*/) {\n    return local;\n  },\n\n  sample: function sample(local, scale) {\n    return jStat.randn() *\n        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;\n  }\n});\n\n\n\n// extend chisquare function with static methods\njStat.extend(jStat.chisquare, {\n  pdf: function pdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && dof === 2) ? 0.5 :\n        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *\n                 Math.log(2) - jStat.gammaln(dof / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(dof / 2, x / 2);\n  },\n\n  inv: function(p, dof) {\n    return 2 * jStat.gammapinv(p, 0.5 * dof);\n  },\n\n  mean : function(dof) {\n    return dof;\n  },\n\n  // TODO: this is an approximation (is there a better way?)\n  median: function median(dof) {\n    return dof * Math.pow(1 - (2 / (9 * dof)), 3);\n  },\n\n  mode: function mode(dof) {\n    return (dof - 2 > 0) ? dof - 2 : 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randg(dof / 2) * 2;\n  },\n\n  variance: function variance(dof) {\n    return 2 * dof;\n  }\n});\n\n\n\n// extend exponential function with static methods\njStat.extend(jStat.exponential, {\n  pdf: function pdf(x, rate) {\n    return x < 0 ? 0 : rate * Math.exp(-rate * x);\n  },\n\n  cdf: function cdf(x, rate) {\n    return x < 0 ? 0 : 1 - Math.exp(-rate * x);\n  },\n\n  inv: function(p, rate) {\n    return -Math.log(1 - p) / rate;\n  },\n\n  mean : function(rate) {\n    return 1 / rate;\n  },\n\n  median: function (rate) {\n    return (1 / rate) * Math.log(2);\n  },\n\n  mode: function mode(/*rate*/) {\n    return 0;\n  },\n\n  sample: function sample(rate) {\n    return -1 / rate * Math.log(jStat._random_fn());\n  },\n\n  variance : function(rate) {\n    return Math.pow(rate, -2);\n  }\n});\n\n\n\n// extend gamma function with static methods\njStat.extend(jStat.gamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return (x === 0 && shape === 1) ? 1 / scale :\n            Math.exp((shape - 1) * Math.log(x) - x / scale -\n                    jStat.gammaln(shape) - shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x < 0)\n      return 0;\n    return jStat.lowRegGamma(shape, x / scale);\n  },\n\n  inv: function(p, shape, scale) {\n    return jStat.gammapinv(p, shape) * scale;\n  },\n\n  mean : function(shape, scale) {\n    return shape * scale;\n  },\n\n  mode: function mode(shape, scale) {\n    if(shape > 1) return (shape - 1) * scale;\n    return undefined;\n  },\n\n  sample: function sample(shape, scale) {\n    return jStat.randg(shape) * scale;\n  },\n\n  variance: function variance(shape, scale) {\n    return shape * scale * scale;\n  }\n});\n\n// extend inverse gamma function with static methods\njStat.extend(jStat.invgamma, {\n  pdf: function pdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -\n                    jStat.gammaln(shape) + shape * Math.log(scale));\n  },\n\n  cdf: function cdf(x, shape, scale) {\n    if (x <= 0)\n      return 0;\n    return 1 - jStat.lowRegGamma(shape, scale / x);\n  },\n\n  inv: function(p, shape, scale) {\n    return scale / jStat.gammapinv(1 - p, shape);\n  },\n\n  mean : function(shape, scale) {\n    return (shape > 1) ? scale / (shape - 1) : undefined;\n  },\n\n  mode: function mode(shape, scale) {\n    return scale / (shape + 1);\n  },\n\n  sample: function sample(shape, scale) {\n    return scale / jStat.randg(shape);\n  },\n\n  variance: function variance(shape, scale) {\n    if (shape <= 2)\n      return undefined;\n    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));\n  }\n});\n\n\n// extend kumaraswamy function with static methods\njStat.extend(jStat.kumaraswamy, {\n  pdf: function pdf(x, alpha, beta) {\n    if (x === 0 && alpha === 1)\n      return beta;\n    else if (x === 1 && beta === 1)\n      return alpha;\n    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *\n                    Math.log(x) + (beta - 1) *\n                    Math.log(1 - Math.pow(x, alpha)));\n  },\n\n  cdf: function cdf(x, alpha, beta) {\n    if (x < 0)\n      return 0;\n    else if (x > 1)\n      return 1;\n    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));\n  },\n\n  inv: function inv(p, alpha, beta) {\n    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);\n  },\n\n  mean : function(alpha, beta) {\n    return (beta * jStat.gammafn(1 + 1 / alpha) *\n            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));\n  },\n\n  median: function median(alpha, beta) {\n    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);\n  },\n\n  mode: function mode(alpha, beta) {\n    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))\n      return undefined;\n    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);\n  },\n\n  variance: function variance(/*alpha, beta*/) {\n    throw new Error('variance not yet implemented');\n    // TODO: complete this\n  }\n});\n\n\n\n// extend lognormal function with static methods\njStat.extend(jStat.lognormal, {\n  pdf: function pdf(x, mu, sigma) {\n    if (x <= 0)\n      return 0;\n    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -\n                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /\n                    (2 * sigma * sigma));\n  },\n\n  cdf: function cdf(x, mu, sigma) {\n    if (x < 0)\n      return 0;\n    return 0.5 +\n        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));\n  },\n\n  inv: function(p, mu, sigma) {\n    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);\n  },\n\n  mean: function mean(mu, sigma) {\n    return Math.exp(mu + sigma * sigma / 2);\n  },\n\n  median: function median(mu/*, sigma*/) {\n    return Math.exp(mu);\n  },\n\n  mode: function mode(mu, sigma) {\n    return Math.exp(mu - sigma * sigma);\n  },\n\n  sample: function sample(mu, sigma) {\n    return Math.exp(jStat.randn() * sigma + mu);\n  },\n\n  variance: function variance(mu, sigma) {\n    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);\n  }\n});\n\n\n\n// extend noncentralt function with static methods\njStat.extend(jStat.noncentralt, {\n  pdf: function pdf(x, dof, ncp) {\n    var tol = 1e-14;\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.pdf(x, dof)\n\n    if (Math.abs(x) < tol) {  // different formula for x == 0\n      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -\n                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));\n    }\n\n    // formula for x != 0\n    return dof / x *\n        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -\n         jStat.noncentralt.cdf(x, dof, ncp));\n  },\n\n  cdf: function cdf(x, dof, ncp) {\n    var tol = 1e-14;\n    var min_iterations = 200;\n\n    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t\n      return jStat.studentt.cdf(x, dof);\n\n    // turn negative x into positive and flip result afterwards\n    var flip = false;\n    if (x < 0) {\n      flip = true;\n      ncp = -ncp;\n    }\n\n    var prob = jStat.normal.cdf(-ncp, 0, 1);\n    var value = tol + 1;\n    // use value at last two steps to determine convergence\n    var lastvalue = value;\n    var y = x * x / (x * x + dof);\n    var j = 0;\n    var p = Math.exp(-ncp * ncp / 2);\n    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -\n                     jStat.gammaln(3 / 2)) * ncp;\n    while (j < min_iterations || lastvalue > tol || value > tol) {\n      lastvalue = value;\n      if (j > 0) {\n        p *= (ncp * ncp) / (2 * j);\n        q *= (ncp * ncp) / (2 * (j + 1 / 2));\n      }\n      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +\n          q * jStat.beta.cdf(y, j+1, dof/2);\n      prob += 0.5 * value;\n      j++;\n    }\n\n    return flip ? (1 - prob) : prob;\n  }\n});\n\n\n// extend normal function with static methods\njStat.extend(jStat.normal, {\n  pdf: function pdf(x, mean, std) {\n    return Math.exp(-0.5 * Math.log(2 * Math.PI) -\n                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));\n  },\n\n  cdf: function cdf(x, mean, std) {\n    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));\n  },\n\n  inv: function(p, mean, std) {\n    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;\n  },\n\n  mean : function(mean/*, std*/) {\n    return mean;\n  },\n\n  median: function median(mean/*, std*/) {\n    return mean;\n  },\n\n  mode: function (mean/*, std*/) {\n    return mean;\n  },\n\n  sample: function sample(mean, std) {\n    return jStat.randn() * std + mean;\n  },\n\n  variance : function(mean, std) {\n    return std * std;\n  }\n});\n\n\n\n// extend pareto function with static methods\njStat.extend(jStat.pareto, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    if (x < scale)\n      return 0;\n    return 1 - Math.pow(scale / x, shape);\n  },\n\n  inv: function inv(p, scale, shape) {\n    return scale / Math.pow(1 - p, 1 / shape);\n  },\n\n  mean: function mean(scale, shape) {\n    if (shape <= 1)\n      return undefined;\n    return (shape * Math.pow(scale, shape)) / (shape - 1);\n  },\n\n  median: function median(scale, shape) {\n    return scale * (shape * Math.SQRT2);\n  },\n\n  mode: function mode(scale/*, shape*/) {\n    return scale;\n  },\n\n  variance : function(scale, shape) {\n    if (shape <= 2)\n      return undefined;\n    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));\n  }\n});\n\n\n\n// extend studentt function with static methods\njStat.extend(jStat.studentt, {\n  pdf: function pdf(x, dof) {\n    dof = dof > 1e100 ? 1e100 : dof;\n    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *\n        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));\n  },\n\n  cdf: function cdf(x, dof) {\n    var dof2 = dof / 2;\n    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /\n                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);\n  },\n\n  inv: function(p, dof) {\n    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);\n    x = Math.sqrt(dof * (1 - x) / x);\n    return (p > 0.5) ? x : -x;\n  },\n\n  mean: function mean(dof) {\n    return (dof > 1) ? 0 : undefined;\n  },\n\n  median: function median(/*dof*/) {\n    return 0;\n  },\n\n  mode: function mode(/*dof*/) {\n    return 0;\n  },\n\n  sample: function sample(dof) {\n    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));\n  },\n\n  variance: function variance(dof) {\n    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;\n  }\n});\n\n\n\n// extend weibull function with static methods\njStat.extend(jStat.weibull, {\n  pdf: function pdf(x, scale, shape) {\n    if (x < 0 || scale < 0 || shape < 0)\n      return 0;\n    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *\n        Math.exp(-(Math.pow((x / scale), shape)));\n  },\n\n  cdf: function cdf(x, scale, shape) {\n    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));\n  },\n\n  inv: function(p, scale, shape) {\n    return scale * Math.pow(-Math.log(1 - p), 1 / shape);\n  },\n\n  mean : function(scale, shape) {\n    return scale * jStat.gammafn(1 + 1 / shape);\n  },\n\n  median: function median(scale, shape) {\n    return scale * Math.pow(Math.log(2), 1 / shape);\n  },\n\n  mode: function mode(scale, shape) {\n    if (shape <= 1)\n      return 0;\n    return scale * Math.pow((shape - 1) / shape, 1 / shape);\n  },\n\n  sample: function sample(scale, shape) {\n    return scale * Math.pow(-Math.log(jStat._random_fn()), 1 / shape);\n  },\n\n  variance: function variance(scale, shape) {\n    return scale * scale * jStat.gammafn(1 + 2 / shape) -\n        Math.pow(jStat.weibull.mean(scale, shape), 2);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.uniform, {\n  pdf: function pdf(x, a, b) {\n    return (x < a || x > b) ? 0 : 1 / (b - a);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (x - a) / (b - a);\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (p * (b - a));\n  },\n\n  mean: function mean(a, b) {\n    return 0.5 * (a + b);\n  },\n\n  median: function median(a, b) {\n    return jStat.mean(a, b);\n  },\n\n  mode: function mode(/*a, b*/) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * jStat._random_fn() - 1);\n  },\n\n  variance: function variance(a, b) {\n    return Math.pow(b - a, 2) / 12;\n  }\n});\n\n\n// Got this from http://www.math.ucla.edu/~tom/distributions/binomial.html\nfunction betinc(x, a, b, eps) {\n  var a0 = 0;\n  var b0 = 1;\n  var a1 = 1;\n  var b1 = 1;\n  var m9 = 0;\n  var a2 = 0;\n  var c9;\n\n  while (Math.abs((a1 - a2) / a1) > eps) {\n    a2 = a1;\n    c9 = -(a + m9) * (a + b + m9) * x / (a + 2 * m9) / (a + 2 * m9 + 1);\n    a0 = a1 + c9 * a0;\n    b0 = b1 + c9 * b0;\n    m9 = m9 + 1;\n    c9 = m9 * (b - m9) * x / (a + 2 * m9 - 1) / (a + 2 * m9);\n    a1 = a0 + c9 * a1;\n    b1 = b0 + c9 * b1;\n    a0 = a0 / b1;\n    b0 = b0 / b1;\n    a1 = a1 / b1;\n    b1 = 1;\n  }\n\n  return a1 / a;\n}\n\n\n// extend uniform function with static methods\njStat.extend(jStat.binomial, {\n  pdf: function pdf(k, n, p) {\n    return (p === 0 || p === 1) ?\n      ((n * p) === k ? 1 : 0) :\n      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);\n  },\n\n  cdf: function cdf(x, n, p) {\n    var betacdf;\n    var eps = 1e-10;\n\n    if (x < 0)\n      return 0;\n    if (x >= n)\n      return 1;\n    if (p < 0 || p > 1 || n <= 0)\n      return NaN;\n\n    x = Math.floor(x);\n    var z = p;\n    var a = x + 1;\n    var b = n - x;\n    var s = a + b;\n    var bt = Math.exp(jStat.gammaln(s) - jStat.gammaln(b) -\n                      jStat.gammaln(a) + a * Math.log(z) + b * Math.log(1 - z));\n\n    if (z < (a + 1) / (s + 2))\n      betacdf = bt * betinc(z, a, b, eps);\n    else\n      betacdf = 1 - bt * betinc(1 - z, b, a, eps);\n\n    return Math.round((1 - betacdf) * (1 / eps)) / (1 / eps);\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.negbin, {\n  pdf: function pdf(k, r, p) {\n    if (k !== k >>> 0)\n      return false;\n    if (k < 0)\n      return 0;\n    return jStat.combination(k + r - 1, r - 1) *\n        Math.pow(1 - p, k) * Math.pow(p, r);\n  },\n\n  cdf: function cdf(x, r, p) {\n    var sum = 0,\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sum += jStat.negbin.pdf(k, r, p);\n    }\n    return sum;\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.hypgeom, {\n  pdf: function pdf(k, N, m, n) {\n    // Hypergeometric PDF.\n\n    // A simplification of the CDF algorithm below.\n\n    // k = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(k !== k | 0) {\n      return false;\n    } else if(k < 0 || k < m - (N - n)) {\n      // It's impossible to have this few successes drawn.\n      return 0;\n    } else if(k > n || k > m) {\n      // It's impossible to have this many successes drawn.\n      return 0;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return jStat.hypgeom.pdf(n - k, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return jStat.hypgeom.pdf(m - k, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.pdf(k, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate product to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < k; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledPDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          scaledPDF *= 1 - (m / (N - samplesDone));\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledPDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledPDF));\n    }\n  },\n\n  cdf: function cdf(x, N, m, n) {\n    // Hypergeometric CDF.\n\n    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,\n    // and comes from his hypergeometric test calculator at\n    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.\n\n    // x = number of successes drawn\n    // N = population size\n    // m = number of successes in population\n    // n = number of items drawn from population\n\n    if(x < 0 || x < m - (N - n)) {\n      // It's impossible to have this few successes drawn or fewer.\n      return 0;\n    } else if(x >= n || x >= m) {\n      // We will always have this many successes or fewer.\n      return 1;\n    } else if (m * 2 > N) {\n      // More than half the population is successes.\n\n      if(n * 2 > N) {\n        // More than half the population is sampled.\n\n        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)\n      } else {\n        // Half or less of the population is sampled.\n\n        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);\n      }\n\n    } else if(n * 2 > N) {\n      // Half or less is successes.\n\n      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);\n\n    } else if(m < n) {\n      // We want to have the number of things sampled to be less than the\n      // successes available. So swap the definitions of successful and sampled.\n      return jStat.hypgeom.cdf(x, N, n, m);\n    } else {\n      // If we get here, half or less of the population was sampled, half or\n      // less of it was successes, and we had fewer sampled things than\n      // successes. Now we can do this complicated iterative algorithm in an\n      // efficient way.\n\n      // The basic premise of the algorithm is that we partially normalize our\n      // intermediate sum to keep it in a numerically good region, and then\n      // finish the normalization at the end.\n\n      // Holds the intermediate, scaled total CDF.\n      var scaledCDF = 1;\n\n      // This variable holds the scaled probability of the current number of\n      // successes.\n      var scaledPDF = 1;\n\n      // This keeps track of how much we have normalized.\n      var samplesDone = 0;\n\n      for(var i = 0; i < x; i++) {\n        // For every possible number of successes up to that observed...\n\n        while(scaledCDF > 1 && samplesDone < n) {\n          // Intermediate result is growing too big. Apply some of the\n          // normalization to shrink everything.\n\n          var factor = 1 - (m / (N - samplesDone));\n\n          scaledPDF *= factor;\n          scaledCDF *= factor;\n\n          // Say we've normalized by this sample already.\n          samplesDone++;\n        }\n\n        // Work out the partially-normalized hypergeometric PDF for the next\n        // number of successes\n        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));\n\n        // Add to the CDF answer.\n        scaledCDF += scaledPDF;\n      }\n\n      for(; samplesDone < n; samplesDone++) {\n        // Apply all the rest of the normalization\n        scaledCDF *= 1 - (m / (N - samplesDone));\n      }\n\n      // Bound answer sanely before returning.\n      return Math.min(1, Math.max(0, scaledCDF));\n    }\n  }\n});\n\n\n\n// extend uniform function with static methods\njStat.extend(jStat.poisson, {\n  pdf: function pdf(k, l) {\n    if (l < 0 || (k % 1) !== 0 || k < 0) {\n      return 0;\n    }\n\n    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);\n  },\n\n  cdf: function cdf(x, l) {\n    var sumarr = [],\n    k = 0;\n    if (x < 0) return 0;\n    for (; k <= x; k++) {\n      sumarr.push(jStat.poisson.pdf(k, l));\n    }\n    return jStat.sum(sumarr);\n  },\n\n  mean : function(l) {\n    return l;\n  },\n\n  variance : function(l) {\n    return l;\n  },\n\n  sampleSmall: function sampleSmall(l) {\n    var p = 1, k = 0, L = Math.exp(-l);\n    do {\n      k++;\n      p *= jStat._random_fn();\n    } while (p > L);\n    return k - 1;\n  },\n\n  sampleLarge: function sampleLarge(l) {\n    var lam = l;\n    var k;\n    var U, V, slam, loglam, a, b, invalpha, vr, us;\n\n    slam = Math.sqrt(lam);\n    loglam = Math.log(lam);\n    b = 0.931 + 2.53 * slam;\n    a = -0.059 + 0.02483 * b;\n    invalpha = 1.1239 + 1.1328 / (b - 3.4);\n    vr = 0.9277 - 3.6224 / (b - 2);\n\n    while (1) {\n      U = Math.random() - 0.5;\n      V = Math.random();\n      us = 0.5 - Math.abs(U);\n      k = Math.floor((2 * a / us + b) * U + lam + 0.43);\n      if ((us >= 0.07) && (V <= vr)) {\n          return k;\n      }\n      if ((k < 0) || ((us < 0.013) && (V > us))) {\n          continue;\n      }\n      /* log(V) == log(0.0) ok here */\n      /* if U==0.0 so that us==0.0, log is ok since always returns */\n      if ((Math.log(V) + Math.log(invalpha) - Math.log(a / (us * us) + b)) <= (-lam + k * loglam - jStat.loggam(k + 1))) {\n          return k;\n      }\n    }\n  },\n\n  sample: function sample(l) {\n    if (l < 10)\n      return this.sampleSmall(l);\n    else\n      return this.sampleLarge(l);\n  }\n});\n\n// extend triangular function with static methods\njStat.extend(jStat.triangular, {\n  pdf: function pdf(x, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (x < a || x > b) {\n        return 0;\n      } else if (x < c) {\n          return (2 * (x - a)) / ((b - a) * (c - a));\n      } else if (x === c) {\n          return (2 / (b - a));\n      } else { // x > c\n          return (2 * (b - x)) / ((b - a) * (b - c));\n      }\n    }\n  },\n\n  cdf: function cdf(x, a, b, c) {\n    if (b <= a || c < a || c > b)\n      return NaN;\n    if (x <= a)\n      return 0;\n    else if (x >= b)\n      return 1;\n    if (x <= c)\n      return Math.pow(x - a, 2) / ((b - a) * (c - a));\n    else // x > c\n      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));\n  },\n\n  inv: function inv(p, a, b, c) {\n    if (b <= a || c < a || c > b) {\n      return NaN;\n    } else {\n      if (p <= ((c - a) / (b - a))) {\n        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));\n      } else { // p > ((c - a) / (b - a))\n        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));\n      }\n    }\n  },\n\n  mean: function mean(a, b, c) {\n    return (a + b + c) / 3;\n  },\n\n  median: function median(a, b, c) {\n    if (c <= (a + b) / 2) {\n      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);\n    } else if (c > (a + b) / 2) {\n      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);\n    }\n  },\n\n  mode: function mode(a, b, c) {\n    return c;\n  },\n\n  sample: function sample(a, b, c) {\n    var u = jStat._random_fn();\n    if (u < ((c - a) / (b - a)))\n      return a + Math.sqrt(u * (b - a) * (c - a))\n    return b - Math.sqrt((1 - u) * (b - a) * (b - c));\n  },\n\n  variance: function variance(a, b, c) {\n    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;\n  }\n});\n\n\n// extend arcsine function with static methods\njStat.extend(jStat.arcsine, {\n  pdf: function pdf(x, a, b) {\n    if (b <= a) return NaN;\n\n    return (x <= a || x >= b) ? 0 :\n      (2 / Math.PI) *\n        Math.pow(Math.pow(b - a, 2) -\n                  Math.pow(2 * x - a - b, 2), -0.5);\n  },\n\n  cdf: function cdf(x, a, b) {\n    if (x < a)\n      return 0;\n    else if (x < b)\n      return (2 / Math.PI) * Math.asin(Math.sqrt((x - a)/(b - a)));\n    return 1;\n  },\n\n  inv: function(p, a, b) {\n    return a + (0.5 - 0.5 * Math.cos(Math.PI * p)) * (b - a);\n  },\n\n  mean: function mean(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  median: function median(a, b) {\n    if (b <= a) return NaN;\n    return (a + b) / 2;\n  },\n\n  mode: function mode(/*a, b*/) {\n    throw new Error('mode is not yet implemented');\n  },\n\n  sample: function sample(a, b) {\n    return ((a + b) / 2) + ((b - a) / 2) *\n      Math.sin(2 * Math.PI * jStat.uniform.sample(0, 1));\n  },\n\n  variance: function variance(a, b) {\n    if (b <= a) return NaN;\n    return Math.pow(b - a, 2) / 8;\n  }\n});\n\n\nfunction laplaceSign(x) { return x / Math.abs(x); }\n\njStat.extend(jStat.laplace, {\n  pdf: function pdf(x, mu, b) {\n    return (b <= 0) ? 0 : (Math.exp(-Math.abs(x - mu) / b)) / (2 * b);\n  },\n\n  cdf: function cdf(x, mu, b) {\n    if (b <= 0) { return 0; }\n\n    if(x < mu) {\n      return 0.5 * Math.exp((x - mu) / b);\n    } else {\n      return 1 - 0.5 * Math.exp(- (x - mu) / b);\n    }\n  },\n\n  mean: function(mu/*, b*/) {\n    return mu;\n  },\n\n  median: function(mu/*, b*/) {\n    return mu;\n  },\n\n  mode: function(mu/*, b*/) {\n    return mu;\n  },\n\n  variance: function(mu, b) {\n    return 2 * b * b;\n  },\n\n  sample: function sample(mu, b) {\n    var u = jStat._random_fn() - 0.5;\n\n    return mu - (b * laplaceSign(u) * Math.log(1 - (2 * Math.abs(u))));\n  }\n});\n\nfunction tukeyWprob(w, rr, cc) {\n  var nleg = 12;\n  var ihalf = 6;\n\n  var C1 = -30;\n  var C2 = -50;\n  var C3 = 60;\n  var bb   = 8;\n  var wlar = 3;\n  var wincr1 = 2;\n  var wincr2 = 3;\n  var xleg = [\n    0.981560634246719250690549090149,\n    0.904117256370474856678465866119,\n    0.769902674194304687036893833213,\n    0.587317954286617447296702418941,\n    0.367831498998180193752691536644,\n    0.125233408511468915472441369464\n  ];\n  var aleg = [\n    0.047175336386511827194615961485,\n    0.106939325995318430960254718194,\n    0.160078328543346226334652529543,\n    0.203167426723065921749064455810,\n    0.233492536538354808760849898925,\n    0.249147045813402785000562436043\n  ];\n\n  var qsqz = w * 0.5;\n\n  // if w >= 16 then the integral lower bound (occurs for c=20)\n  // is 0.99999999999995 so return a value of 1.\n\n  if (qsqz >= bb)\n    return 1.0;\n\n  // find (f(w/2) - 1) ^ cc\n  // (first term in integral of hartley's form).\n\n  var pr_w = 2 * jStat.normal.cdf(qsqz, 0, 1, 1, 0) - 1; // erf(qsqz / M_SQRT2)\n  // if pr_w ^ cc < 2e-22 then set pr_w = 0\n  if (pr_w >= Math.exp(C2 / cc))\n    pr_w = Math.pow(pr_w, cc);\n  else\n    pr_w = 0.0;\n\n  // if w is large then the second component of the\n  // integral is small, so fewer intervals are needed.\n\n  var wincr;\n  if (w > wlar)\n    wincr = wincr1;\n  else\n    wincr = wincr2;\n\n  // find the integral of second term of hartley's form\n  // for the integral of the range for equal-length\n  // intervals using legendre quadrature.  limits of\n  // integration are from (w/2, 8).  two or three\n  // equal-length intervals are used.\n\n  // blb and bub are lower and upper limits of integration.\n\n  var blb = qsqz;\n  var binc = (bb - qsqz) / wincr;\n  var bub = blb + binc;\n  var einsum = 0.0;\n\n  // integrate over each interval\n\n  var cc1 = cc - 1.0;\n  for (var wi = 1; wi <= wincr; wi++) {\n    var elsum = 0.0;\n    var a = 0.5 * (bub + blb);\n\n    // legendre quadrature with order = nleg\n\n    var b = 0.5 * (bub - blb);\n\n    for (var jj = 1; jj <= nleg; jj++) {\n      var j, xx;\n      if (ihalf < jj) {\n        j = (nleg - jj) + 1;\n        xx = xleg[j-1];\n      } else {\n        j = jj;\n        xx = -xleg[j-1];\n      }\n      var c = b * xx;\n      var ac = a + c;\n\n      // if exp(-qexpo/2) < 9e-14,\n      // then doesn't contribute to integral\n\n      var qexpo = ac * ac;\n      if (qexpo > C3)\n        break;\n\n      var pplus = 2 * jStat.normal.cdf(ac, 0, 1, 1, 0);\n      var pminus= 2 * jStat.normal.cdf(ac, w, 1, 1, 0);\n\n      // if rinsum ^ (cc-1) < 9e-14,\n      // then doesn't contribute to integral\n\n      var rinsum = (pplus * 0.5) - (pminus * 0.5);\n      if (rinsum >= Math.exp(C1 / cc1)) {\n        rinsum = (aleg[j-1] * Math.exp(-(0.5 * qexpo))) * Math.pow(rinsum, cc1);\n        elsum += rinsum;\n      }\n    }\n    elsum *= (((2.0 * b) * cc) / Math.sqrt(2 * Math.PI));\n    einsum += elsum;\n    blb = bub;\n    bub += binc;\n  }\n\n  // if pr_w ^ rr < 9e-14, then return 0\n  pr_w += einsum;\n  if (pr_w <= Math.exp(C1 / rr))\n    return 0;\n\n  pr_w = Math.pow(pr_w, rr);\n  if (pr_w >= 1) // 1 was iMax was eps\n    return 1;\n  return pr_w;\n}\n\nfunction tukeyQinv(p, c, v) {\n  var p0 = 0.322232421088;\n  var q0 = 0.993484626060e-01;\n  var p1 = -1.0;\n  var q1 = 0.588581570495;\n  var p2 = -0.342242088547;\n  var q2 = 0.531103462366;\n  var p3 = -0.204231210125;\n  var q3 = 0.103537752850;\n  var p4 = -0.453642210148e-04;\n  var q4 = 0.38560700634e-02;\n  var c1 = 0.8832;\n  var c2 = 0.2368;\n  var c3 = 1.214;\n  var c4 = 1.208;\n  var c5 = 1.4142;\n  var vmax = 120.0;\n\n  var ps = 0.5 - 0.5 * p;\n  var yi = Math.sqrt(Math.log(1.0 / (ps * ps)));\n  var t = yi + (((( yi * p4 + p3) * yi + p2) * yi + p1) * yi + p0)\n     / (((( yi * q4 + q3) * yi + q2) * yi + q1) * yi + q0);\n  if (v < vmax) t += (t * t * t + t) / v / 4.0;\n  var q = c1 - c2 * t;\n  if (v < vmax) q += -c3 / v + c4 * t / v;\n  return t * (q * Math.log(c - 1.0) + c5);\n}\n\njStat.extend(jStat.tukey, {\n  cdf: function cdf(q, nmeans, df) {\n    // Identical implementation as the R ptukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var nlegq = 16;\n    var ihalfq = 8;\n\n    var eps1 = -30.0;\n    var eps2 = 1.0e-14;\n    var dhaf  = 100.0;\n    var dquar = 800.0;\n    var deigh = 5000.0;\n    var dlarg = 25000.0;\n    var ulen1 = 1.0;\n    var ulen2 = 0.5;\n    var ulen3 = 0.25;\n    var ulen4 = 0.125;\n    var xlegq = [\n      0.989400934991649932596154173450,\n      0.944575023073232576077988415535,\n      0.865631202387831743880467897712,\n      0.755404408355003033895101194847,\n      0.617876244402643748446671764049,\n      0.458016777657227386342419442984,\n      0.281603550779258913230460501460,\n      0.950125098376374401853193354250e-1\n    ];\n    var alegq = [\n      0.271524594117540948517805724560e-1,\n      0.622535239386478928628438369944e-1,\n      0.951585116824927848099251076022e-1,\n      0.124628971255533872052476282192,\n      0.149595988816576732081501730547,\n      0.169156519395002538189312079030,\n      0.182603415044923588866763667969,\n      0.189450610455068496285396723208\n    ];\n\n    if (q <= 0)\n      return 0;\n\n    // df must be > 1\n    // there must be at least two values\n\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (!Number.isFinite(q))\n      return 1;\n\n    if (df > dlarg)\n      return tukeyWprob(q, rr, cc);\n\n    // calculate leading constant\n\n    var f2 = df * 0.5;\n    var f2lf = ((f2 * Math.log(df)) - (df * Math.log(2))) - jStat.gammaln(f2);\n    var f21 = f2 - 1.0;\n\n    // integral is divided into unit, half-unit, quarter-unit, or\n    // eighth-unit length intervals depending on the value of the\n    // degrees of freedom.\n\n    var ff4 = df * 0.25;\n    var ulen;\n    if      (df <= dhaf)  ulen = ulen1;\n    else if (df <= dquar) ulen = ulen2;\n    else if (df <= deigh) ulen = ulen3;\n    else                  ulen = ulen4;\n\n    f2lf += Math.log(ulen);\n\n    // integrate over each subinterval\n\n    var ans = 0.0;\n\n    for (var i = 1; i <= 50; i++) {\n      var otsum = 0.0;\n\n      // legendre quadrature with order = nlegq\n      // nodes (stored in xlegq) are symmetric around zero.\n\n      var twa1 = (2 * i - 1) * ulen;\n\n      for (var jj = 1; jj <= nlegq; jj++) {\n        var j, t1;\n        if (ihalfq < jj) {\n          j = jj - ihalfq - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 + (xlegq[j] * ulen))))\n              - (((xlegq[j] * ulen) + twa1) * ff4);\n        } else {\n          j = jj - 1;\n          t1 = (f2lf + (f21 * Math.log(twa1 - (xlegq[j] * ulen))))\n              + (((xlegq[j] * ulen) - twa1) * ff4);\n        }\n\n        // if exp(t1) < 9e-14, then doesn't contribute to integral\n        var qsqz;\n        if (t1 >= eps1) {\n          if (ihalfq < jj) {\n            qsqz = q * Math.sqrt(((xlegq[j] * ulen) + twa1) * 0.5);\n          } else {\n            qsqz = q * Math.sqrt(((-(xlegq[j] * ulen)) + twa1) * 0.5);\n          }\n\n          // call wprob to find integral of range portion\n\n          var wprb = tukeyWprob(qsqz, rr, cc);\n          var rotsum = (wprb * alegq[j]) * Math.exp(t1);\n          otsum += rotsum;\n        }\n        // end legendre integral for interval i\n        // L200:\n      }\n\n      // if integral for interval i < 1e-14, then stop.\n      // However, in order to avoid small area under left tail,\n      // at least  1 / ulen  intervals are calculated.\n      if (i * ulen >= 1.0 && otsum <= eps2)\n        break;\n\n      // end of interval i\n      // L330:\n\n      ans += otsum;\n    }\n\n    if (otsum > eps2) { // not converged\n      throw new Error('tukey.cdf failed to converge');\n    }\n    if (ans > 1)\n      ans = 1;\n    return ans;\n  },\n\n  inv: function(p, nmeans, df) {\n    // Identical implementation as the R qtukey() function as of commit 68947\n    var rr = 1;\n    var cc = nmeans;\n\n    var eps = 0.0001;\n    var maxiter = 50;\n\n    // df must be > 1 ; there must be at least two values\n    if (df < 2 || rr < 1 || cc < 2) return NaN;\n\n    if (p < 0 || p > 1) return NaN;\n    if (p === 0) return 0;\n    if (p === 1) return Infinity;\n\n    // Initial value\n\n    var x0 = tukeyQinv(p, cc, df);\n\n    // Find prob(value < x0)\n\n    var valx0 = jStat.tukey.cdf(x0, nmeans, df) - p;\n\n    // Find the second iterate and prob(value < x1).\n    // If the first iterate has probability value\n    // exceeding p then second iterate is 1 less than\n    // first iterate; otherwise it is 1 greater.\n\n    var x1;\n    if (valx0 > 0.0)\n      x1 = Math.max(0.0, x0 - 1.0);\n    else\n      x1 = x0 + 1.0;\n    var valx1 = jStat.tukey.cdf(x1, nmeans, df) - p;\n\n    // Find new iterate\n\n    var ans;\n    for(var iter = 1; iter < maxiter; iter++) {\n      ans = x1 - ((valx1 * (x1 - x0)) / (valx1 - valx0));\n      valx0 = valx1;\n\n      // New iterate must be >= 0\n\n      x0 = x1;\n      if (ans < 0.0) {\n        ans = 0.0;\n        valx1 = -p;\n      }\n      // Find prob(value < new iterate)\n\n      valx1 = jStat.tukey.cdf(ans, nmeans, df) - p;\n      x1 = ans;\n\n      // If the difference between two successive\n      // iterates is less than eps, stop\n\n      var xabs = Math.abs(x1 - x0);\n      if (xabs < eps)\n        return ans;\n    }\n\n    throw new Error('tukey.inv failed to converge');\n  }\n});\n\n}(jStat, Math));\n/* Provides functions for the solution of linear system of equations, integration, extrapolation,\n * interpolation, eigenvalue problems, differential equations and PCA analysis. */\n\n(function(jStat, Math) {\n\nvar push = Array.prototype.push;\nvar isArray = jStat.utils.isArray;\n\nfunction isUsable(arg) {\n  return isArray(arg) || arg instanceof jStat;\n}\n\njStat.extend({\n\n  // add a vector/matrix to a vector/matrix or scalar\n  add: function add(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value + arg[row][col];\n      });\n    }\n    return jStat.map(arr, function(value) { return value + arg; });\n  },\n\n  // subtract a vector or scalar from the vector\n  subtract: function subtract(arr, arg) {\n    // check if arg is a vector or scalar\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.map(arr, function(value, row, col) {\n        return value - arg[row][col] || 0;\n      });\n    }\n    return jStat.map(arr, function(value) { return value - arg; });\n  },\n\n  // matrix division\n  divide: function divide(arr, arg) {\n    if (isUsable(arg)) {\n      if (!isUsable(arg[0])) arg = [ arg ];\n      return jStat.multiply(arr, jStat.inv(arg));\n    }\n    return jStat.map(arr, function(value) { return value / arg; });\n  },\n\n  // matrix multiplication\n  multiply: function multiply(arr, arg) {\n    var row, col, nrescols, sum, nrow, ncol, res, rescols;\n    // eg: arr = 2 arg = 3 -> 6 for res[0][0] statement closure\n    if (arr.length === undefined && arg.length === undefined) {\n      return arr * arg;\n    }\n    nrow = arr.length,\n    ncol = arr[0].length,\n    res = jStat.zeros(nrow, nrescols = (isUsable(arg)) ? arg[0].length : ncol),\n    rescols = 0;\n    if (isUsable(arg)) {\n      for (; rescols < nrescols; rescols++) {\n        for (row = 0; row < nrow; row++) {\n          sum = 0;\n          for (col = 0; col < ncol; col++)\n          sum += arr[row][col] * arg[col][rescols];\n          res[row][rescols] = sum;\n        }\n      }\n      return (nrow === 1 && rescols === 1) ? res[0][0] : res;\n    }\n    return jStat.map(arr, function(value) { return value * arg; });\n  },\n\n  // outer([1,2,3],[4,5,6])\n  // ===\n  // [[1],[2],[3]] times [[4,5,6]]\n  // ->\n  // [[4,5,6],[8,10,12],[12,15,18]]\n  outer:function outer(A, B) {\n    return jStat.multiply(A.map(function(t){ return [t] }), [B]);\n  },\n\n\n  // Returns the dot product of two matricies\n  dot: function dot(arr, arg) {\n    if (!isUsable(arr[0])) arr = [ arr ];\n    if (!isUsable(arg[0])) arg = [ arg ];\n    // convert column to row vector\n    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,\n    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,\n    res = [],\n    row = 0,\n    nrow = left.length,\n    ncol = left[0].length,\n    sum, col;\n    for (; row < nrow; row++) {\n      res[row] = [];\n      sum = 0;\n      for (col = 0; col < ncol; col++)\n      sum += left[row][col] * right[row][col];\n      res[row] = sum;\n    }\n    return (res.length === 1) ? res[0] : res;\n  },\n\n  // raise every element by a scalar\n  pow: function pow(arr, arg) {\n    return jStat.map(arr, function(value) { return Math.pow(value, arg); });\n  },\n\n  // exponentiate every element\n  exp: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.exp(value); });\n  },\n\n  // generate the natural log of every element\n  log: function exp(arr) {\n    return jStat.map(arr, function(value) { return Math.log(value); });\n  },\n\n  // generate the absolute values of the vector\n  abs: function abs(arr) {\n    return jStat.map(arr, function(value) { return Math.abs(value); });\n  },\n\n  // computes the p-norm of the vector\n  // In the case that a matrix is passed, uses the first row as the vector\n  norm: function norm(arr, p) {\n    var nnorm = 0,\n    i = 0;\n    // check the p-value of the norm, and set for most common case\n    if (isNaN(p)) p = 2;\n    // check if multi-dimensional array, and make vector correction\n    if (isUsable(arr[0])) arr = arr[0];\n    // vector norm\n    for (; i < arr.length; i++) {\n      nnorm += Math.pow(Math.abs(arr[i]), p);\n    }\n    return Math.pow(nnorm, 1 / p);\n  },\n\n  // computes the angle between two vectors in rads\n  // In case a matrix is passed, this uses the first row as the vector\n  angle: function angle(arr, arg) {\n    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));\n  },\n\n  // augment one matrix by another\n  // Note: this function returns a matrix, not a jStat object\n  aug: function aug(a, b) {\n    var newarr = [];\n    var i;\n    for (i = 0; i < a.length; i++) {\n      newarr.push(a[i].slice());\n    }\n    for (i = 0; i < newarr.length; i++) {\n      push.apply(newarr[i], b[i]);\n    }\n    return newarr;\n  },\n\n  // The inv() function calculates the inverse of a matrix\n  // Create the inverse by augmenting the matrix by the identity matrix of the\n  // appropriate size, and then use G-J elimination on the augmented matrix.\n  inv: function inv(a) {\n    var rows = a.length;\n    var cols = a[0].length;\n    var b = jStat.identity(rows, cols);\n    var c = jStat.gauss_jordan(a, b);\n    var result = [];\n    var i = 0;\n    var j;\n\n    //We need to copy the inverse portion to a new matrix to rid G-J artifacts\n    for (; i < rows; i++) {\n      result[i] = [];\n      for (j = cols; j < c[0].length; j++)\n        result[i][j - cols] = c[i][j];\n    }\n    return result;\n  },\n\n  // calculate the determinant of a matrix\n  det: function det(a) {\n    if (a.length === 2) {\n      return a[0][0] * a[1][1] - a[0][1] * a[1][0];\n    }\n\n    var determinant = 0;\n    for (var i = 0; i < a.length; i++) {\n      // build a sub matrix without column `i`\n      var submatrix = [];\n      for (var row = 1; row < a.length; row++) {\n        submatrix[row - 1] = [];\n        for (var col = 0; col < a.length; col++) {\n          if (col < i) {\n            submatrix[row - 1][col] = a[row][col];\n          } else if (col > i) {\n            submatrix[row - 1][col - 1] = a[row][col];\n          }\n        }\n      }\n\n      // alternate between + and - between determinants\n      var sign = i % 2 ? -1 : 1;\n      determinant += det(submatrix) * a[0][i] * sign;\n    }\n\n    return determinant\n  },\n\n  gauss_elimination: function gauss_elimination(a, b) {\n    var i = 0,\n    j = 0,\n    n = a.length,\n    m = a[0].length,\n    factor = 1,\n    sum = 0,\n    x = [],\n    maug, pivot, temp, k;\n    a = jStat.aug(a, b);\n    maug = a[0].length;\n    for(i = 0; i < n; i++) {\n      pivot = a[i][i];\n      j = i;\n      for (k = i + 1; k < m; k++) {\n        if (pivot < Math.abs(a[k][i])) {\n          pivot = a[k][i];\n          j = k;\n        }\n      }\n      if (j != i) {\n        for(k = 0; k < maug; k++) {\n          temp = a[i][k];\n          a[i][k] = a[j][k];\n          a[j][k] = temp;\n        }\n      }\n      for (j = i + 1; j < n; j++) {\n        factor = a[j][i] / a[i][i];\n        for(k = i; k < maug; k++) {\n          a[j][k] = a[j][k] - factor * a[i][k];\n        }\n      }\n    }\n    for (i = n - 1; i >= 0; i--) {\n      sum = 0;\n      for (j = i + 1; j<= n - 1; j++) {\n        sum = sum + x[j] * a[i][j];\n      }\n      x[i] =(a[i][maug - 1] - sum) / a[i][i];\n    }\n    return x;\n  },\n\n  gauss_jordan: function gauss_jordan(a, b) {\n    var m = jStat.aug(a, b);\n    var h = m.length;\n    var w = m[0].length;\n    var c = 0;\n    var x, y, y2;\n    // find max pivot\n    for (y = 0; y < h; y++) {\n      var maxrow = y;\n      for (y2 = y+1; y2 < h; y2++) {\n        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))\n          maxrow = y2;\n      }\n      var tmp = m[y];\n      m[y] = m[maxrow];\n      m[maxrow] = tmp\n      for (y2 = y+1; y2 < h; y2++) {\n        c = m[y2][y] / m[y][y];\n        for (x = y; x < w; x++) {\n          m[y2][x] -= m[y][x] * c;\n        }\n      }\n    }\n    // backsubstitute\n    for (y = h-1; y >= 0; y--) {\n      c = m[y][y];\n      for (y2 = 0; y2 < y; y2++) {\n        for (x = w-1; x > y-1; x--) {\n          m[y2][x] -= m[y][x] * m[y2][y] / c;\n        }\n      }\n      m[y][y] /= c;\n      for (x = h; x < w; x++) {\n        m[y][x] /= c;\n      }\n    }\n    return m;\n  },\n\n  // solve equation\n  // Ax=b\n  // A is upper triangular matrix\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[1,2,3]\n  // triaUpSolve(A,b) // -> [2.666,0.1666,1.666]\n  // if you use matrix style\n  // A=[[1,2,3],[0,4,5],[0,6,7]]\n  // b=[[1],[2],[3]]\n  // will return [[2.666],[0.1666],[1.666]]\n  triaUpSolve: function triaUpSolve(A, b) {\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n    var matrix_mode = false;\n\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size - 1, -1, -1).forEach(function(i) {\n      parts = jStat.arange(i + 1, size).map(function(j) {\n        return x[j] * A[i][j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    });\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n  triaLowSolve: function triaLowSolve(A, b) {\n    // like to triaUpSolve but A is lower triangular matrix\n    var size = A[0].length;\n    var x = jStat.zeros(1, size)[0];\n    var parts;\n\n    var matrix_mode=false;\n    if (b[0].length != undefined) {\n      b = b.map(function(i){ return i[0] });\n      matrix_mode = true;\n    }\n\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(j) {\n        return A[i][j] * x[j];\n      });\n      x[i] = (b[i] - jStat.sum(parts)) / A[i][i];\n    })\n\n    if (matrix_mode)\n      return x.map(function(i){ return [i] });\n    return x;\n  },\n\n\n  // A -> [L,U]\n  // A=LU\n  // L is lower triangular matrix\n  // U is upper triangular matrix\n  lu: function lu(A) {\n    var size = A.length;\n    //var L=jStat.diagonal(jStat.ones(1,size)[0]);\n    var L = jStat.identity(size);\n    var R = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(t) {\n      R[0][t] = A[0][t];\n    });\n    jStat.arange(1, size).forEach(function(l) {\n      jStat.arange(l).forEach(function(i) {\n        parts = jStat.arange(i).map(function(jj) {\n          return L[l][jj] * R[jj][i];\n        });\n        L[l][i] = (A[l][i] - jStat.sum(parts)) / R[i][i];\n      });\n      jStat.arange(l, size).forEach(function(j) {\n        parts = jStat.arange(l).map(function(jj) {\n          return L[l][jj] * R[jj][j];\n        });\n        R[l][j] = A[parts.length][j] - jStat.sum(parts);\n      });\n    });\n    return [L, R];\n  },\n\n  // A -> T\n  // A=TT'\n  // T is lower triangular matrix\n  cholesky: function cholesky(A) {\n    var size = A.length;\n    var T = jStat.zeros(A.length, A[0].length);\n    var parts;\n    jStat.arange(size).forEach(function(i) {\n      parts = jStat.arange(i).map(function(t) {\n        return Math.pow(T[i][t],2);\n      });\n      T[i][i] = Math.sqrt(A[i][i] - jStat.sum(parts));\n      jStat.arange(i + 1, size).forEach(function(j) {\n        parts = jStat.arange(i).map(function(t) {\n          return T[i][t] * T[j][t];\n        });\n        T[j][i] = (A[i][j] - jStat.sum(parts)) / T[i][i];\n      });\n    });\n    return T;\n  },\n\n\n  gauss_jacobi: function gauss_jacobi(a, b, x, r) {\n    var i = 0;\n    var j = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);\n    c = jStat.multiply(jStat.inv(d), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  gauss_seidel: function gauss_seidel(a, b, x, r) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);\n    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i = i + 1;\n    }\n    return xk;\n  },\n\n  SOR: function SOR(a, b, x, r, w) {\n    var i = 0;\n    var n = a.length;\n    var l = [];\n    var u = [];\n    var d = [];\n    var j, xv, c, h, xk;\n    for (; i < n; i++) {\n      l[i] = [];\n      u[i] = [];\n      d[i] = [];\n      for (j = 0; j < n; j++) {\n        if (i > j) {\n          l[i][j] = a[i][j];\n          u[i][j] = d[i][j] = 0;\n        } else if (i < j) {\n          u[i][j] = a[i][j];\n          l[i][j] = d[i][j] = 0;\n        } else {\n          d[i][j] = a[i][j];\n          l[i][j] = u[i][j] = 0;\n        }\n      }\n    }\n    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),\n                       jStat.subtract(jStat.multiply(d, 1 - w),\n                                      jStat.multiply(u, w)));\n    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,\n        jStat.multiply(l, w))), b), w);\n    xv = x;\n    xk = jStat.add(jStat.multiply(h, x), c);\n    i = 2;\n    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {\n      xv = xk;\n      xk = jStat.add(jStat.multiply(h, xv), c);\n      i++;\n    }\n    return xk;\n  },\n\n  householder: function householder(a) {\n    var m = a.length;\n    var n = a[0].length;\n    var i = 0;\n    var w = [];\n    var p = [];\n    var alpha, r, k, j, factor;\n    for (; i < m - 1; i++) {\n      alpha = 0;\n      for (j = i + 1; j < n; j++)\n      alpha += (a[j][i] * a[j][i]);\n      factor = (a[i + 1][i] > 0) ? -1 : 1;\n      alpha = factor * Math.sqrt(alpha);\n      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));\n      w = jStat.zeros(m, 1);\n      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);\n      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);\n      p = jStat.subtract(jStat.identity(m, n),\n          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));\n      a = jStat.multiply(p, jStat.multiply(a, p));\n    }\n    return a;\n  },\n\n  // A -> [Q,R]\n  // Q is orthogonal matrix\n  // R is upper triangular\n  QR: (function() {\n    // x -> Q\n    // find a orthogonal matrix Q st.\n    // Qx=y\n    // y is [||x||,0,0,...]\n\n    // quick ref\n    var sum   = jStat.sum;\n    var range = jStat.arange;\n\n    function qr2(x) {\n      // quick impletation\n      // https://www.stat.wisc.edu/~larget/math496/qr.html\n\n      var n = x.length;\n      var p = x[0].length;\n\n      var r = jStat.zeros(p, p);\n      x = jStat.copy(x);\n\n      var i,j,k;\n      for(j = 0; j < p; j++){\n        r[j][j] = Math.sqrt(sum(range(n).map(function(i){\n          return x[i][j] * x[i][j];\n        })));\n        for(i = 0; i < n; i++){\n          x[i][j] = x[i][j] / r[j][j];\n        }\n        for(k = j+1; k < p; k++){\n          r[j][k] = sum(range(n).map(function(i){\n            return x[i][j] * x[i][k];\n          }));\n          for(i = 0; i < n; i++){\n            x[i][k] = x[i][k] - x[i][j]*r[j][k];\n          }\n        }\n      }\n      return [x, r];\n    }\n\n    return qr2;\n  }()),\n\n  lstsq: (function() {\n    // solve least squard problem for Ax=b as QR decomposition way if b is\n    // [[b1],[b2],[b3]] form will return [[x1],[x2],[x3]] array form solution\n    // else b is [b1,b2,b3] form will return [x1,x2,x3] array form solution\n    function R_I(A) {\n      A = jStat.copy(A);\n      var size = A.length;\n      var I = jStat.identity(size);\n      jStat.arange(size - 1, -1, -1).forEach(function(i) {\n        jStat.sliceAssign(\n            I, { row: i }, jStat.divide(jStat.slice(I, { row: i }), A[i][i]));\n        jStat.sliceAssign(\n            A, { row: i }, jStat.divide(jStat.slice(A, { row: i }), A[i][i]));\n        jStat.arange(i).forEach(function(j) {\n          var c = jStat.multiply(A[j][i], -1);\n          var Aj = jStat.slice(A, { row: j });\n          var cAi = jStat.multiply(jStat.slice(A, { row: i }), c);\n          jStat.sliceAssign(A, { row: j }, jStat.add(Aj, cAi));\n          var Ij = jStat.slice(I, { row: j });\n          var cIi = jStat.multiply(jStat.slice(I, { row: i }), c);\n          jStat.sliceAssign(I, { row: j }, jStat.add(Ij, cIi));\n        })\n      });\n      return I;\n    }\n\n    function qr_solve(A, b){\n      var array_mode = false;\n      if (b[0].length === undefined) {\n        // [c1,c2,c3] mode\n        b = b.map(function(x){ return [x] });\n        array_mode = true;\n      }\n      var QR = jStat.QR(A);\n      var Q = QR[0];\n      var R = QR[1];\n      var attrs = A[0].length;\n      var Q1 = jStat.slice(Q,{col:{end:attrs}});\n      var R1 = jStat.slice(R,{row:{end:attrs}});\n      var RI = R_I(R1);\n      var Q2 = jStat.transpose(Q1);\n\n      if(Q2[0].length === undefined){\n        Q2 = [Q2]; // The confusing jStat.multifly implementation threat nature process again.\n      }\n\n      var x = jStat.multiply(jStat.multiply(RI, Q2), b);\n\n      if(x.length === undefined){\n        x = [[x]]; // The confusing jStat.multifly implementation threat nature process again.\n      }\n\n\n      if (array_mode)\n        return x.map(function(i){ return i[0] });\n      return x;\n    }\n\n    return qr_solve;\n  }()),\n\n  jacobi: function jacobi(a) {\n    var condition = 1;\n    var n = a.length;\n    var e = jStat.identity(n, n);\n    var ev = [];\n    var b, i, j, p, q, maxim, theta, s;\n    // condition === 1 only if tolerance is not reached\n    while (condition === 1) {\n      maxim = a[0][1];\n      p = 0;\n      q = 1;\n      for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          if (i != j) {\n            if (maxim < Math.abs(a[i][j])) {\n              maxim = Math.abs(a[i][j]);\n              p = i;\n              q = j;\n            }\n          }\n        }\n      }\n      if (a[p][p] === a[q][q])\n        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;\n      else\n        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;\n      s = jStat.identity(n, n);\n      s[p][p] = Math.cos(theta);\n      s[p][q] = -Math.sin(theta);\n      s[q][p] = Math.sin(theta);\n      s[q][q] = Math.cos(theta);\n      // eigen vector matrix\n      e = jStat.multiply(e, s);\n      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);\n      a = b;\n      condition = 0;\n      for (i = 1; i < n; i++) {\n        for (j = 1; j < n; j++) {\n          if (i != j && Math.abs(a[i][j]) > 0.001) {\n            condition = 1;\n          }\n        }\n      }\n    }\n    for (i = 0; i < n; i++) ev.push(a[i][i]);\n    //returns both the eigenvalue and eigenmatrix\n    return [e, ev];\n  },\n\n  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {\n    var k1, k2, u_j1, k3, k4;\n    if (order === 2) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h, u_j + k1);\n        u_j1 = u_j + (k1 + k2) / 2;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    if (order === 4) {\n      while (t_j <= p) {\n        k1 = h * f(t_j, u_j);\n        k2 = h * f(t_j + h / 2, u_j + k1 / 2);\n        k3 = h * f(t_j + h / 2, u_j + k2 / 2);\n        k4 = h * f(t_j +h, u_j + k3);\n        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;\n        u_j = u_j1;\n        t_j = t_j + h;\n      }\n    }\n    return u_j;\n  },\n\n  romberg: function romberg(f, a, b, order) {\n    var i = 0;\n    var h = (b - a) / 2;\n    var x = [];\n    var h1 = [];\n    var g = [];\n    var m, a1, j, k, I;\n    while (i < order / 2) {\n      I = f(a);\n      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;\n      m = x.length;\n      for (j = 1; j < m - 1; j++) {\n        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);\n      }\n      I = (h / 3) * (I + f(b));\n      g[i] = I;\n      h /= 2;\n      i++;\n    }\n    a1 = g.length;\n    m = 1;\n    while (a1 !== 1) {\n      for (j = 0; j < a1 - 1; j++)\n      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a1 = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  richardson: function richardson(X, f, x, h) {\n    function pos(X, x) {\n      var i = 0;\n      var n = X.length;\n      var p;\n      for (; i < n; i++)\n        if (X[i] === x) p = i;\n      return p;\n    }\n    var h_min = Math.abs(x - X[pos(X, x) + 1]);\n    var i = 0;\n    var g = [];\n    var h1 = [];\n    var y1, y2, m, a, j;\n    while (h >= h_min) {\n      y1 = pos(X, x + h);\n      y2 = pos(X, x);\n      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);\n      h /= 2;\n      i++;\n    }\n    a = g.length;\n    m = 1;\n    while (a != 1) {\n      for (j = 0; j < a - 1; j++)\n        h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);\n      a = h1.length;\n      g = h1;\n      h1 = [];\n      m++;\n    }\n    return g;\n  },\n\n  simpson: function simpson(f, a, b, n) {\n    var h = (b - a) / n;\n    var I = f(a);\n    var x = [];\n    var j = a;\n    var k = 0;\n    var i = 1;\n    var m;\n    for (; j <= b; j = j + h, k++)\n      x[k] = j;\n    m = x.length;\n    for (; i < m - 1; i++) {\n      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);\n    }\n    return (h / 3) * (I + f(b));\n  },\n\n  hermite: function hermite(X, F, dF, value) {\n    var n = X.length;\n    var p = 0;\n    var i = 0;\n    var l = [];\n    var dl = [];\n    var A = [];\n    var B = [];\n    var j;\n    for (; i < n; i++) {\n      l[i] = 1;\n      for (j = 0; j < n; j++) {\n        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);\n      }\n      dl[i] = 0;\n      for (j = 0; j < n; j++) {\n        if (i != j) dl[i] += 1 / (X [i] - X[j]);\n      }\n      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);\n      B[i] = (value - X[i]) * (l[i] * l[i]);\n      p += (A[i] * F[i] + B[i] * dF[i]);\n    }\n    return p;\n  },\n\n  lagrange: function lagrange(X, F, value) {\n    var p = 0;\n    var i = 0;\n    var j, l;\n    var n = X.length;\n    for (; i < n; i++) {\n      l = F[i];\n      for (j = 0; j < n; j++) {\n        // calculating the lagrange polynomial L_i\n        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);\n      }\n      // adding the lagrange polynomials found above\n      p += l;\n    }\n    return p;\n  },\n\n  cubic_spline: function cubic_spline(X, F, value) {\n    var n = X.length;\n    var i = 0, j;\n    var A = [];\n    var B = [];\n    var alpha = [];\n    var c = [];\n    var h = [];\n    var b = [];\n    var d = [];\n    for (; i < n - 1; i++)\n      h[i] = X[i + 1] - X[i];\n    alpha[0] = 0;\n    for (i = 1; i < n - 1; i++) {\n      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -\n          (3 / h[i-1]) * (F[i] - F[i-1]);\n    }\n    for (i = 1; i < n - 1; i++) {\n      A[i] = [];\n      B[i] = [];\n      A[i][i-1] = h[i-1];\n      A[i][i] = 2 * (h[i - 1] + h[i]);\n      A[i][i+1] = h[i];\n      B[i][0] = alpha[i];\n    }\n    c = jStat.multiply(jStat.inv(A), B);\n    for (j = 0; j < n - 1; j++) {\n      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;\n      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);\n    }\n    for (j = 0; j < n; j++) {\n      if (X[j] > value) break;\n    }\n    j -= 1;\n    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *\n        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];\n  },\n\n  gauss_quadrature: function gauss_quadrature() {\n    throw new Error('gauss_quadrature not yet implemented');\n  },\n\n  PCA: function PCA(X) {\n    var m = X.length;\n    var n = X[0].length;\n    var i = 0;\n    var j, temp1;\n    var u = [];\n    var D = [];\n    var result = [];\n    var temp2 = [];\n    var Y = [];\n    var Bt = [];\n    var B = [];\n    var C = [];\n    var V = [];\n    var Vt = [];\n    for (i = 0; i < m; i++) {\n      u[i] = jStat.sum(X[i]) / n;\n    }\n    for (i = 0; i < n; i++) {\n      B[i] = [];\n      for(j = 0; j < m; j++) {\n        B[i][j] = X[j][i] - u[j];\n      }\n    }\n    B = jStat.transpose(B);\n    for (i = 0; i < m; i++) {\n      C[i] = [];\n      for (j = 0; j < m; j++) {\n        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);\n      }\n    }\n    result = jStat.jacobi(C);\n    V = result[0];\n    D = result[1];\n    Vt = jStat.transpose(V);\n    for (i = 0; i < D.length; i++) {\n      for (j = i; j < D.length; j++) {\n        if(D[i] < D[j])  {\n          temp1 = D[i];\n          D[i] = D[j];\n          D[j] = temp1;\n          temp2 = Vt[i];\n          Vt[i] = Vt[j];\n          Vt[j] = temp2;\n        }\n      }\n    }\n    Bt = jStat.transpose(B);\n    for (i = 0; i < m; i++) {\n      Y[i] = [];\n      for (j = 0; j < Bt.length; j++) {\n        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);\n      }\n    }\n    return [X, D, Vt, Y];\n  }\n});\n\n// extend jStat.fn with methods that require one argument\n(function(funcs) {\n  for (var i = 0; i < funcs.length; i++) (function(passfunc) {\n    jStat.fn[passfunc] = function(arg, func) {\n      var tmpthis = this;\n      // check for callback\n      if (func) {\n        setTimeout(function() {\n          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));\n        }, 15);\n        return this;\n      }\n      if (typeof jStat[passfunc](this, arg) === 'number')\n        return jStat[passfunc](this, arg);\n      else\n        return jStat(jStat[passfunc](this, arg));\n    };\n  }(funcs[i]));\n}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));\n\n}(jStat, Math));\n(function(jStat, Math) {\n\nvar slice = [].slice;\nvar isNumber = jStat.utils.isNumber;\nvar isArray = jStat.utils.isArray;\n\n// flag==true denotes use of sample standard deviation\n// Z Statistics\njStat.extend({\n  // 2 different parameter lists:\n  // (value, mean, sd)\n  // (value, array, flag)\n  zscore: function zscore() {\n    var args = slice.call(arguments);\n    if (isNumber(args[1])) {\n      return (args[0] - args[1]) / args[2];\n    }\n    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, sides)\n  // (zscore, sides)\n  // (value, array, sides, flag)\n  ztest: function ztest() {\n    var args = slice.call(arguments);\n    var z;\n    if (isArray(args[1])) {\n      // (value, array, sides, flag)\n      z = jStat.zscore(args[0],args[1],args[3]);\n      return (args[2] === 1) ?\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :\n        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);\n    } else {\n      if (args.length > 2) {\n        // (value, mean, sd, sides)\n        z = jStat.zscore(args[0],args[1],args[2]);\n        return (args[3] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);\n      } else {\n        // (zscore, sides)\n        z = args[0];\n        return (args[1] === 1) ?\n          (jStat.normal.cdf(-Math.abs(z),0,1)) :\n          (jStat.normal.cdf(-Math.abs(z),0,1)*2);\n      }\n    }\n  }\n});\n\njStat.extend(jStat.fn, {\n  zscore: function zscore(value, flag) {\n    return (value - this.mean()) / this.stdev(flag);\n  },\n\n  ztest: function ztest(value, sides, flag) {\n    var zscore = Math.abs(this.zscore(value, flag));\n    return (sides === 1) ?\n      (jStat.normal.cdf(-zscore, 0, 1)) :\n      (jStat.normal.cdf(-zscore, 0, 1) * 2);\n  }\n});\n\n// T Statistics\njStat.extend({\n  // 2 parameter lists\n  // (value, mean, sd, n)\n  // (value, array)\n  tscore: function tscore() {\n    var args = slice.call(arguments);\n    return (args.length === 4) ?\n      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :\n      ((args[0] - jStat.mean(args[1])) /\n       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));\n  },\n\n  // 3 different paramter lists:\n  // (value, mean, sd, n, sides)\n  // (tscore, n, sides)\n  // (value, array, sides)\n  ttest: function ttest() {\n    var args = slice.call(arguments);\n    var tscore;\n    if (args.length === 5) {\n      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));\n      return (args[4] === 1) ?\n        (jStat.studentt.cdf(-tscore, args[3]-1)) :\n        (jStat.studentt.cdf(-tscore, args[3]-1)*2);\n    }\n    if (isNumber(args[1])) {\n      tscore = Math.abs(args[0])\n      return (args[2] == 1) ?\n        (jStat.studentt.cdf(-tscore, args[1]-1)) :\n        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);\n    }\n    tscore = Math.abs(jStat.tscore(args[0], args[1]))\n    return (args[2] == 1) ?\n      (jStat.studentt.cdf(-tscore, args[1].length-1)) :\n      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  tscore: function tscore(value) {\n    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));\n  },\n\n  ttest: function ttest(value, sides) {\n    return (sides === 1) ?\n      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :\n      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);\n  }\n});\n\n// F Statistics\njStat.extend({\n  // Paramter list is as follows:\n  // (array1, array2, array3, ...)\n  // or it is an array of arrays\n  // array of arrays conversion\n  anovafscore: function anovafscore() {\n    var args = slice.call(arguments),\n    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;\n    if (args.length === 1) {\n      tmpargs = new Array(args[0].length);\n      for (i = 0; i < args[0].length; i++) {\n        tmpargs[i] = args[0][i];\n      }\n      args = tmpargs;\n    }\n    // Builds sample array\n    sample = new Array();\n    for (i = 0; i < args.length; i++) {\n      sample = sample.concat(args[i]);\n    }\n    sampMean = jStat.mean(sample);\n    // Computes the explained variance\n    expVar = 0;\n    for (i = 0; i < args.length; i++) {\n      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);\n    }\n    expVar /= (args.length - 1);\n    // Computes unexplained variance\n    unexpVar = 0;\n    for (i = 0; i < args.length; i++) {\n      sampSampMean = jStat.mean(args[i]);\n      for (j = 0; j < args[i].length; j++) {\n        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);\n      }\n    }\n    unexpVar /= (sample.length - args.length);\n    return expVar / unexpVar;\n  },\n\n  // 2 different paramter setups\n  // (array1, array2, array3, ...)\n  // (anovafscore, df1, df2)\n  anovaftest: function anovaftest() {\n    var args = slice.call(arguments),\n    df1, df2, n, i;\n    if (isNumber(args[0])) {\n      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);\n    }\n    var anovafscore = jStat.anovafscore(args);\n    df1 = args.length - 1;\n    n = 0;\n    for (i = 0; i < args.length; i++) {\n      n = n + args[i].length;\n    }\n    df2 = n - df1 - 1;\n    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);\n  },\n\n  ftest: function ftest(fscore, df1, df2) {\n    return 1 - jStat.centralF.cdf(fscore, df1, df2);\n  }\n});\n\njStat.extend(jStat.fn, {\n  anovafscore: function anovafscore() {\n    return jStat.anovafscore(this.toArray());\n  },\n\n  anovaftes: function anovaftes() {\n    var n = 0;\n    var i;\n    for (i = 0; i < this.length; i++) {\n      n = n + this[i].length;\n    }\n    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);\n  }\n});\n\n// Tukey's range test\njStat.extend({\n  // 2 parameter lists\n  // (mean1, mean2, n1, n2, sd)\n  // (array1, array2, sd)\n  qscore: function qscore() {\n    var args = slice.call(arguments);\n    var mean1, mean2, n1, n2, sd;\n    if (isNumber(args[0])) {\n        mean1 = args[0];\n        mean2 = args[1];\n        n1 = args[2];\n        n2 = args[3];\n        sd = args[4];\n    } else {\n        mean1 = jStat.mean(args[0]);\n        mean2 = jStat.mean(args[1]);\n        n1 = args[0].length;\n        n2 = args[1].length;\n        sd = args[2];\n    }\n    return Math.abs(mean1 - mean2) / (sd * Math.sqrt((1 / n1 + 1 / n2) / 2));\n  },\n\n  // 3 different parameter lists:\n  // (qscore, n, k)\n  // (mean1, mean2, n1, n2, sd, n, k)\n  // (array1, array2, sd, n, k)\n  qtest: function qtest() {\n    var args = slice.call(arguments);\n\n    var qscore;\n    if (args.length === 3) {\n      qscore = args[0];\n      args = args.slice(1);\n    } else if (args.length === 7) {\n      qscore = jStat.qscore(args[0], args[1], args[2], args[3], args[4]);\n      args = args.slice(5);\n    } else {\n      qscore = jStat.qscore(args[0], args[1], args[2]);\n      args = args.slice(3);\n    }\n\n    var n = args[0];\n    var k = args[1];\n\n    return 1 - jStat.tukey.cdf(qscore, k, n - k);\n  },\n\n  tukeyhsd: function tukeyhsd(arrays) {\n    var sd = jStat.pooledstdev(arrays);\n    var means = arrays.map(function (arr) {return jStat.mean(arr);});\n    var n = arrays.reduce(function (n, arr) {return n + arr.length;}, 0);\n\n    var results = [];\n    for (var i = 0; i < arrays.length; ++i) {\n        for (var j = i + 1; j < arrays.length; ++j) {\n            var p = jStat.qtest(means[i], means[j], arrays[i].length, arrays[j].length, sd, n, arrays.length);\n            results.push([[i, j], p]);\n        }\n    }\n\n    return results;\n  }\n});\n\n// Error Bounds\njStat.extend({\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  normalci: function normalci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *\n                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  // 2 different parameter setups\n  // (value, alpha, sd, n)\n  // (value, alpha, array)\n  tci: function tci() {\n    var args = slice.call(arguments),\n    ans = new Array(2),\n    change;\n    if (args.length === 4) {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *\n                        args[2] / Math.sqrt(args[3]));\n    } else {\n      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *\n                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));\n    }\n    ans[0] = args[0] - change;\n    ans[1] = args[0] + change;\n    return ans;\n  },\n\n  significant: function significant(pvalue, alpha) {\n    return pvalue < alpha;\n  }\n});\n\njStat.extend(jStat.fn, {\n  normalci: function normalci(value, alpha) {\n    return jStat.normalci(value, alpha, this.toArray());\n  },\n\n  tci: function tci(value, alpha) {\n    return jStat.tci(value, alpha, this.toArray());\n  }\n});\n\n// internal method for calculating the z-score for a difference of proportions test\nfunction differenceOfProportions(p1, n1, p2, n2) {\n  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {\n    throw new Error(\"Proportions should be greater than 0 and less than 1\")\n  }\n  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);\n  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));\n  return (p1 - p2) / se;\n}\n\n// Difference of Proportions\njStat.extend(jStat.fn, {\n  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 1);\n  },\n\n  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {\n    var z = differenceOfProportions(p1, n1, p2, n2);\n    return jStat.ztest(z, 2);\n  }\n});\n\n}(jStat, Math));\njStat.models = (function(){\n  function sub_regress(exog) {\n    var var_count = exog[0].length;\n    var modelList = jStat.arange(var_count).map(function(endog_index) {\n      var exog_index =\n          jStat.arange(var_count).filter(function(i){return i!==endog_index});\n      return ols(jStat.col(exog, endog_index).map(function(x){ return x[0] }),\n                 jStat.col(exog, exog_index))\n    });\n    return modelList;\n  }\n\n  // do OLS model regress\n  // exog have include const columns ,it will not generate it .In fact, exog is\n  // \"design matrix\" look at\n  //https://en.wikipedia.org/wiki/Design_matrix\n  function ols(endog, exog) {\n    var nobs = endog.length;\n    var df_model = exog[0].length - 1;\n    var df_resid = nobs-df_model - 1;\n    var coef = jStat.lstsq(exog, endog);\n    var predict =\n        jStat.multiply(exog, coef.map(function(x) { return [x] }))\n            .map(function(p) { return p[0] });\n    var resid = jStat.subtract(endog, predict);\n    var ybar = jStat.mean(endog);\n    // constant cause problem\n    // var SST = jStat.sum(endog.map(function(y) {\n    //   return Math.pow(y-ybar,2);\n    // }));\n    var SSE = jStat.sum(predict.map(function(f) {\n      return Math.pow(f - ybar, 2);\n    }));\n    var SSR = jStat.sum(endog.map(function(y, i) {\n      return Math.pow(y - predict[i], 2);\n    }));\n    var SST = SSE + SSR;\n    var R2 = (SSE / SST);\n    return {\n        exog:exog,\n        endog:endog,\n        nobs:nobs,\n        df_model:df_model,\n        df_resid:df_resid,\n        coef:coef,\n        predict:predict,\n        resid:resid,\n        ybar:ybar,\n        SST:SST,\n        SSE:SSE,\n        SSR:SSR,\n        R2:R2\n    };\n  }\n\n  // H0: b_I=0\n  // H1: b_I!=0\n  function t_test(model) {\n    var subModelList = sub_regress(model.exog);\n    //var sigmaHat=jStat.stdev(model.resid);\n    var sigmaHat = Math.sqrt(model.SSR / (model.df_resid));\n    var seBetaHat = subModelList.map(function(mod) {\n      var SST = mod.SST;\n      var R2 = mod.R2;\n      return sigmaHat / Math.sqrt(SST * (1 - R2));\n    });\n    var tStatistic = model.coef.map(function(coef, i) {\n      return (coef - 0) / seBetaHat[i];\n    });\n    var pValue = tStatistic.map(function(t) {\n      var leftppf = jStat.studentt.cdf(t, model.df_resid);\n      return (leftppf > 0.5 ? 1 - leftppf : leftppf) * 2;\n    });\n    var c = jStat.studentt.inv(0.975, model.df_resid);\n    var interval95 = model.coef.map(function(coef, i) {\n      var d = c * seBetaHat[i];\n      return [coef - d, coef + d];\n    })\n    return {\n        se: seBetaHat,\n        t: tStatistic,\n        p: pValue,\n        sigmaHat: sigmaHat,\n        interval95: interval95\n    };\n  }\n\n  function F_test(model) {\n    var F_statistic =\n        (model.R2 / model.df_model) / ((1 - model.R2) / model.df_resid);\n    var fcdf = function(x, n1, n2) {\n      return jStat.beta.cdf(x / (n2 / n1 + x), n1 / 2, n2 / 2)\n    }\n    var pvalue = 1 - fcdf(F_statistic, model.df_model, model.df_resid);\n    return { F_statistic: F_statistic, pvalue: pvalue };\n  }\n\n  function ols_wrap(endog, exog) {\n    var model = ols(endog,exog);\n    var ttest = t_test(model);\n    var ftest = F_test(model);\n    // Provide the Wherry / Ezekiel / McNemar / Cohen Adjusted R^2\n    // Which matches the 'adjusted R^2' provided by R's lm package\n    var adjust_R2 =\n        1 - (1 - model.R2) * ((model.nobs - 1) / (model.df_resid));\n    model.t = ttest;\n    model.f = ftest;\n    model.adjust_R2 = adjust_R2;\n    return model;\n  }\n\n  return { ols: ols_wrap };\n})();\n//To regress, simply build X matrix\n//(append column of 1's) using\n//buildxmatrix and build the Y\n//matrix using buildymatrix\n//(simply the transpose)\n//and run regress.\n\n\n\n//Regressions\n\njStat.extend({\n  buildxmatrix: function buildxmatrix(){\n    //Parameters will be passed in as such\n    //(array1,array2,array3,...)\n    //as (x1,x2,x3,...)\n    //needs to be (1,x1,x2,x3,...)\n    var matrixRows = new Array(arguments.length);\n    for(var i=0;i<arguments.length;i++){\n      var array = [1];\n      matrixRows[i]= array.concat(arguments[i]);\n    }\n    return jStat(matrixRows);\n\n  },\n\n  builddxmatrix: function builddxmatrix() {\n    //Paramters will be passed in as such\n    //([array1,array2,...]\n    var matrixRows = new Array(arguments[0].length);\n    for(var i=0;i<arguments[0].length;i++){\n      var array = [1]\n      matrixRows[i]= array.concat(arguments[0][i]);\n    }\n    return jStat(matrixRows);\n\n  },\n\n  buildjxmatrix: function buildjxmatrix(jMat) {\n    //Builds from jStat Matrix\n    var pass = new Array(jMat.length)\n    for(var i=0;i<jMat.length;i++){\n      pass[i] = jMat[i];\n    }\n    return jStat.builddxmatrix(pass);\n\n  },\n\n  buildymatrix: function buildymatrix(array){\n    return jStat(array).transpose();\n  },\n\n  buildjymatrix: function buildjymatrix(jMat){\n    return jMat.transpose();\n  },\n\n  matrixmult: function matrixmult(A,B){\n    var i, j, k, result, sum;\n    if (A.cols() == B.rows()) {\n      if(B.rows()>1){\n        result = [];\n        for (i = 0; i < A.rows(); i++) {\n          result[i] = [];\n          for (j = 0; j < B.cols(); j++) {\n            sum = 0;\n            for (k = 0; k < A.cols(); k++) {\n              sum += A.toArray()[i][k] * B.toArray()[k][j];\n            }\n            result[i][j] = sum;\n          }\n        }\n        return jStat(result);\n      }\n      result = [];\n      for (i = 0; i < A.rows(); i++) {\n        result[i] = [];\n        for (j = 0; j < B.cols(); j++) {\n          sum = 0;\n          for (k = 0; k < A.cols(); k++) {\n            sum += A.toArray()[i][k] * B.toArray()[j];\n          }\n          result[i][j] = sum;\n        }\n      }\n      return jStat(result);\n    }\n  },\n\n  //regress and regresst to be fixed\n\n  regress: function regress(jMatX,jMatY){\n    //print(\"regressin!\");\n    //print(jMatX.toArray());\n    var innerinv = jStat.xtranspxinv(jMatX);\n    //print(innerinv);\n    var xtransp = jMatX.transpose();\n    var next = jStat.matrixmult(jStat(innerinv),xtransp);\n    return jStat.matrixmult(next,jMatY);\n\n  },\n\n  regresst: function regresst(jMatX,jMatY,sides){\n    var beta = jStat.regress(jMatX,jMatY);\n\n    var compile = {};\n    compile.anova = {};\n    var jMatYBar = jStat.jMatYBar(jMatX, beta);\n    compile.yBar = jMatYBar;\n    var yAverage = jMatY.mean();\n    compile.anova.residuals = jStat.residuals(jMatY, jMatYBar);\n\n    compile.anova.ssr = jStat.ssr(jMatYBar, yAverage);\n    compile.anova.msr = compile.anova.ssr / (jMatX[0].length - 1);\n\n    compile.anova.sse = jStat.sse(jMatY, jMatYBar);\n    compile.anova.mse =\n        compile.anova.sse / (jMatY.length - (jMatX[0].length - 1) - 1);\n\n    compile.anova.sst = jStat.sst(jMatY, yAverage);\n    compile.anova.mst = compile.anova.sst / (jMatY.length - 1);\n\n    compile.anova.r2 = 1 - (compile.anova.sse / compile.anova.sst);\n    if (compile.anova.r2 < 0) compile.anova.r2 = 0;\n\n    compile.anova.fratio = compile.anova.msr / compile.anova.mse;\n    compile.anova.pvalue =\n        jStat.anovaftest(compile.anova.fratio,\n                         jMatX[0].length - 1,\n                         jMatY.length - (jMatX[0].length - 1) - 1);\n\n    compile.anova.rmse = Math.sqrt(compile.anova.mse);\n\n    compile.anova.r2adj = 1 - (compile.anova.mse / compile.anova.mst);\n    if (compile.anova.r2adj < 0) compile.anova.r2adj = 0;\n\n    compile.stats = new Array(jMatX[0].length);\n    var covar = jStat.xtranspxinv(jMatX);\n    var sds, ts, ps;\n\n    for(var i=0; i<beta.length;i++){\n      sds=Math.sqrt(compile.anova.mse * Math.abs(covar[i][i]));\n      ts= Math.abs(beta[i] / sds);\n      ps= jStat.ttest(ts, jMatY.length - jMatX[0].length - 1, sides);\n\n      compile.stats[i]=[beta[i], sds, ts, ps];\n    }\n\n    compile.regress = beta;\n    return compile;\n  },\n\n  xtranspx: function xtranspx(jMatX){\n    return jStat.matrixmult(jMatX.transpose(),jMatX);\n  },\n\n\n  xtranspxinv: function xtranspxinv(jMatX){\n    var inner = jStat.matrixmult(jMatX.transpose(),jMatX);\n    var innerinv = jStat.inv(inner);\n    return innerinv;\n  },\n\n  jMatYBar: function jMatYBar(jMatX, beta) {\n    var yBar = jStat.matrixmult(jMatX, beta);\n    return new jStat(yBar);\n  },\n\n  residuals: function residuals(jMatY, jMatYBar) {\n    return jStat.matrixsubtract(jMatY, jMatYBar);\n  },\n\n  ssr: function ssr(jMatYBar, yAverage) {\n    var ssr = 0;\n    for(var i = 0; i < jMatYBar.length; i++) {\n      ssr += Math.pow(jMatYBar[i] - yAverage, 2);\n    }\n    return ssr;\n  },\n\n  sse: function sse(jMatY, jMatYBar) {\n    var sse = 0;\n    for(var i = 0; i < jMatY.length; i++) {\n      sse += Math.pow(jMatY[i] - jMatYBar[i], 2);\n    }\n    return sse;\n  },\n\n  sst: function sst(jMatY, yAverage) {\n    var sst = 0;\n    for(var i = 0; i < jMatY.length; i++) {\n      sst += Math.pow(jMatY[i] - yAverage, 2);\n    }\n    return sst;\n  },\n\n  matrixsubtract: function matrixsubtract(A,B){\n    var ans = new Array(A.length);\n    for(var i=0;i<A.length;i++){\n      ans[i] = new Array(A[i].length);\n      for(var j=0;j<A[i].length;j++){\n        ans[i][j]=A[i][j]-B[i][j];\n      }\n    }\n    return jStat(ans);\n  }\n});\n  // Make it compatible with previous version.\n  jStat.jStat = jStat;\n\n  return jStat;\n});\n\n\n//# sourceURL=webpack://visualization-tool-uctb/./node_modules/jstat/dist/jstat.js?");

/***/ }),

/***/ "./node_modules/ml-array-max/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-max/lib-es6/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ max)\n/* harmony export */ });\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ \"./node_modules/is-any-array/lib-esm/index.js\");\n\n\nfunction max(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var _options$fromIndex = options.fromIndex,\n      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,\n      _options$toIndex = options.toIndex,\n      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;\n\n  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {\n    throw new Error('fromIndex must be a positive integer smaller than length');\n  }\n\n  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {\n    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');\n  }\n\n  var maxValue = input[fromIndex];\n\n  for (var i = fromIndex + 1; i < toIndex; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\n\n\n\n//# sourceURL=webpack://visualization-tool-uctb/./node_modules/ml-array-max/lib-es6/index.js?");

/***/ }),

/***/ "./node_modules/ml-array-min/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-min/lib-es6/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ min)\n/* harmony export */ });\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ \"./node_modules/is-any-array/lib-esm/index.js\");\n\n\nfunction min(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var _options$fromIndex = options.fromIndex,\n      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,\n      _options$toIndex = options.toIndex,\n      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;\n\n  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {\n    throw new Error('fromIndex must be a positive integer smaller than length');\n  }\n\n  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {\n    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');\n  }\n\n  var minValue = input[fromIndex];\n\n  for (var i = fromIndex + 1; i < toIndex; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\n\n\n\n//# sourceURL=webpack://visualization-tool-uctb/./node_modules/ml-array-min/lib-es6/index.js?");

/***/ }),

/***/ "./node_modules/ml-isolation-forest/src/IsolationForest.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ml-isolation-forest/src/IsolationForest.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsolationForest\": () => (/* binding */ IsolationForest)\n/* harmony export */ });\n/* harmony import */ var _TreeNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TreeNode */ \"./node_modules/ml-isolation-forest/src/TreeNode.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./node_modules/ml-isolation-forest/src/Utils.js\");\n\n\n\nclass IsolationForest {\n  /**\n   * Create a new instance of IsolationForest\n   * @constructor\n   * @param {object} options - options for the IsolationForest\n   * @param {number} [options.nEstimators=100] - number of trees/estimators to use in the forest\n   */\n  constructor(options) {\n    if (options) {\n      this.nEstimators = options.nEstimators || 100;\n    }\n    this.nEstimators = this.nEstimators || 100;\n    this.forest = [];\n  }\n\n  /**\n   * Train the trees in the Isolation Forest with the given training set\n   * @param {number[][]} - trainingSet for building the isolation forest\n   */\n  train(trainingSet) {\n    this.trainingSet = trainingSet;\n    const maxDepth = Math.ceil(Math.log2(this.trainingSet.length));\n\n    for (let i = 0; i < this.nEstimators; i++) {\n      const tree = new _TreeNode__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({ depth: 0, maxDepth: maxDepth });\n      tree.train(trainingSet, 0);\n      this.forest.push(tree);\n    }\n  }\n\n  /**\n   * Predict the anomalies in the set\n   * @param {number[][]} - set of data for which to find the anomalies\n   * @return {number[]} - returns the anomaly scores for the data points\n   */\n  predict(data) {\n    const anomalyScores = [];\n    for (const row of data) {\n      let totalLengthsOfPathsFromRoot = 0;\n      for (let i = 0; i < this.nEstimators; i++) {\n        totalLengthsOfPathsFromRoot += this.forest[i].pathLengthFromRoot(\n          row,\n          0,\n        );\n      }\n      const averagePathLength = totalLengthsOfPathsFromRoot / this.nEstimators;\n      const anomalyScore =\n        2 **\n        (-averagePathLength /\n          (0,_Utils__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.trainingSet.length));\n      anomalyScores.push(anomalyScore);\n    }\n    return anomalyScores;\n  }\n}\n\n\n//# sourceURL=webpack://visualization-tool-uctb/./node_modules/ml-isolation-forest/src/IsolationForest.js?");

/***/ }),

/***/ "./node_modules/ml-isolation-forest/src/TreeNode.js":
/*!**********************************************************!*\
  !*** ./node_modules/ml-isolation-forest/src/TreeNode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TreeNode)\n/* harmony export */ });\n/* harmony import */ var ml_array_max__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ml-array-max */ \"./node_modules/ml-array-max/lib-es6/index.js\");\n/* harmony import */ var ml_array_min__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ml-array-min */ \"./node_modules/ml-array-min/lib-es6/index.js\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ \"./node_modules/ml-isolation-forest/src/Utils.js\");\n\n\n\n\n\nclass TreeNode {\n  /**\n   * Constructor for a tree node used in an isolation forest\n   * @param {object} options - options for the TreeNode\n   * @param {number} options.depth - the depth of the TreeNode\n   * @param {number} options.maxDepth - the maximum depth possible for the TreeNode\n   * @constructor\n   */\n  constructor(options) {\n    if (options) {\n      this.depth = options.depth;\n      this.maxDepth = options.maxDepth;\n    }\n  }\n\n  /**\n   * Train a node for the isolation forest given the training set\n   * @param {number[][]} trainingSet - training set used to train the isolation tree\n   * @param {number} currentDepth - depth of the node which is currently trained\n   */\n  train(trainingSet, currentDepth) {\n    if (currentDepth <= this.maxDepth && trainingSet.length > 1) {\n      this.left = new TreeNode(this);\n      this.right = new TreeNode(this);\n\n      const numberFeatures = trainingSet[0].length;\n      this.splitColumn = Math.floor(Math.random() * numberFeatures);\n      const valuesForFeature = trainingSet.map((row) => row[this.splitColumn]);\n\n      const maxValueFeature = (0,ml_array_max__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(valuesForFeature);\n      const minValueFeature = (0,ml_array_min__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(valuesForFeature);\n\n      this.splitValue =\n        Math.random() * (maxValueFeature - minValueFeature) + minValueFeature;\n\n      const smallerThanSplitValue = trainingSet.filter(\n        (row) => row[this.splitColumn] < this.splitValue,\n      );\n      const biggerThanSplitValue = trainingSet.filter(\n        (row) => row[this.splitColumn] >= this.splitValue,\n      );\n\n      this.left.train(smallerThanSplitValue, currentDepth + 1);\n      this.right.train(biggerThanSplitValue, currentDepth + 1);\n    } else {\n      this.trainingSet = trainingSet;\n    }\n  }\n\n  /**\n   * Verifies whether the current node is a leaf node in the tree it belongs to\n   * @returns a boolean\n   */\n  isLeafNode() {\n    return this.left === undefined && this.right === undefined;\n  }\n\n  /**\n   * Verifies whether the current node is an inner node in the tree it belongs to\n   * @returns a boolean\n   */\n  isInnerNode() {\n    return this.left !== undefined && this.right !== undefined;\n  }\n\n  /**\n   * Returns the number of data points in the current node\n   * @returns the number of data points\n   */\n  numberDataPoints() {\n    if (this.trainingSet !== undefined) {\n      return this.trainingSet.length;\n    }\n    return 0;\n  }\n\n  /**\n   * Returns the length of the path from the root to isolate the data point\n   * @param {number[]} data - data point for which to predict the anomaly score\n   * @param {number} currentPathLengthFromRoot - the current path length from the root\n   * @returns\n   */\n  pathLengthFromRoot(data, currentPathLengthFromRoot) {\n    if (this.isLeafNode()) {\n      return (\n        currentPathLengthFromRoot +\n        (0,_Utils__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.numberDataPoints())\n      );\n    }\n    const splitColumn = this.splitColumn;\n    if (data[splitColumn] < this.splitValue) {\n      return this.left.pathLengthFromRoot(data, currentPathLengthFromRoot + 1);\n    } else {\n      return this.right.pathLengthFromRoot(data, currentPathLengthFromRoot + 1);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://visualization-tool-uctb/./node_modules/ml-isolation-forest/src/TreeNode.js?");

/***/ }),

/***/ "./node_modules/ml-isolation-forest/src/Utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/ml-isolation-forest/src/Utils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ averagePathLengthFromRoot)\n/* harmony export */ });\n/**\n * Returns the average path length of the nodes in a tree from the root given the number of training data points\n * @param {number} sizeDataset - the number of data training points\n * @returns - the average path length from the root\n */\nfunction averagePathLengthFromRoot(sizeDataset) {\n  if (sizeDataset === 0 || sizeDataset === 1) {\n    return 0;\n  } else if (sizeDataset === 2) {\n    return 1;\n  }\n  return (\n    2 * Math.log(sizeDataset - 1) +\n    0.57721 -\n    (2 * (sizeDataset - 1)) / sizeDataset\n  );\n}\n\n\n//# sourceURL=webpack://visualization-tool-uctb/./node_modules/ml-isolation-forest/src/Utils.js?");

/***/ }),

/***/ "./node_modules/ml-isolation-forest/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/ml-isolation-forest/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IsolationForest\": () => (/* reexport safe */ _IsolationForest__WEBPACK_IMPORTED_MODULE_0__.IsolationForest)\n/* harmony export */ });\n/* harmony import */ var _IsolationForest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IsolationForest */ \"./node_modules/ml-isolation-forest/src/IsolationForest.js\");\n\n\n\n//# sourceURL=webpack://visualization-tool-uctb/./node_modules/ml-isolation-forest/src/index.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ __webpack_require__("./public/js/js.js");
/******/ __webpack_require__("./public/js/draw.js");
/******/ __webpack_require__("./public/js/anomaly_detection.js");
/******/ __webpack_require__("./public/js/line_final.js");
/******/ __webpack_require__("./public/js/map.js");
/******/ var __webpack_exports__ = __webpack_require__("./public/js/myfun.js");
/******/ module.exports = __webpack_exports__;
/******/ 
